<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决Mac无法写入U盘问题]]></title>
    <url>%2F%2Fblog%2Fupan-for-mac%2F</url>
    <content type="text"><![CDATA[前言​ 新手使用MacBook Pro时，会发现Mac系统下只能读取U盘，但不能写入。其实这个问题是因为，Mac OS系统硬盘格式为HFS， Windows 的硬盘格式为 NTFS，二者互不兼容。那么有没有解决的办法呢？ 网上的资料一般都安装第三方软件，如 NTFS for MAC 等，但一般都是收费的。或者，格式化U盘，将U盘磁盘格式设定为 FAT 或 exFAT，但个人不提倡。 现在提供一种方法进行开启 Mac OS 读写 NTFS格式 U盘的功能。经过测试！ 实现步骤1、打开 终端，输入：1diskutil list 该命令用于列出系统下的各个磁盘信息，找到你要处理的U盘名称，如名称为：Chloneda。 2、在终端中，输入：1sudo vim /etc/fstab 然后输入电脑密码（没有密码的不用输），输入电脑密码后，加入以下内容，进行配置：1LABEL=U盘名称 none ntfs rw,auto,nobrowse 如下图： 注意：如果你的U盘只有一个，只需添加一个即可，不能有空行！其次，如果你的U盘含有空格，如 Chloneda X，U盘名称中的空格用\040代替，即命令应该写成：1LABEL=Chloneda\040X none ntfs rw,auto,nobrowse 参数说明： U盘名称：建议不要有中文。 ntfs rw： 表示把这个分区挂载为可读写的 ntfs格式。 nobrowse：这个代表了在 finder 里不显示这个分区，这个选项非常重要，如果不打开的话挂载会失败。完成后，按 esc 键退出编辑模式，并按 :wq! 命令，然后回车进行保存。 3、创建快捷方式终端中输入以下内容，创建桌面快捷方式。1sudo ln -s /Volumes/U盘名称 ~/Desktop/U盘名称 因为刚刚创建的分区是不会在 Finder 里不显示的,创建桌面快捷方式，方便以后再次访问U盘（可将 快捷方式 拖拽至 Finder 的侧边栏喔）。 4、拔掉U盘，重新插入，可见正常显示，正常读写。 补充1、如果不可以写入U盘，请重启一下电脑。2、如果要恢复之前样子，请输入命令 sudo vim /etc/fstab 重新编辑，把写入的 LABEL 一行删除，重新保存即可。]]></content>
      <categories>
        <category>采坑日记</category>
      </categories>
      <tags>
        <tag>采坑日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker容器Centos不能使用systemctl命令问题]]></title>
    <url>%2F%2Fblog%2Fbug-dock-os%2F</url>
    <content type="text"><![CDATA[注：本文出自博主：chloneda 最近使用Docker搭建Centos容器时遇到这样的问题：Centos系统的不能使用systemctl命令! 具体场景使用 systemctl 或 service 命令重启服务时。1systemctl restart snmpd.service 会报无权限的错误：1Failed to get D-Bus connection: Operation not permitted； 这是docker中centos7的bug，官网上也提到了这个问题，并给出了 解决办法，但有点复杂。我们可以通过以下方法解决！ 首先，使用docker构建centos容器加上 privileged 参数，即在docker run命令是要加上 –privileged=true，该参数在docker容器运行时，让系统拥有真正的root权限。 其次，在启动容器时，在docker run 命令最后，加上/usr/sbin/init，最终命令为：1docker run -v /tmp/:/tmp --privileged --cap-add SYS_ADMIN -e container=docker -it --name=centos -d --restart=always centos /usr/sbin/init 参数说明： -v /tmp/:/tmp：挂载宿主机的一个目录，冒号”:”前面的目录是宿主机目录，后面的目录是容器内目录。 –privileged： 指定容器是否是特权容器。 –cap-add SYS_ADMIN： 添加系统的权限，不然系统很多功能都用不了的。 -e container=docker：设置容器的类型。 -it： 启动互动模式。 /usr/sbin/init：初始容器里的CENTOS，用于启动dbus-daemon。 最后，如果想查看Docker更多内容，请查看Docker官网文档。]]></content>
      <categories>
        <category>采坑日记</category>
      </categories>
      <tags>
        <tag>采坑日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些优秀的软件工具！]]></title>
    <url>%2F%2Fblog%2Ftools%2F</url>
    <content type="text"><![CDATA[注：本文出自博主：chloneda 本博客用于收录那些优秀的软件工具，并且长期更新！ Windowseverythingeverything：是速度最快的文件名搜索软件。其速度之快令人震惊，百G硬盘几十万个文件，可以在几秒钟之内完成索引；文件名搜索瞬间呈现结果。它小巧免费，支持中文，支持正则表达式，可以通过HTTP或FTP分享搜索结果。如果不满意Windows自带的搜索工具，那就用它吧！ MacOseZipeZip：是一款 Mac 上完全免费的压缩与解压缩工具软件，主要是提供了文件预览以及加密压缩和解压缩功能，功能足够实用，基本可以替代市面上大部分的 macOS 商业收费压缩工具，个人认为值得力荐。 OmniGraffleOmniGraffle：Windows下使用Visio画框图、流程图非常方便，切换到MAC后，我们可以使用OmniGraffle。 CheatSheetCheatSheet：Mac上的快捷键神器 LinuxRemminaRemmina：是一款在 Linux 和其他类 Unix 系统下的自由开源、功能丰富、强大的远程桌面客户端，它用 GTK+ 3 编写而成。它适用于那些需要远程访问及使用许多计算机的系统管理员和在外出行人员。]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git同步代码至github和gitee(码云)]]></title>
    <url>%2F%2Fblog%2Fgit-to-github-gitee%2F</url>
    <content type="text"><![CDATA[注：本文出自博主：chloneda 我们有时候开发代码需要把代码同步到多个远程库中，如何操作才能做到呢？ 我们知道，git是分布式版本控制系统，同步到多个远程库时，需要用不同的名称来标识不同的远程库，而git给远程库起的默认名称是origin。所以我们需要修改、配置名称，以关联不同远程库。有两种方式！ 为了方便举例，我以GitHub和Gitee(码云)作为示例！ 同步方式命令方式同步先删除已关联的名为origin的远程库：1git remote rm origin 然后，再关联GitHub的远程库：1git remote add github git@github.com:chloneda/demo.git 接着，再关联码云的远程库：1git remote add gitee git@gitee.com:chloneda/demo.git 配置方式同步修改.git文件夹内的config文件：1234567891011[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true[remote "origin"] url = git@github.com:chloneda/demo.git fetch = +refs/heads/*:refs/remotes/github/*[branch "master"] remote = origin merge = refs/heads/master 将上述文件内容[remote “origin”]内容复制，修改origin名称，内容如下：1234567891011121314[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true[remote "github"] url = git@github.com:chloneda/demo.git fetch = +refs/heads/*:refs/remotes/github/*[remote "gitee"] url = git@gitee.com:chloneda/demo.git fetch = +refs/heads/*:refs/remotes/gitee/*[branch "master"] remote = origin merge = refs/heads/master 查看远程库通过以上两种方式的任一种方式配置完成后，我们用git remote -v查看远程库信息：1234gitee git@gitee.com:chloneda/demo.git (fetch)gitee git@gitee.com:chloneda/demo.git (push)github git@github.com:chloneda/demo.git (fetch)github git@github.com:chloneda/demo.git (push) 可以看到两个远程库，说明配置生效了。 上传代码12git add .git commit -m "update" 提交到github1git push github master 提交到码云1git push gitee master 更新代码12345# 从github拉取更新git pull github# 从gitee拉取更新git pull gitee 踩到的坑上述过程中，更新或提交代码时可能会遇到fatal:refusing to merge unrelated histories (拒绝合并无关的历史) 错误，解决办法： 首先将远程仓库和本地仓库关联起来。 1git branch --set-upstream-to=origin/remote_branch your_branch 其中，origin/remote_branch是你本地分支对应的远程分支，your_branch是你当前的本地分支。 然后使用git pull整合远程仓库和本地仓库。1git pull --allow-unrelated-histories (忽略版本不同造成的影响) 重新更新、提交即可。 注： 如遇到 Git没有共同祖先的两个分支合并 的情形请自行查询！]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊SNMP协议]]></title>
    <url>%2F%2Fblog%2Fsnmp-protocol%2F</url>
    <content type="text"><![CDATA[注：本文出自博主：chloneda SNMP概述SNMP(Simple Network Management Protocol):简单网络管理协议,是基于TCP/IP五层协议中的应用层协议。由于其简单可靠，提供了一种监控和管理网络设备的系统方法，因此受到了众多厂商的欢迎，成为了目前最为广泛的网管协议。 SNMP的基本思想：为不同种类、厂家、型号的设备，定义一个统一的接口和协议，使得管理员可以是使用统一的外观面对这些需要管理的网络设备。通过网络，管理员可以管理位于不同物理空间的设备，从而大大提高网络管理的效率，简化网络管理员的工作。 Snmp版本SNMP目前共有v1，v2，v3这三个版本，三个版本的联系与区别。 SNMP v1：是SNMP协议的最初版本，存在较多安全缺陷，现在这个版本是使用的比较少了。 SNMP v2：也采用团体名认证,在兼容SNMPv1的同时又扩充了SNMPv1的功能，具体是扩展了数据类型、支持分布式网络管理、可以实现大量数据的传输，提高了效率和性能、丰富了故障处理能力及增加了集合处理功能。 SNMP v3：是最新版本的SNMP。它相对于V2版本，在安全性上得到了重要提升，增加了对认证和密文传输的支持。 SNMP核心概念SNMP管理架构SNMP管理架构应包含四个部分进行网络管理：SNMP管理站、SNMP代理、MIB(管理信息库)和SNMP管理协议。 SNMP管理站（management station）：通常被称作为网络管理工作站（NMS），负责收集维护各个SNMP元素的信息，通过UDP协议向SNMP代理发送各种命令，当SNMP代理收到命令后，对收集的信息进行处理，并返回SNMP管理站需要的参数。而此时被管理对象中一定要有代理进程，这样才能响应管理站发来的请求。 SNMP代理(Agent)：运行在各个被管理的网络节点之上，负责统计该节点的各项信息，并且负责与SNMP管理站交互，接收并执行管理站的命令，上传各种本地的网络信息。 注：协议栈中带有阴影的部分是原主机或路由器所具有的，而没有阴影的部分是为实现网络管理而增加的。 MIB(管理信息库)：是对象的集合，它代表网络中可以管理的资源和设备。每个对象基本上是一个数据变量，它代表被管理的对象的一方面的信息。 SNMP管理协议：用于管理站与SNMP代理之间的通信规则，其SNMP报文格式请查看底下章节。 管理站和代理之间利用 SNMP 报文进行通信，而 SNMP 报文又使用 UDP协议来传送，由于采用UDP协议，不需要在代理和管理站之间保持连接。 SNMP报文格式管理站（NMS）和代理（Agent）之间交换的管理信息构成了SNMP报文，报文的基本格式如下图： 下面将对该SNMP报文格式逐个进行说明！ SNMP消息报文包含两个部分：SNMP报头和PDU(协议数据单元)。 SNMP报头 版本：版本号字段，规则为版本号减 1，如SNMP V1则应写入 0。如果SNMP代理使用不相同的协议，会直接抛弃与自己协议版本不同的数据报。 共同体(community)：即团体名，作为管理进程和代理进程之间的明文口令，相当于密码，默认为public，该字段可读可写，用来限制NMS对Agent的访问。如果团体名没有得到NMS/Agent的认可，该报文将被丢弃。 PDU 类型：填入 0～4 中的一个数字，其对应关系如图。 PDU类型请参考PDU(协议数据单元)章节！ Get/Set 首部 请求标识符(request ID)，这是由管理进程设置的一个整数值。代理进程在发送 get-response 报文时也要返回此请求标识符。管理进程可同时向许多代理发出 get 报文，这些报文都使用 UDP 传送，先发送的有可能后到达。设置了请求标识符可使管理进程能够识别返回的响应报文对于哪一个请求。 差错状态（error status）：由代理进程回答时填入 0～5 中的一个数字，见表 3 的描述。 差错索引(error index)：当出现 noSuchName、badValue 或 readOnly 的差错时，由代理进程在回答时设置的一个整数，它指明有差错的变量在变量列表中的偏移。 Trap 首部 企业（enterprise）：填入 trap 报文的网络设备的对象标识符。此对象标识符肯定是在图 3 的对象命名树上的 enterprise 结点{1.3.6.1.4.1}下面的一棵子树上。 Trap 类型：此字段正式的名称是 generic-trap，共分为表 4 中的 7 种。 当使用上述类型 2、3、5 时，在报文后面变量部分的第一个变量应标识响应的接口。 特定代码(specific-code)：指明代理自定义的时间（若 trap 类型为 6），否则为 0。 时间戳(timestamp)：指明自代理进程初始化到 trap 报告的事件发生所经历的时间，单位为 10ms。例如时间戳为 1908 表明在代理初始化后 1908ms 发生了该时间。 变量绑定(variable-bindings)：指明一个或多个变量的名和对应的值。在 get 或 get-next 报文中，变量的值应忽略。 PDU(协议数据单元)SNMP v1 版本规定了 5 种核心 PDU(协议数据单元)，用来在管理进程和代理之间信息的交换。 get-request 操作：从代理进程处提取一个OID值。 get-next-request 操作：从代理进程(MIB中)处提取紧跟当前参数值的下一个OID值，常被用于检索表数据，也被用于不能指定名称的变量,可以浏览MIB树。 set-request 操作：设置代理进程的一个或多个参数值。 get-response 操作：返回的一个或多个参数值。这个操作是由代理进程发出的，它是前面三种操作的响应操作。 trap 操作：代理进程主动发出的报文，通知管理进程有某些事情发生。 前面的 3 种操作是由管理进程向代理进程发出的，后面的 2 个操作是代理进程发给管理进程的，其中代理进程端是用 161 端口接收 get 或 set 报文，而在管理进程端是用 162 端口来接收 trap 报文。 另外，在SNMP v2版本又增加了 3 种PDU(协议数据单元)，它们分别是： inform-request 操作：允许路由器向SNMP管理器发送通知请求。 getBulk-request 操作：从代理进程处提取多个参数值,该操作会根据最大重试值执行一连串的GetNext操作，减少管理站与代理之间的交互,提高效率。 report 操作： SNMP的操作类型其实上述 8 种PDU(协议数据单元)按照功能不同，可以归结为三类操作。 查询、设置SNMP变量,如get-request、get-next-request、set-request、getBulk-request、inform-request。 应答请求,如 get-response。 事件报告，如trap。 实际上，在SNMP中，SNMP管理站对被管理设备的SNMP变量的操作只能有 读 与 写 两种基本动作。 ASN.1(抽象语法标记)ASN.1：高级的数据描述语言。描述数据的类型、结构、组织、及编码方法。包括符号和语法两部分。SNMP使用ASN.1描述PDU和MIB(管理信息库)。 关于ASN.1详细信息请查看这篇博文：SNMP从入门到开发：进阶篇 BER(基本编码规则)BER(Basic Encoding Rule)，中文名称：基本编码规则。描述具体的ASN.1对象如何编码为比特流在网络上传输。SNMP使用BER(Basic Encoding Rule)作为编码方案，数据首先先经过BER编码，再经由传输层协议(一边是UDP)发往接收方。接收方在SNMP端口上收到PDU后，经过BER解码后，得到具体的SNMP操作数据。 BER的数据都由三个域构成:标识域(tag)+长度域(length)+值域(value)。 SMI(管理信息结构)SMI(Structure of Managerment Intormation)，中文名称：管理信息结构，是SNMP的描述方法。规定了使用ASN.1子类型、符号。ASN.1功能强大，但SNMP只用到了其中很小一部分，对于这一部分内容的描述，限定了范围，即为SMI。SMI规定了使用到的ASN.1类型、宏、符号等。SMI是ASN.1的一个子集和超集。 MIB(管理信息库)MIB(Management Information Base)，中文名称：管理信息库，由网络管理协议访问的管理对象数据库。MIB是对象的集合，它代表网络中可以管理的资源和设备。每个对象基本上是一个数据变量，它代表被管理的对象的一方面的信息。 管理信息库 MIB 指明了网络元素所维持的变量（即能够被管理进程查询和设置的信息）。MIB 给出了一个网络中所有可能的被管理对象的集合的数据结构。SNMP 的管理信息库采用和域名系统 DNS 相似的树型结构，它的根在最上面，根没有名字。底下的图 画的是管理信息库的一部分，它又称为对象命名（object naming tree）。 MIB采用分层树形结构，对象命名树的顶级对象有三个，即 ISO、ITU-T 和这两个组织的联合体。在 ISO 的下面有 4 个结点，其中的饿一个（标号 3）是被标识的组织。在其下面有一个美国国防部（Department of Defense）的子树（标号是 6），再下面就是 Internet（标号是 1）。在只讨论 Internet 中的对象时，可只画出 Internet 以下的子树（图中带阴影的虚线方框），并在 Internet 结点旁边标注上{1.3.6.1}即可。 在 Internet 结点下面的第二个结点是 mgmt（管理），标号是 2。再下面是管理信息库，原先的结点名是 mib。1991 年定义了新的版本 MIB-II，故结点名现改为 mib-2，其标识为{1.3.6.1.2.1}，或{Internet(1) .2.1}。这种标识为对象标识符。 最初的结点 mib 将其所管理的信息分为 8 个类别，如图，现在的 mib-2 所包含的信息类别已超过 40 个。 应当指出，MIB 的定义与具体的网络管理协议无关，这对于厂商和用户都有利。厂商可以在产品（如路由器）中包含 SNMP 代理软件，并保证在定义新的 MIB 项目后该软件仍遵守标准。用户可以使用同一网络管理客户软件来管理具有不同版本的 MIB 的多个路由器。当然，一个没有新的 MIB 项目的路由器不能提供这些项目的信息。这里要提一下MIB中的对象{1.3.6.1.4.1}，即enterprises（企业），其所属结点数已超过 3000。例如IBM为{1.3.6.1.4.1.2}，Cisco为{1.3.6.1.4.1.9}，Novell为{1.3.6.1.4.1.23}等。世界上任何一个公司、学校只要用电子邮件发往iana-mib@isi.edu进行申请即可获得一个结点名。这样各厂家就可以定义自己的产品的被管理对象名，使它能用SNMP进行管理。 ASN.1、BER、SMI、MIB、PDU的关系关于ASN.1、BER、SMI、MIB、PDU的关系如下图所示。 OID(对象标识符)OID(Object Identifier)，中文名称：对象标识符，被管理设备的每个管理资源和对象都有自己的OID(Object Identifier)，管理对象通过树状结构进行组织，OID由树上的一系列整数组成，整数之间用点( . )分隔开，树的叶子节点才是真正能够被管理的对象。 常用OID这里总结了一些常用的OID，当需要时可以及时查询。SNMP监控常用OID查询SNMP监控一些常用OID的总结下载不同厂商的MIB包查看不同厂商的OID代号 SNMP协议实现SNMP协议的Java实现是SNMP4J，其jar包可以在SNMP官方网站上下载。开发前请简单了解一下SNMP4J，具体细节请看这篇博文：SNMP4J介绍；更多SNMP4J示例请参考Github。 本文小结SNMP支持Window、Linux、MacOS系统的安装，关于SNMP的安装步骤请自行查询。]]></content>
      <categories>
        <category>SNMP</category>
      </categories>
      <tags>
        <tag>SNMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列七-mapper映射文件配置之insert、update、delete]]></title>
    <url>%2F%2Fblog%2Fmybatis-7%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（六）—objectFactory、plugins、mappers简介与配置》简单地给mybatis的配置画上了一个句号。那么从本篇文章开始，将会介绍mapper映射文件的配置， 这是mybatis的核心之一，一定要学好。在mapper文件中，以mapper作为根节点，其下面可以配置的元素节点有： select, insert, update, delete, cache, cache-ref, resultMap, sql 。 本篇文章将简单介绍 insert, update, delete 的配置及使用，以后会对mybatis的源码进行深入讲解。 相信，看到insert, update, delete， 我们就知道其作用了，顾名思义嘛，myabtis 作为持久层框架，必须要对CRUD啊。 好啦，咱们就先来看看 insert, update, delete 怎么配置， 能配置哪些元素吧： 相关元素配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN" "http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd"&gt; &lt;!-- mapper 为根元素节点， 一个namespace对应一个dao --&gt;&lt;mapper namespace="com.dy.dao.UserDao"&gt; &lt;insert &lt;!-- 1. id （必须配置） id是命名空间中的唯一标识符，可被用来代表这条语句。 一个命名空间（namespace） 对应一个dao接口, 这个id也应该对应dao里面的某个方法（相当于方法的实现），因此id 应该与方法名一致 --&gt; id="insertUser" &lt;!-- 2. parameterType （可选配置, 默认为mybatis自动选择处理） 将要传入语句的参数的完全限定类名或别名， 如果不配置， mybatis会通过ParameterHandler 根据参数类型默认选择合适的typeHandler进行处理 parameterType 主要指定参数类型，可以是int, short, long, string等类型，也可以是复杂类型（如对象） --&gt; parameterType="com.demo.User" &lt;!-- 3. flushCache （可选配置，默认配置为true） 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空， 默认值：true（对应插入、更新和删除语句） --&gt; flushCache="true" &lt;!-- 4. statementType （可选配置，默认配置为PREPARED） STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement， PreparedStatement 或 CallableStatement，默认值：PREPARED。 --&gt; statementType="PREPARED" &lt;!-- 5. keyProperty (可选配置， 默认为unset) （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值， 默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 --&gt; keyProperty="" &lt;!-- 6. keyColumn (可选配置) （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库 （像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。 如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 --&gt; keyColumn="" &lt;!-- 7. useGeneratedKeys (可选配置， 默认为false) （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。 --&gt; useGeneratedKeys="false" &lt;!-- 8. timeout (可选配置， 默认为unset, 依赖驱动) 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 --&gt; timeout="20"&gt; &lt;update id="updateUser" parameterType="com.demo.User" flushCache="true" statementType="PREPARED" timeout="20"&gt; &lt;delete id="deleteUser" parameterType="com.demo.User" flushCache="true" statementType="PREPARED" timeout="20"&gt;&lt;/mapper&gt; 以上就是一个模板配置， 哪些是必要配置，哪些是根据自己实际需求，看一眼就知道了。 下面， 还是用第一篇文章《深入浅出Mybatis系列（一）—Mybatis入门》里面的demo来示例吧： User类1234567891011public class User &#123; private int id; private String name; private String password; private int age; private int deleteFlag; //setter和getter方法省略...&#125; UserDao类12345public interface UserDao &#123; public void insertUser (User user); public void updateUser (User user); public void deleteUser (User user);&#125; userDao.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN" "http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.dy.dao.UserDao"&gt; &lt;!-- 对应userDao中的insertUser方法， --&gt; &lt;insert id="insertUser" parameterType="com.dy.entity.User"&gt; insert into user(id, name, password, age, deleteFlag) values(#&#123;id&#125; , #&#123;name&#125; , #&#123;password&#125; , #&#123;age&#125; , #&#123;deleteFlag&#125;) &lt;/insert&gt; &lt;!-- 对应userDao中的updateUser方法 --&gt; &lt;update id="updateUser" parameterType="com.dy.entity.User"&gt; update user set name = #&#123;name&#125; , password = #&#123;password&#125; , age = #&#123;age&#125; , deleteFlag = #&#123;deleteFlag&#125; where id = #&#123;id&#125;; &lt;/update&gt; &lt;!-- 对应userDao中的deleteUser 方法 --&gt; &lt;delete id="deleteUser" parameterType="com.dy.entity.User"&gt; delete from user where id = #&#123;id&#125;; &lt;/delete&gt;&lt;/mapper&gt; 这样，一个简单的映射关系就建立了。仔细观察上面parameterType, “com.dy.entity.User”，包名要是再长点呢，每次都这样写，写得蛋疼了。别忘了之前讲的 typeAliases（别名）， 那么这个地方，用上别名，岂不是技能跟蛋疼的长长的包名说拜拜了。好啦，咱们配上别名，在哪儿配？ 当然是在mybatis 的全局配置文件（我这儿名字是mybatis-conf.xml）， 不要认为是在mapper的配置文件里面配置哈。 mybatis-conf.xml123456789&lt;typeAliases&gt; &lt;!-- 通过package, 可以直接指定package的名字， mybatis会自动扫描你指定包下面的javabean, 并且默认设置一个别名，默认的名字为： javabean 的首字母小写的非限定类名来作为它的别名。 也可在javabean 加上注解@Alias 来自定义别名， 例如： @Alias(user) &lt;package name="com.dy.entity"/&gt; --&gt; &lt;typeAlias alias="user" type="com.dy.entity.User"/&gt; &lt;/typeAliases&gt; 这样，一个别名就取好了，咱们可以把上面的 com.dy.entity.User 都直接改为user 了。 这多方便呀！ 我这儿数据库用的是mysql, 我把user表的主键id 设置了自动增长， 以上代码运行正常， 那么问题来了（当然，我不是要问学挖掘机哪家强），我要是换成oracle数据库怎么办？ oracle 可是不支持id自增长啊？ 怎么办？请看下面：123456789101112&lt;!-- 对应userDao中的insertUser方法， --&gt; &lt;insert id="insertUser" parameterType="com.dy.entity.User"&gt; &lt;!-- oracle等不支持id自增长的，可根据其id生成策略，先获取id &lt;selectKey resultType="int" order="BEFORE" keyProperty="id"&gt; select seq_user_id.nextval as id from dual &lt;/selectKey&gt; --&gt; insert into user(id, name, password, age, deleteFlag) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;deleteFlag&#125;) &lt;/insert&gt; 同理，如果我们在使用mysql的时候，想在数据插入后返回插入的id, 我们也可以使用 selectKey 这个元素：1234567891011121314151617&lt;!-- 对应userDao中的insertUser方法， --&gt; &lt;insert id="insertUser" parameterType="com.dy.entity.User"&gt; &lt;!-- oracle等不支持id自增长的，可根据其id生成策略，先获取id &lt;selectKey resultType="int" order="BEFORE" keyProperty="id"&gt; select seq_user_id.nextval as id from dual &lt;/selectKey&gt; --&gt; &lt;!-- mysql插入数据后，获取id --&gt; &lt;selectKey keyProperty="id" resultType="int" order="AFTER" &gt; SELECT LAST_INSERT_ID() as id &lt;/selectKey&gt; insert into user(id, name, password, age, deleteFlag) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;deleteFlag&#125;) &lt;/insert&gt; 这儿，我们就简单提一下 这个元素节点吧:1234567891011121314151617181920212223242526&lt;selectKey &lt;!-- selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列， 也可以是逗号分隔的属性名称列表。 --&gt; keyProperty="id" &lt;!-- 结果的类型。MyBatis 通常可以推算出来，但是为了更加确定写上也不会有什么问题。 MyBatis 允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列， 则可以使用一个包含期望属性的 Object 或一个 Map。 --&gt; resultType="int" &lt;!-- 这可以被设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它会首先选择主键， 设置 keyProperty 然后执行插入语句。如果设置为 AFTER，那么先执行插入语句， 然后是 selectKey 元素 - 这和像 Oracle 的数据库相似，在插入语句内部可能有嵌入索引调用。 --&gt; order="BEFORE" &lt;!-- 与前面相同，MyBatis 支持 STATEMENT，PREPARED 和 CALLABLE 语句的映射类型， 分别代表 PreparedStatement 和 CallableStatement 类型。 --&gt; statementType="PREPARED"&gt; 好啦，本篇文章主要介绍了insert, update, delete的配置及用法。 下篇文章将介绍复杂的 select相关的配置及用法， 待这些都讲完后，会先根据源码分析一下mybatis的整个运行流程，然后再深入mybatis的用法。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列六-objectFactory、plugins、mappers简介与配置]]></title>
    <url>%2F%2Fblog%2Fmybatis-6%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（五）—TypeHandler简介及配置（mybatis源码篇）》简单看了一下TypeHandler， 本次将结束对于mybatis的配置文件的学习， 本次涉及到剩下没提及到的几个节点的配置：objectFactory、databaseIdProvider、plugins、mappers。 那么，接下来，就简单介绍一下这几个配置的作用吧： 1、objectFactory是干什么的？ 需要配置吗？ MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。默认情况下，我们不需要配置，mybatis会调用默认实现的objectFactory。 除非我们要自定义ObjectFactory的实现， 那么我们才需要去手动配置。 那么怎么自定义实现ObjectFactory？ 怎么配置呢？ 自定义ObjectFactory只需要去继承DefaultObjectFactory（是ObjectFactory接口的实现类），并重写其方法即可。具体的，本处不多说，后面再具体讲解。 写好了ObjectFactory, 仅需做如下配置：1234567&lt;configuration&gt; ...... &lt;objectFactory type="org.mybatis.example.ExampleObjectFactory"&gt; &lt;property name="someProperty" value="100"/&gt; &lt;/objectFactory&gt; ...... &lt;/configuration plugin有何作用？ 需要配置吗？ plugins 是一个可选配置。mybatis中的plugin其实就是个interceptor， 它可以拦截Executor 、ParameterHandler 、ResultSetHandler 、StatementHandler 的部分方法，处理我们自己的逻辑。Executor就是真正执行sql语句的东西， ParameterHandler 是处理我们传入参数的，还记得前面讲TypeHandler的时候提到过，mybatis默认帮我们实现了不少的typeHandler, 当我们不显示配置typeHandler的时候，mybatis会根据参数类型自动选择合适的typeHandler执行，其实就是ParameterHandler 在选择。ResultSetHandler 就是处理返回结果的。 怎么自定义plugin? 怎么配置？ 要自定义一个plugin, 需要去实现Interceptor接口， 这儿不细说， 后面实战部分会详细讲解。定义好之后，配置如下：123456789&lt;configuration&gt; ...... &lt;plugins&gt; &lt;plugin interceptor="org.mybatis.example.ExamplePlugin"&gt; &lt;property name="someProperty" value="100"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; ...... &lt;/configuration&gt; mappers, 这下引出mybatis的核心之一了，mappers作用 ? 需要配置吗？ mappers 节点下，配置我们的mapper映射文件， 所谓的mapper映射文件，就是让mybatis 用来建立数据表和javabean映射的一个桥梁。在我们实际开发中，通常一个mapper文件对应一个dao接口， 这个mapper可以看做是dao的实现。所以,mappers必须配置。 那么怎么配置呢？12345678910111213141516171819202122232425&lt;configuration&gt; ...... &lt;mappers&gt; &lt;!-- 第一种方式：通过resource指定 --&gt; &lt;mapper resource="com/dy/dao/userDao.xml"/&gt; &lt;!-- 第二种方式， 通过class指定接口，进而将接口与对应的xml文件形成映射关系 不过，使用这种方式必须保证 接口与mapper文件同名(不区分大小写)， 我这儿接口是UserDao,那么意味着mapper文件为UserDao.xml &lt;mapper class="com.dy.dao.UserDao"/&gt; --&gt; &lt;!-- 第三种方式，直接指定包，自动扫描，与方法二同理 &lt;package name="com.dy.dao"/&gt; --&gt; &lt;!-- 第四种方式：通过url指定mapper文件位置 &lt;mapper url="file://........"/&gt; --&gt; &lt;/mappers&gt; ...... &lt;/configuration&gt; 本篇仅作简单介绍， 更高级的使用以及其实现原理，会在后面的实战部分进行详细讲解。 这几个节点的解析源码，与之前提到的那些节点的解析类似，源码需要的可以从这里看看。 相关节点源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * objectFactory 节点解析 */private void objectFactoryElement(XNode context) throws Exception &#123; if (context != null) &#123; //读取type属性的值， 接下来进行实例化ObjectFactory, 并set进 configuration //到此，简单讲一下configuration这个对象，其实它里面主要保存的都是mybatis的配置 String type = context.getStringAttribute("type"); //读取propertie的值， 根据需要可以配置， mybatis默认实现的objectFactory没有使用properties Properties properties = context.getChildrenAsProperties(); ObjectFactory factory = (ObjectFactory) resolveClass(type).newInstance(); factory.setProperties(properties); configuration.setObjectFactory(factory); &#125; &#125; /** * plugins 节点解析 */ private void pluginElement(XNode parent) throws Exception &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; String interceptor = child.getStringAttribute("interceptor"); Properties properties = child.getChildrenAsProperties(); /** * 由此可见，我们在定义一个interceptor的时候，需要去实现Interceptor, * 这儿先不具体讲，以后会详细讲解 */ Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance(); interceptorInstance.setProperties(properties); configuration.addInterceptor(interceptorInstance); &#125; &#125; &#125; /** * mappers 节点解析 * 这是mybatis的核心之一，这儿先简单介绍，在接下来的文章会对它进行分析 */ private void mapperElement(XNode parent) throws Exception &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; if ("package".equals(child.getName())) &#123; //如果mappers节点的子节点是package, 那么就扫描package下的文件, 注入进configuration String mapperPackage = child.getStringAttribute("name"); configuration.addMappers(mapperPackage); &#125; else &#123; String resource = child.getStringAttribute("resource"); String url = child.getStringAttribute("url"); String mapperClass = child.getStringAttribute("class"); //resource, url, class 三选一 if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) &#123; ErrorContext.instance().resource(resource); InputStream inputStream = Resources.getResourceAsStream(resource); //mapper映射文件都是通过XMLMapperBuilder解析 XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream , configuration , resource , configuration.getSqlFragments()); mapperParser.parse(); &#125; else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) &#123; ErrorContext.instance().resource(url); InputStream inputStream = Resources.getUrlAsStream(url); XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream , configuration , url , configuration.getSqlFragments()); mapperParser.parse(); &#125; else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) &#123; Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass); configuration.addMapper(mapperInterface); &#125; else &#123; throw new BuilderException("A mapper element may only specify a url , resource or class, but not more than one."); &#125; &#125; &#125; &#125; &#125; 本次就简单的到此结束， 从下篇文章开始，将会开始接触到mybatis的核心部分，不过首先还是要讲mapper文件的配置及使用， 并通过源码进一步深入核心。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列九-强大的动态SQL]]></title>
    <url>%2F%2Fblog%2Fmybatis-9%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（八）—mapper映射文件配置之select、resultMap》简单介绍了mybatis的查询，至此，CRUD都已讲完。本文将介绍mybatis强大的动态SQL。 那么，问题来了： 什么是动态SQL? 动态SQL有什么作用？ 传统的使用JDBC的方法，相信大家在组合复杂的的SQL语句的时候，需要去拼接，稍不注意哪怕少了个空格，都会导致错误。Mybatis的动态SQL功能正是为了解决这种问题， 其通过 if, choose, when, otherwise, trim, where, set, foreach标签，可组合成非常灵活的SQL语句，从而提高开发人员的效率。下面就去感受Mybatis动态SQL的魅力吧： mybatis中if判断作为程序猿，谁不懂if !在mybatis中也能用 if 啦：1234567&lt;select id="findUserById" resultType="user"&gt; select * from user where &lt;if test="id != null"&gt; id=#&#123;id&#125; &lt;/if&gt; and deleteFlag=0;&lt;/select&gt; 上面例子： 如果传入的id 不为空， 那么才会SQL才拼接id = #{id}。 这个相信大家看一样就能明白，不多说。 细心的人会发现一个问题：“你这不对啊！ 要是你传入的id为null, 那么你这最终的SQL语句不就成了 select * from user where and deleteFlag=0, 这语句有问题！” 是啊，这时候，mybatis的 where 标签就该隆重登场啦： mybatis中where咱们通过where改造一下上面的例子：123456789&lt;select id="findUserById" resultType="user"&gt; select * from user &lt;where&gt; &lt;if test="id != null"&gt; id=#&#123;id&#125; &lt;/if&gt; and deleteFlag=0; &lt;/where&gt; &lt;/select&gt; 有些人就要问了： “你这都是些什么玩意儿！ 跟上面的相比， 不就是多了个where标签嘛！ 那这个还会不会出现 select * from user where and deleteFlag=0 ？” 的确，从表面上来看，就是多了个where标签而已， 不过实质上， mybatis是对它做了处理，当它遇到AND或者OR这些，它知道怎么处理。其实我们可以通过 trim 标签去自定义这种处理规则。 trim:我的地盘，我做主上面的where标签，其实用trim 可以表示如下：123&lt;trim prefix="WHERE" prefixOverrides="AND |OR "&gt; ... &lt;/trim&gt; 它的意思就是： 当WHERE后紧随AND或则OR的时候，就去除AND或者OR。 除了WHERE以外， 其实还有一个比较经典的实现，那就是SET。 set: 信我，不出错123456789101112131415161718&lt;update id="updateUser" parameterType="com.dy.entity.User"&gt; update user set &lt;if test="name != null"&gt; name = #&#123;name&#125;, &lt;/if&gt; &lt;if test="password != null"&gt; password = #&#123;password&#125;, &lt;/if&gt; &lt;if test="age != null"&gt; age = #&#123;age&#125; &lt;/if&gt; &lt;where&gt; &lt;if test="id != null"&gt; id = #&#123;id&#125; &lt;/if&gt; and deleteFlag = 0; &lt;/where&gt;&lt;/update&gt; 问题又来了： “如果我只有name不为null, 那么这SQL不就成了 update set name = #{name}, where …….. ? 你那name后面那逗号会导致出错啊！” 是的，这时候，就可以用mybatis为我们提供的set 标签了。下面是通过set标签改造后：1234567891011121314&lt;update id="updateUser" parameterType="com.dy.entity.User"&gt; update user &lt;set&gt; &lt;if test="name != null"&gt;name = #&#123;name&#125;,&lt;/if&gt; &lt;if test="password != null"&gt;password = #&#123;password&#125;,&lt;/if&gt; &lt;if test="age != null"&gt;age = #&#123;age&#125;,&lt;/if&gt; &lt;/set&gt; &lt;where&gt; &lt;if test="id != null"&gt; id = #&#123;id&#125; &lt;/if&gt; and deleteFlag = 0; &lt;/where&gt;&lt;/update&gt; 这个用trim 可表示为：123&lt;trim prefix="SET" suffixOverrides=","&gt; ...&lt;/trim&gt; foreach: 你有for, 我有foreach！java中有for, 可通过for循环， 同样， mybatis中有foreach, 可通过它实现循环，循环的对象当然主要是java容器和数组。123456789&lt;select id="selectPostIn" resultType="domain.blog.Post"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item="item" index="index" collection="list" open="(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; 将一个 List 实例或者数组作为参数对象传给 MyBatis，当这么做的时候，MyBatis 会自动将它包装在一个 Map 中并以名称为键。List 实例将会以“list”作为键，而数组实例的键将是“array”。同样， 当循环的对象为map的时候，index其实就是map的key。 choose: 我选择了你，你选择了我Java中有switch, mybatis有choose1234567891011121314&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test="title != null"&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 以上例子中： 当title和author都不为null的时候， 那么选择二选一（前者优先）， 如果都为null, 那么就选择 otherwise中的， 如果tilte和author只有一个不为null, 那么就选择不为null的那个。 纵观mybatis的动态SQL， 强大而简单， 相信大家简单看一下就能使用了。 好啦，本次就写到这！下篇文章将结合mybatis的源码分析一次sql语句执行的整个过程。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列八-mapper映射文件配置之select、resultMap]]></title>
    <url>%2F%2Fblog%2Fmybatis-8%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇《深入浅出Mybatis系列（七）—mapper映射文件配置之insert、update、delete》介绍了insert、update、delete的用法，本篇将介绍select、resultMap的用法。select无疑是我们最常用，也是最复杂的，mybatis通过resultMap能帮助我们很好地进行高级映射。下面就开始看看select 以及 resultMap的用法： 先看select的配置吧： select配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;select &lt;!-- 1. id （必须配置） id是命名空间中的唯一标识符，可被用来代表这条语句。 一个命名空间（namespace） 对应一个dao接口, 这个id也应该对应dao里面的某个方法（相当于方法的实现），因此id 应该与方法名一致 --&gt; id="selectPerson" &lt;!-- 2. parameterType （可选配置, 默认为mybatis自动选择处理） 将要传入语句的参数的完全限定类名或别名， 如果不配置，mybatis会通过ParameterHandler 根据参数类型默认选择合适的typeHandler进行处理 parameterType 主要指定参数类型，可以是int, short, long, string等类型，也可以是复杂类型（如对象） --&gt; parameterType="int" &lt;!-- 3. resultType (resultType 与 resultMap 二选一配置) resultType用以指定返回类型，指定的类型可以是基本类型，可以是java容器，也可以是javabean --&gt; resultType="hashmap" &lt;!-- 4. resultMap (resultType 与 resultMap 二选一配置) resultMap用于引用我们通过 resultMap标签定义的映射类型， 这也是mybatis组件高级复杂映射的关键 --&gt; resultMap="personResultMap" &lt;!-- 5. flushCache (可选配置) 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false --&gt; flushCache="false" &lt;!-- 6. useCache (可选配置) 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true --&gt; useCache="true" &lt;!-- 7. timeout (可选配置) 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动） --&gt; timeout="10000" &lt;!-- 8. fetchSize (可选配置) 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动) --&gt; fetchSize="256" &lt;!-- 9. statementType (可选配置) STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED --&gt; statementType="PREPARED" &lt;!-- 10. resultSetType (可选配置) FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个， 默认值为 unset （依赖驱动） --&gt; resultSetType="FORWARD_ONLY"&gt; 配置看起来总是这么多，不过实际常用的配置也就那么几个， 根据自己的需要吧，上面都已注明是否必须配置。 下面还是上个demo及时练练手吧! 数据库：新增两张表（t_course, t_student）,以下为相关实体类。 Course.java1234567public class Course &#123; private int id; private String name; private int deleteFlag; //setter和getter方法省略...&#125; Student.java123456789public class Student &#123; private int id; private String idCard; private String name; private List&lt;Course&gt; courseList; private int deleteFlag; //setter和getter方法省略...&#125; CourseDao.java123public interface CourseDao &#123; public Course findCourseById(int courseId); &#125; StudentDao.java123public interface StudentDao &#123; public Student findStudentById(String idCard);&#125; courseDao.xml12345678910111213141516171819202122232425&lt;mapper namespace="com.dy.dao.CourseDao"&gt; &lt;!-- 1.此处直接将resultType 设置为course, 一看就知道我设置了别名吧， 如果没有设置别名，那么resultType = com.dy.entity.Course。 2.可能细心的你会发现：Course.java中的属性名与数据库字段名不一致，下面， 我就在sql语句中用了as, 使之匹配，当然方法不止一种，在学习了resultMap之后， 你能看到一种更直观优雅的方式去将javabean中的属性与数据库字段名保持一致 3.findCourseById 与CourseDao中findCourseById方法对应， 那么传入的参数名称以及类型也应该保持对应关系。 4.可以看到，在sql语句中，通过#&#123;&#125;表达式可以获取参数。 5.下面这条sql语句，实际上的形式是怎么样的？还记得之前说过， mybatis默认为preparedStatement吧，那么，用我们jdbc代码来看，它其实就是： select course_id as id, course_name as name, course_delete_flg as deleteFlag from t_course where course_id=? --&gt; &lt;select id="findCourseById" resultType="course" &gt; select course_id as id , course_name as name , course_delete_flg as deleteFlag from t_course where course_id=#&#123;courseId&#125; &lt;/select&gt; &lt;/mapper&gt; CourseDaoTest.java123456789101112131415161718192021222324public class CourseDaoTest &#123; @Test public void findCourseById() &#123; SqlSessionFactory sqlSessionFactory = getSessionFactory(); SqlSession sqlSession = sqlSessionFactory.openSession(); CourseDao courseDao = sqlSession.getMapper(CourseDao.class); Course course = courseDao.findCourseById(1); &#125; //Mybatis 通过SqlSessionFactory获取SqlSession, 然后才能通过SqlSession与数据库进行交互 private static SqlSessionFactory getSessionFactory() &#123; SqlSessionFactory sessionFactory = null; String resource = "mybatis-conf.xml"; try &#123; sessionFactory = new SqlSessionFactoryBuilder().build(Resources .getResourceAsReader(resource)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return sessionFactory; &#125; &#125; 上面的示例，我们针对course, 简单演示了 select的用法， 不过有个问题值得思考： 一个student可以对应多个course, 那么，在mybatis中如何处理这种一对多， 甚至于多对多，一对一的关系呢？ 这儿，就不得不提到 resultMap 这个东西， mybatis的resultMap功能可谓十分强大，能够处理复杂的关系映射， 那么resultMap 该怎么配置呢？ 别急，这就来了： resultMap配置12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 1.type 对应类型，可以是javabean, 也可以是其它 2.id 必须唯一， 用于标示这个resultMap的唯一性，在使用resultMap的时候，就是通过id指定 --&gt; &lt;resultMap type="" id=""&gt; &lt;!-- id, 唯一性，注意啦，这个id用于标示这个javabean对象的唯一性， 不一定会是数据库的主键（不要把它理解为数据库对应表的主键） property属性对应javabean的属性名，column对应数据库表的列名 （这样，当javabean的属性与数据库对应表的列名不一致的时候，就能通过指定这个保持正常映射了） --&gt; &lt;id property="" column=""/&gt; &lt;!-- result与id相比， 对应普通属性 --&gt; &lt;result property="" column=""/&gt; &lt;!-- constructor对应javabean中的构造方法 --&gt; &lt;constructor&gt; &lt;!-- idArg 对应构造方法中的id参数 --&gt; &lt;idArg column=""/&gt; &lt;!-- arg 对应构造方法中的普通参数 --&gt; &lt;arg column=""/&gt; &lt;/constructor&gt; &lt;!-- collection，对应javabean中容器类型, 是实现一对多的关键 property 为javabean中容器对应字段名 column 为体现在数据库中列名 ofType 就是指定javabean中容器指定的类型 --&gt; &lt;collection property="" column="" ofType=""&gt;&lt;/collection&gt; &lt;!-- association 为关联关系，是实现N对一的关键。 property 为javabean中容器对应字段名 column 为体现在数据库中列名 javaType 指定关联的类型 --&gt; &lt;association property="" column="" javaType=""&gt;&lt;/association&gt; &lt;/resultMap&gt; 好啦，知道resutMap怎么配置后，咱们立即接着上面的demo来练习一下吧： 下面是用resultMap处理一对多关系的映射的示例 一个student对应多个course， 典型的一对多，咱们就来看看mybatis怎么配置这种映射吧： studentDao.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;mapper namespace="com.dy.dao.StudentDao"&gt; &lt;!-- 这儿定义一个resultMap --&gt; &lt;resultMap type="student" id="studentMap"&gt; &lt;!-- 数据库中主键是id, 但是我这儿却是指定idCard为主键，为什么？ 刚刚讲了，id用来表示唯一性， 我们可以认为只要idCard一样，那么他就是同一个学生。 如果此处用数据库中id， 那么mybatis将会认为数据库中每条记录都是一个student, 这显然不符合逻辑 --&gt; &lt;id property="idCard" column="stu_id_card"/&gt; &lt;result property="id" column="stu_id"/&gt; &lt;result property="name" column="stu_name"/&gt; &lt;result property="deleteFlag" column="stu_delete_flg"/&gt; &lt;!-- 这儿就是实现一对多的关键。 在Student中，courseList为List&lt;Course&gt;, 因此， ofType也应该与之对应（当然，我用了别名，不然要蛋疼的写全名了）。 collection的子标签是在指定Course的映射关系 （由于Course的javabean的属性名与数据库的列名不一致） --&gt; &lt;collection property="courseList" column="stu_course_id" ofType="Course"&gt; &lt;id property="id" column="course_id"/&gt; &lt;result property="name" column="course_name"/&gt; &lt;result property="deleteFlag" column="course_delete_flg"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 这儿将返回类型设置成了上面指定的studentMap --&gt; &lt;select id="findStudentById" resultMap="studentMap"&gt; SELECT s.*, c.* FROM t_student s LEFT JOIN t_course c ON s.stu_course_id=c.course_id WHERE s.stu_id_card=#&#123;idCard&#125; &lt;/select&gt; &lt;/mapper&gt; StudentDaoTest.java12345678910111213141516171819202122232425262728public class StudentDaoTest &#123; @Test public void findCourseById() &#123; SqlSessionFactory sqlSessionFactory = getSessionFactory(); SqlSession sqlSession = sqlSessionFactory.openSession(); StudentDao studentDao = sqlSession.getMapper(StudentDao.class); Student student = studentDao.findStudentById("20140101"); List&lt;Course&gt; courseList = student.getCourseList(); for (Course course: courseList) &#123; System.out.println(course.getId() + " " + course.getName()); &#125; &#125; //Mybatis 通过SqlSessionFactory获取SqlSession, 然后才能通过SqlSession与数据库进行交互 private static SqlSessionFactory getSessionFactory() &#123; SqlSessionFactory sessionFactory = null; String resource = "mybatis-conf.xml"; try &#123; sessionFactory = new SqlSessionFactoryBuilder().build(Resources .getResourceAsReader(resource)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return sessionFactory; &#125; &#125; 相信通过以上demo， 大家也能够使用mybatis的select 和 resultMap的用法了。上面demo只演示了一对多的映射，其实多对一、多对多也与它类似，所以我就没演示了，有兴趣的可以自己动手再做做。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列五-TypeHandler简介及配置（mybatis源码篇）]]></title>
    <url>%2F%2Fblog%2Fmybatis-5%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（四）—配置详解之typeAliases别名（mybatis源码篇）》为大家介绍了mybatis中别名的使用，以及其源码。本篇将为大家介绍TypeHandler， 并简单分析其源码。 Mybatis中的TypeHandler是什么？ 无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时，都会用类型处理器将获取的值以合适的方式转换成 Java 类型。Mybatis默认为我们实现了许多TypeHandler, 当我们没有配置指定TypeHandler时，Mybatis会根据参数或者返回结果的不同，默认为我们选择合适的TypeHandler处理。 那么，Mybatis为我们实现了哪些TypeHandler呢? 我们怎么自定义实现一个TypeHandler ? 这些都会在接下来的mybatis的源码中看到。 在看源码之前，还是像之前一样，先看看怎么配置吧？ 配置TypeHandler123456789101112131415161718192021222324252627282930&lt;configuration&gt; &lt;typeHandlers&gt; &lt;!-- 当配置package的时候，mybatis会去配置的package扫描TypeHandler &lt;package name="com.dy.demo"/&gt; --&gt; &lt;!-- handler属性直接配置我们要指定的TypeHandler --&gt; &lt;typeHandler handler=""/&gt; &lt;!-- javaType 配置java类型，例如String, 如果配上javaType, 那么指定的typeHandler就只作用于指定的类型 --&gt; &lt;typeHandler javaType="" handler=""/&gt; &lt;!-- jdbcType 配置数据库基本数据类型，例如varchar, 如果配上jdbcType, 那么指定的typeHandler就只作用于指定的类型 --&gt; &lt;typeHandler jdbcType="" handler=""/&gt; &lt;!-- 也可两者都配置 --&gt; &lt;typeHandler javaType="" jdbcType="" handler=""/&gt; &lt;/typeHandlers&gt; ...... &lt;/configuration&gt; 上面简单介绍了一下TypeHandler, 下面就看看mybatis中TypeHandler的源码了。 老规矩，先从对xml的解析讲起： typeHandlers节点源码123456789101112131415161718192021222324252627282930313233343536373839404142/** * 解析typeHandlers节点 */private void typeHandlerElement(XNode parent) throws Exception &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; //子节点为package时，获取其name属性的值，然后自动扫描package下的自定义typeHandler if ("package".equals(child.getName())) &#123; String typeHandlerPackage = child.getStringAttribute("name"); typeHandlerRegistry.register(typeHandlerPackage); &#125; else &#123; /** * 子节点为typeHandler时， 可以指定javaType属性， * 也可以指定jdbcType, 也可两者都指定 * javaType 是指定java类型 * jdbcType 是指定jdbc类型（数据库类型： 如varchar） */ String javaTypeName = child.getStringAttribute("javaType"); String jdbcTypeName = child.getStringAttribute("jdbcType"); //handler就是我们配置的typeHandler String handlerTypeName = child.getStringAttribute("handler"); //resolveClass方法就是我们上篇文章所讲的TypeAliasRegistry里面处理别名的方法 Class&lt;?&gt; javaTypeClass = resolveClass(javaTypeName); //JdbcType是一个枚举类型，resolveJdbcType方法是在获取枚举类型的值 JdbcType jdbcType = resolveJdbcType(jdbcTypeName); Class&lt;?&gt; typeHandlerClass = resolveClass(handlerTypeName); //注册typeHandler, typeHandler通过TypeHandlerRegistry这个类管理 if (javaTypeClass != null) &#123; if (jdbcType == null) &#123; typeHandlerRegistry.register(javaTypeClass, typeHandlerClass); &#125; else &#123; typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass); &#125; &#125; else &#123; typeHandlerRegistry.register(typeHandlerClass); &#125; &#125; &#125; &#125;&#125; 接下来看看TypeHandler的管理注册类： TypeHandlerRegistry源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379/** * typeHandler注册管理类 */public final class TypeHandlerRegistry &#123; //源码一上来，二话不说，几个大大的HashMap就出现，这不又跟上次讲的typeAliases的注册类似么 //基本数据类型与其包装类 private static final Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; reversePrimitiveMap = new HashMap&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;() &#123; private static final long serialVersionUID = 1L; &#123; put(Byte.class, byte.class); put(Short.class, short.class); put(Integer.class, int.class); put(Long.class, long.class); put(Float.class, float.class); put(Double.class, double.class); put(Boolean.class, boolean.class); put(Character.class, char.class); &#125; &#125;; //这几个MAP不用说就知道存的是什么东西吧，命名的好处 private final Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; JDBC_TYPE_HANDLER_MAP = new EnumMap&lt;JdbcType, TypeHandler&lt;?&gt;&gt;(JdbcType.class); private final Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; TYPE_HANDLER_MAP = new HashMap&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt;(); private final TypeHandler&lt;Object&gt; UNKNOWN_TYPE_HANDLER = new UnknownTypeHandler(this); private final Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; ALL_TYPE_HANDLERS_MAP = new HashMap&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt;(); //就像上篇文章讲的typeAliases一样，mybatis也默认给我们注册了不少的typeHandler //具体如下 public TypeHandlerRegistry() &#123; register(Boolean.class, new BooleanTypeHandler()); register(boolean.class, new BooleanTypeHandler()); register(JdbcType.BOOLEAN, new BooleanTypeHandler()); register(JdbcType.BIT, new BooleanTypeHandler()); register(Byte.class, new ByteTypeHandler()); register(byte.class, new ByteTypeHandler()); register(JdbcType.TINYINT, new ByteTypeHandler()); register(Short.class, new ShortTypeHandler()); register(short.class, new ShortTypeHandler()); register(JdbcType.SMALLINT, new ShortTypeHandler()); register(Integer.class, new IntegerTypeHandler()); register(int.class, new IntegerTypeHandler()); register(JdbcType.INTEGER, new IntegerTypeHandler()); register(Long.class, new LongTypeHandler()); register(long.class, new LongTypeHandler()); register(Float.class, new FloatTypeHandler()); register(float.class, new FloatTypeHandler()); register(JdbcType.FLOAT, new FloatTypeHandler()); register(Double.class, new DoubleTypeHandler()); register(double.class, new DoubleTypeHandler()); register(JdbcType.DOUBLE, new DoubleTypeHandler()); register(String.class, new StringTypeHandler()); register(String.class, JdbcType.CHAR, new StringTypeHandler()); register(String.class, JdbcType.CLOB, new ClobTypeHandler()); register(String.class, JdbcType.VARCHAR, new StringTypeHandler()); register(String.class, JdbcType.LONGVARCHAR, new ClobTypeHandler()); register(String.class, JdbcType.NVARCHAR, new NStringTypeHandler()); register(String.class, JdbcType.NCHAR, new NStringTypeHandler()); register(String.class, JdbcType.NCLOB, new NClobTypeHandler()); register(JdbcType.CHAR, new StringTypeHandler()); register(JdbcType.VARCHAR, new StringTypeHandler()); register(JdbcType.CLOB, new ClobTypeHandler()); register(JdbcType.LONGVARCHAR, new ClobTypeHandler()); register(JdbcType.NVARCHAR, new NStringTypeHandler()); register(JdbcType.NCHAR, new NStringTypeHandler()); register(JdbcType.NCLOB, new NClobTypeHandler()); register(Object.class, JdbcType.ARRAY, new ArrayTypeHandler()); register(JdbcType.ARRAY, new ArrayTypeHandler()); register(BigInteger.class, new BigIntegerTypeHandler()); register(JdbcType.BIGINT, new LongTypeHandler()); register(BigDecimal.class, new BigDecimalTypeHandler()); register(JdbcType.REAL, new BigDecimalTypeHandler()); register(JdbcType.DECIMAL, new BigDecimalTypeHandler()); register(JdbcType.NUMERIC, new BigDecimalTypeHandler()); register(Byte[].class, new ByteObjectArrayTypeHandler()); register(Byte[].class, JdbcType.BLOB, new BlobByteObjectArrayTypeHandler()); register(Byte[].class, JdbcType.LONGVARBINARY,new BlobByteObjectArrayTypeHandler()); register(byte[].class, new ByteArrayTypeHandler()); register(byte[].class, JdbcType.BLOB, new BlobTypeHandler()); register(byte[].class, JdbcType.LONGVARBINARY, new BlobTypeHandler()); register(JdbcType.LONGVARBINARY, new BlobTypeHandler()); register(JdbcType.BLOB, new BlobTypeHandler()); register(Object.class, UNKNOWN_TYPE_HANDLER); register(Object.class, JdbcType.OTHER, UNKNOWN_TYPE_HANDLER); register(JdbcType.OTHER, UNKNOWN_TYPE_HANDLER); register(Date.class, new DateTypeHandler()); register(Date.class, JdbcType.DATE, new DateOnlyTypeHandler()); register(Date.class, JdbcType.TIME, new TimeOnlyTypeHandler()); register(JdbcType.TIMESTAMP, new DateTypeHandler()); register(JdbcType.DATE, new DateOnlyTypeHandler()); register(JdbcType.TIME, new TimeOnlyTypeHandler()); register(java.sql.Date.class, new SqlDateTypeHandler()); register(java.sql.Time.class, new SqlTimeTypeHandler()); register(java.sql.Timestamp.class, new SqlTimestampTypeHandler()); // issue #273 register(Character.class, new CharacterTypeHandler()); register(char.class, new CharacterTypeHandler()); &#125; public boolean hasTypeHandler(Class&lt;?&gt; javaType) &#123; return hasTypeHandler(javaType, null); &#125; public boolean hasTypeHandler(TypeReference&lt;?&gt; javaTypeReference) &#123; return hasTypeHandler(javaTypeReference, null); &#125; public boolean hasTypeHandler(Class&lt;?&gt; javaType, JdbcType jdbcType) &#123; return javaType != null &amp;&amp; getTypeHandler((Type) javaType, jdbcType) != null; &#125; public boolean hasTypeHandler(TypeReference&lt;?&gt; javaTypeReference, JdbcType jdbcType) &#123; return javaTypeReference != null &amp;&amp; getTypeHandler(javaTypeReference, jdbcType) != null; &#125; public TypeHandler&lt;?&gt; getMappingTypeHandler( Class&lt;? extends TypeHandler&lt;?&gt;&gt; handlerType) &#123; return ALL_TYPE_HANDLERS_MAP.get(handlerType); &#125; public &lt;T&gt; TypeHandler&lt;T&gt; getTypeHandler(Class&lt;T&gt; type) &#123; return getTypeHandler((Type) type, null); &#125; public &lt;T&gt; TypeHandler&lt;T&gt; getTypeHandler(TypeReference&lt;T&gt; javaTypeReference) &#123; return getTypeHandler(javaTypeReference, null); &#125; public TypeHandler&lt;?&gt; getTypeHandler(JdbcType jdbcType) &#123; return JDBC_TYPE_HANDLER_MAP.get(jdbcType); &#125; public &lt;T&gt; TypeHandler&lt;T&gt; getTypeHandler(Class&lt;T&gt; type, JdbcType jdbcType) &#123; return getTypeHandler((Type) type, jdbcType); &#125; public &lt;T&gt; TypeHandler&lt;T&gt; getTypeHandler( TypeReference&lt;T&gt; javaTypeReference, JdbcType jdbcType) &#123; return getTypeHandler(javaTypeReference.getRawType(), jdbcType); &#125; private &lt;T&gt; TypeHandler&lt;T&gt; getTypeHandler(Type type, JdbcType jdbcType) &#123; Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; jdbcHandlerMap = TYPE_HANDLER_MAP.get(type); TypeHandler&lt;?&gt; handler = null; if (jdbcHandlerMap != null) &#123; handler = jdbcHandlerMap.get(jdbcType); if (handler == null) &#123; handler = jdbcHandlerMap.get(null); &#125; &#125; if (handler == null &amp;&amp; type != null &amp;&amp; type instanceof Class &amp;&amp; Enum.class.isAssignableFrom((Class&lt;?&gt;) type)) &#123; handler = new EnumTypeHandler((Class&lt;?&gt;) type); &#125; @SuppressWarnings("unchecked") // type drives generics here TypeHandler&lt;T&gt; returned = (TypeHandler&lt;T&gt;) handler; return returned; &#125; public TypeHandler&lt;Object&gt; getUnknownTypeHandler() &#123; return UNKNOWN_TYPE_HANDLER; &#125; public void register(JdbcType jdbcType, TypeHandler&lt;?&gt; handler) &#123; JDBC_TYPE_HANDLER_MAP.put(jdbcType, handler); &#125; // // REGISTER INSTANCE // /** * 只配置了typeHandler, 没有配置jdbcType 或者javaType */ @SuppressWarnings("unchecked") public &lt;T&gt; void register(TypeHandler&lt;T&gt; typeHandler) &#123; boolean mappedTypeFound = false; //在自定义typeHandler的时候，可以加上注解MappedTypes 去指定关联的javaType //因此，此处需要扫描MappedTypes注解 MappedTypes mappedTypes = typeHandler.getClass().getAnnotation(MappedTypes.class); if (mappedTypes != null) &#123; for (Class&lt;?&gt; handledType : mappedTypes.value()) &#123; register(handledType, typeHandler); mappedTypeFound = true; &#125; &#125; // @since 3.1.0 - try to auto-discover the mapped type if (!mappedTypeFound &amp;&amp; typeHandler instanceof TypeReference) &#123; try &#123; TypeReference&lt;T&gt; typeReference = (TypeReference&lt;T&gt;) typeHandler; register(typeReference.getRawType(), typeHandler); mappedTypeFound = true; &#125; catch (Throwable t) &#123; /** * maybe users define the TypeReference with a different * type and are not assignable, so just ignore it */ &#125; &#125; if (!mappedTypeFound) &#123; register((Class&lt;T&gt;) null, typeHandler); &#125; &#125; /** * 配置了typeHandlerhe和javaType */ public &lt;T&gt; void register(Class&lt;T&gt; javaType, TypeHandler&lt;? extends T&gt; typeHandler) &#123; register((Type) javaType, typeHandler); &#125; private &lt;T&gt; void register(Type javaType, TypeHandler&lt;? extends T&gt; typeHandler) &#123; //扫描注解MappedJdbcTypes MappedJdbcTypes mappedJdbcTypes = typeHandler.getClass().getAnnotation(MappedJdbcTypes.class); if (mappedJdbcTypes != null) &#123; for (JdbcType handledJdbcType : mappedJdbcTypes.value()) &#123; register(javaType, handledJdbcType, typeHandler); &#125; if (mappedJdbcTypes.includeNullJdbcType()) &#123; register(javaType, null, typeHandler); &#125; &#125; else &#123; register(javaType, null, typeHandler); &#125; &#125; public &lt;T&gt; void register(TypeReference&lt;T&gt; javaTypeReference, TypeHandler&lt;? extends T&gt; handler) &#123; register(javaTypeReference.getRawType(), handler); &#125; /** * typeHandlerhe、javaType、jdbcType都配置了 */ public &lt;T&gt; void register(Class&lt;T&gt; type, JdbcType jdbcType, TypeHandler&lt;? extends T&gt; handler) &#123; register((Type) type, jdbcType, handler); &#125; /** * 注册typeHandler的核心方法 * 就是向Map新增数据而已 */ private void register(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler) &#123; if (javaType != null) &#123; Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = TYPE_HANDLER_MAP.get(javaType); if (map == null) &#123; map = new HashMap&lt;JdbcType, TypeHandler&lt;?&gt;&gt;(); TYPE_HANDLER_MAP.put(javaType, map); &#125; map.put(jdbcType, handler); if (reversePrimitiveMap.containsKey(javaType)) &#123; register(reversePrimitiveMap.get(javaType), jdbcType, handler); &#125; &#125; ALL_TYPE_HANDLERS_MAP.put(handler.getClass(), handler); &#125; // // REGISTER CLASS // // Only handler type public void register(Class&lt;?&gt; typeHandlerClass) &#123; boolean mappedTypeFound = false; MappedTypes mappedTypes = typeHandlerClass.getAnnotation(MappedTypes.class); if (mappedTypes != null) &#123; for (Class&lt;?&gt; javaTypeClass : mappedTypes.value()) &#123; register(javaTypeClass, typeHandlerClass); mappedTypeFound = true; &#125; &#125; if (!mappedTypeFound) &#123; register(getInstance(null, typeHandlerClass)); &#125; &#125; // java type + handler type public void register(Class&lt;?&gt; javaTypeClass, Class&lt;?&gt; typeHandlerClass) &#123; register(javaTypeClass, getInstance(javaTypeClass, typeHandlerClass)); &#125; // java type + jdbc type + handler type public void register(Class&lt;?&gt; javaTypeClass, JdbcType jdbcType, Class&lt;?&gt; typeHandlerClass) &#123; register(javaTypeClass, jdbcType, getInstance(javaTypeClass, typeHandlerClass)); &#125; // Construct a handler (used also from Builders) @SuppressWarnings("unchecked") public &lt;T&gt; TypeHandler&lt;T&gt; getInstance(Class&lt;?&gt; javaTypeClass, Class&lt;?&gt; typeHandlerClass) &#123; if (javaTypeClass != null) &#123; try &#123; Constructor&lt;?&gt; c = typeHandlerClass.getConstructor(Class.class); return (TypeHandler&lt;T&gt;) c.newInstance(javaTypeClass); &#125; catch (NoSuchMethodException ignored) &#123; // ignored &#125; catch (Exception e) &#123; throw new TypeException("Failed invoking constructor for handler " + typeHandlerClass, e); &#125; &#125; try &#123; Constructor&lt;?&gt; c = typeHandlerClass.getConstructor(); return (TypeHandler&lt;T&gt;) c.newInstance(); &#125; catch (Exception e) &#123; throw new TypeException("Unable to find a usable constructor for " + typeHandlerClass, e); &#125; &#125; /** * 根据指定的pacakge去扫描自定义的typeHander，然后注册 */ public void register(String packageName) &#123; ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;Class&lt;?&gt;&gt;(); resolverUtil.find(new ResolverUtil.IsA(TypeHandler.class), packageName); Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; handlerSet = resolverUtil.getClasses(); for (Class&lt;?&gt; type : handlerSet) &#123; /** * Ignore inner classes and interfaces (including package-info.java) * and abstract classes */ if (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !Modifier.isAbstract(type.getModifiers())) &#123; register(type); &#125; &#125; &#125; // get information /** * 通过configuration对象可以获取已注册的所有typeHandler */ public Collection&lt;TypeHandler&lt;?&gt;&gt; getTypeHandlers() &#123; return Collections.unmodifiableCollection(ALL_TYPE_HANDLERS_MAP.values()); &#125; &#125; 由源码可以看到， mybatis为我们实现了那么多TypeHandler, 随便打开一个TypeHandler，看其源码，都可以看到，它继承自一个抽象类：BaseTypeHandler， 那么我们是不是也能通过继承BaseTypeHandler，从而实现自定义的TypeHandler ? 答案是肯定的， 那么现在下面就为大家演示一下自定义TypeHandler: 自定义TypeHandler1234567891011121314151617181920212223242526272829303132@MappedJdbcTypes(JdbcType.VARCHAR) /*** 此处如果不用注解指定jdbcType, 那么，就可以在配置文件中通过"jdbcType"属性指定，* 同理， javaType 也可通过 @MappedTypes指定*/public class ExampleTypeHandler extends BaseTypeHandler&lt;String&gt; &#123; @Override public void setNonNullParameter(PreparedStatement ps , int i , String parameter , JdbcType jdbcType) throws SQLException &#123; ps.setString(i, parameter); &#125; @Override public String getNullableResult(ResultSet rs , String columnName) throws SQLException &#123; return rs.getString(columnName); &#125; @Override public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123; return rs.getString(columnIndex); &#125; @Override public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123; return cs.getString(columnIndex); &#125;&#125; 然后，就该配置我们的自定义TypeHandler了：1234567891011&lt;configuration&gt; &lt;typeHandlers&gt; &lt;!-- 由于自定义的TypeHandler在定义时已经通过注解指定了jdbcType, 所以此处不用再配置jdbcType --&gt; &lt;typeHandler handler="ExampleTypeHandler"/&gt; &lt;/typeHandlers&gt; ...... &lt;/configuration&gt; 也就是说，我们在自定义TypeHandler的时候，可以在TypeHandler通过@MappedJdbcTypes指定jdbcType, 通过 @MappedTypes 指定javaType, 如果没有使用注解指定，那么我们就需要在配置文件中配置。 好啦，本篇文章到此结束。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列十-SQL执行流程分析（源码篇）]]></title>
    <url>%2F%2Fblog%2Fmybatis-10%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 最近太忙了，一直没时间继续更新博客，今天忙里偷闲继续我的Mybatis学习之旅。在前九篇中，介绍了mybatis的配置以及使用， 那么本篇将走进mybatis的源码，分析mybatis 的执行流程。 SqlSessionFactory 与 SqlSession通过前面的章节对于mybatis 的介绍及使用，大家都能体会到SqlSession的重要性了吧， 没错，从表面上来看，咱们都是通过SqlSession去执行sql语句（注意：是从表面看，实际的待会儿就会讲）。那么咱们就先看看是怎么获取SqlSession的吧： 首先，SqlSessionFactoryBuilder去读取mybatis的配置文件，然后build一个DefaultSqlSessionFactory。源码如下：12345678910111213141516171819202122232425262728/*** 一系列的构造方法最终都会调用本方法（配置文件为Reader时会调用本方法，还有一个InputStream方法与此对应）* @param reader* @param environment* @param properties* @return*/public SqlSessionFactory build(Reader reader,String environment,Properties properties)&#123; try &#123; //通过XMLConfigBuilder解析配置文件，解析的配置相关信息都会封装为一个Configuration对象 XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties); //这儿创建DefaultSessionFactory对象 return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException("Error building SqlSession.", e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; reader.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125;&#125;public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config);&#125; 当我们获取到SqlSessionFactory之后，就可以通过SqlSessionFactory去获取SqlSession对象。源码如下：123456789101112131415161718192021222324252627282930313233343536/*** 通常一系列openSession方法最终都会调用本方法* @param execType * @param level* @param autoCommit* @return*/private SqlSession openSessionFromDataSource(ExecutorType execType , TransactionIsolationLevel level , boolean autoCommit) &#123; Transaction tx = null; try &#123; //通过Confuguration对象获取Mybatis相关配置,Environment对象包含了数据源和事务的配置 final Environment environment = configuration.getEnvironment(); final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment); tx = transactionFactory.newTransaction(environment.getDataSource() , level , autoCommit); /** * 之前说了，从表面上来看，咱们是用sqlSession在执行sql语句， * 实际呢，其实是通过excutor执行， excutor是对于Statement的封装 */ final Executor executor = configuration.newExecutor(tx, execType); //关键看这儿，创建了一个DefaultSqlSession对象 return new DefaultSqlSession(configuration, executor, autoCommit); &#125; catch (Exception e) &#123; // may have fetched a connection so lets call close() closeTransaction(tx); throw ExceptionFactory.wrapException("Error opening session. Cause: " + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125;&#125; 通过以上步骤，咱们已经得到SqlSession对象了。接下来就是该干嘛干嘛去了（话说还能干嘛，当然是执行sql语句咯）。看了上面，咱们也回想一下之前写的Demo,1234567891011SqlSessionFactory sessionFactory = null; String resource = "mybatis-conf.xml"; try &#123; //SqlSessionFactoryBuilder读取配置文件 sessionFactory = new SqlSessionFactoryBuilder().build(Resources .getResourceAsReader(resource));&#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //通过SqlSessionFactory获取SqlSessionSqlSession sqlSession = sessionFactory.openSession(); 还真这么一回事儿，对吧！ SqlSession咱们也拿到了，咱们可以调用SqlSession中一系列的select…, insert…, update…, delete…方法轻松自如的进行CRUD操作了。 就这样？ 那咱配置的映射文件去哪儿了？ 别急， 咱们接着往下看： 利器之MapperProxy在mybatis中，通过MapperProxy动态代理咱们的dao， 也就是说， 当咱们执行自己写的dao里面的方法的时候，其实是对应的mapperProxy在代理。那么，咱们就看看怎么获取MapperProxy对象吧： 通过SqlSession从Configuration中获取。源码如下：1234567/*** 什么都不做，直接去configuration中找， 哥就是这么任性*/@Overridepublic &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123; return configuration.&lt;T&gt;getMapper(type, this);&#125; SqlSession把包袱甩给了Configuration, 接下来就看看Configuration。源码如下：123456789/*** 烫手的山芋，俺不要，你找mapperRegistry去要* @param type* @param sqlSession* @return*/public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; return mapperRegistry.getMapper(type, sqlSession);&#125; Configuration不要这烫手的山芋，接着甩给了MapperRegistry， 那咱看看MapperRegistry。 源码如下：1234567891011121314151617181920212223/*** 烂活净让我来做了，没法了，下面没人了，我不做谁来做* @param type* @param sqlSession* @return*/@SuppressWarnings("unchecked")public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; //能偷懒的就偷懒，俺把粗活交给MapperProxyFactory去做 final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type); if (mapperProxyFactory == null) &#123; throw new BindingException("Type " + type + " is not known to the MapperRegistry."); &#125; try &#123; //关键在这儿 return mapperProxyFactory.newInstance(sqlSession); &#125; catch (Exception e) &#123; throw new BindingException("Error getting mapper instance.Cause: " + e, e); &#125; &#125; MapperProxyFactory是个苦B的人，粗活最终交给它去做了。咱们看看源码：1234567891011121314151617/*** 别人虐我千百遍，我待别人如初恋* @param mapperProxy* @return*/@SuppressWarnings("unchecked")protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123; //动态代理我们写的dao接口 return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader() , new Class[] &#123; mapperInterface &#125;, mapperProxy);&#125; public T newInstance(SqlSession sqlSession) &#123; final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy);&#125; 通过以上的动态代理，咱们就可以方便地使用dao接口啦， 就像之前咱们写的demo那样：12UserDao userMapper = sqlSession.getMapper(UserDao.class); User insertUser = new User(); 这下方便多了吧， 呵呵， 貌似mybatis的源码就这么一回事儿啊。 别急，还没完， 咱们还没看具体是怎么执行sql语句的呢。 Excutor 接下来，咱们才要真正去看sql的执行过程了。 上面，咱们拿到了MapperProxy, 每个MapperProxy对应一个dao接口， 那么咱们在使用的时候，MapperProxy是怎么做的呢？ 源码奉上： MapperProxy源码12345678910111213141516/*** MapperProxy在执行时会触发此方法*/@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; try &#123; return method.invoke(this, args); &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125; final MapperMethod mapperMethod = cachedMapperMethod(method); //二话不说，主要交给MapperMethod自己去管 return mapperMethod.execute(sqlSession, args);&#125; MapperMethod源码12345678910111213141516171819202122232425262728293031323334353637383940414243/*** 看着代码不少，不过其实就是先判断CRUD类型，然后根据类型去选择到底执行sqlSession中的哪个方法，* 绕了一圈，又转回sqlSession了* @param sqlSession* @param args* @return*/public Object execute(SqlSession sqlSession, Object[] args) &#123; Object result; if (SqlCommandType.INSERT == command.getType()) &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.insert(command.getName(), param)); &#125; else if (SqlCommandType.UPDATE == command.getType()) &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.update(command.getName(), param)); &#125; else if (SqlCommandType.DELETE == command.getType()) &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.delete(command.getName(), param)); &#125; else if (SqlCommandType.SELECT == command.getType()) &#123; if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123; executeWithResultHandler(sqlSession, args); result = null; &#125; else if (method.returnsMany()) &#123; result = executeForMany(sqlSession, args); &#125; else if (method.returnsMap()) &#123; result = executeForMap(sqlSession, args); &#125; else &#123; Object param = method.convertArgsToSqlCommandParam(args); result = sqlSession.selectOne(command.getName(), param); &#125; &#125; else &#123; throw new BindingException("Unknown execution method for: " + command.getName()); &#125; if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123; throw new BindingException("Mapper method '" + command.getName() + "attempted to return null from a method with a primitive return type (" + method.getReturnType() + ")."); &#125; return result;&#125; 既然又回到SqlSession了， 那么咱们就看看SqlSession的CRUD方法了，为了省事，还是就选择其中的一个方法来做分析吧。这儿，咱们选择了selectList方法：1234567891011121314151617181920public &lt;E&gt; List&lt;E&gt; selectList(String statement , Object parameter , RowBounds rowBounds) &#123; try &#123; MappedStatement ms = configuration.getMappedStatement(statement); /** * CRUD实际上是交给Excetor去处理， excutor其实也只是穿了个马甲而已， * 小样，别以为穿个马甲我就不认识你嘞！ */ return executor.query(ms , wrapCollection(parameter) , rowBounds , Executor.NO_RESULT_HANDLER); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException("Error querying database. Cause: " + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125;&#125; 然后，通过一层一层的调用，最终会来到doQuery方法， 这儿咱们就随便找个Excutor看看doQuery方法的实现吧，我这儿选择了SimpleExecutor: SimpleExecutor12345678910111213141516171819202122public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms , Object parameter , RowBounds rowBounds , ResultHandler resultHandler , BoundSql boundSql) throws SQLException &#123; Statement stmt = null; try &#123; Configuration configuration = ms.getConfiguration(); StatementHandler handler = configuration.newStatementHandler( wrapper , ms, parameter , rowBounds , resultHandler , boundSql); stmt = prepareStatement(handler, ms.getStatementLog()); //StatementHandler封装了Statement, 让 StatementHandler 去处理 return handler.&lt;E&gt;query(stmt, resultHandler); &#125; finally &#123; closeStatement(stmt); &#125;&#125; 接下来，咱们看看StatementHandler 的一个实现类 PreparedStatementHandler（这也是我们最常用的，封装的是PreparedStatement）, 看看它使怎么去处理的：12345678public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123; //到此，原形毕露， PreparedStatement, 这个大家都已经滚瓜烂熟了吧 PreparedStatement ps = (PreparedStatement) statement; ps.execute(); //结果交给了ResultSetHandler 去处理 return resultSetHandler.&lt;E&gt; handleResultSets(ps);&#125; 到此， 一次sql的执行流程就完了。 我这儿仅抛砖引玉，建议有兴趣的去看看Mybatis3的源码。 好啦，本次就到此结束啦]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列三-配置详解之properties与environments（mybatis源码篇）]]></title>
    <url>%2F%2Fblog%2Fmybatis-3%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（二）—配置简介（mybatis源码篇）》我们通过对mybatis源码的简单分析，可看出，在mybatis配置文件中，在configuration根节点下面，可配置properties、typeAliases、plugins、objectFactory、objectWrapperFactory、settings、environments、databaseIdProvider、typeHandlers、mappers这些节点。那么本次，就会先介绍properties节点和environments节点。 为了让大家能够更好地阅读mybatis源码，我先简单的给大家示例一下properties的使用方法。 properties节点1234567891011&lt;configuration&gt; &lt;!-- 方法一：从外部指定properties配置文件, 除了使用resource属性指定外，还可通过url属性指定url &lt;properties resource="dbConfig.properties"&gt;&lt;/properties&gt; --&gt; &lt;!-- 方法二： 直接配置为xml --&gt; &lt;properties&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test1"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/properties&gt; 那么，我要是 两种方法都同时用了，那么哪种方法优先？当以上两种方法都xml配置优先， 外部指定properties配置其次。至于为什么，接下来的源码分析会提到，请留意一下。 再看一下envirements元素节点的使用方法吧. envirements节点12345678910111213141516171819202122232425262728293031323334&lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 如果上面没有指定数据库配置的properties文件，那么此处可以这样直接配置 &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test1"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; --&gt; &lt;!-- 上面指定了数据库配置文件， 配置文件里面也是对应的这四个属性 --&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!-- 我再指定一个environment --&gt; &lt;environment id="test"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;!-- 与上面的url不一样 --&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/demo"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; environments元素节点可以配置多个environment子节点， 怎么理解呢？ 假如我们系统的开发环境和正式环境所用的数据库不一样（这是肯定的）， 那么可以设置两个environment, 两个id分别对应开发环境（dev）和正式环境（final），那么通过配置environments的default属性就能选择对应的environment了， 例如，我将environments的deault属性的值配置为dev, 那么就会选择dev的environment。 至于这个是怎么实现的， 下面源码就会讲。 好啦，上面简单给大家介绍了一下properties 和 environments 的配置， 接下来就正式开始看源码了： 上次我们说过mybatis 是通过XMLConfigBuilder这个类在解析mybatis配置文件的，那么本次就接着看看XMLConfigBuilder对于properties和environments的解析。 XMLConfigBuilder源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public class XMLConfigBuilder extends BaseBuilder &#123; private boolean parsed; //xml解析器 private XPathParser parser; private String environment; /** * 上次说到这个方法是在解析mybatis配置文件中能配置的元素节点 * 今天首先要看的就是properties节点和environments节点 */ private void parseConfiguration(XNode root) &#123; try &#123; //解析properties元素 //issue #117 read properties first propertiesElement(root.evalNode("properties")); typeAliasesElement(root.evalNode("typeAliases")); pluginElement(root.evalNode("plugins")); objectFactoryElement(root.evalNode("objectFactory")); objectWrapperFactoryElement(root.evalNode("objectWrapperFactory")); settingsElement(root.evalNode("settings")); //解析environments元素 // read it after objectFactory and objectWrapperFactory issue #631 environmentsElement(root.evalNode("environments")); databaseIdProviderElement(root.evalNode("databaseIdProvider")); typeHandlerElement(root.evalNode("typeHandlers")); mapperElement(root.evalNode("mappers")); &#125; catch (Exception e) &#123; throw new BuilderException("Error parsing SQL Mapper Configuration.Cause: " + e, e); &#125; &#125; //下面就看看解析properties的具体方法 private void propertiesElement(XNode context) throws Exception &#123; if (context != null) &#123; /** * 将子节点的 name 以及value属性set进properties对象 * 这儿可以注意一下顺序，xml配置优先， 外部指定properties配置其次 */ Properties defaults = context.getChildrenAsProperties(); //获取properties节点上 resource属性的值 String resource = context.getStringAttribute("resource"); //获取properties节点上 url属性的值, resource和url不能同时配置 String url = context.getStringAttribute("url"); if (resource != null &amp;&amp; url != null) &#123; throw new BuilderException("The properties element cannot specify both a URL and a resource based property file reference. Please specify one or the other."); &#125; //把解析出的properties文件set进Properties对象 if (resource != null) &#123; defaults.putAll(Resources.getResourceAsProperties(resource)); &#125; else if (url != null) &#123; defaults.putAll(Resources.getUrlAsProperties(url)); &#125; /** * 将configuration对象中已配置的Properties属性与刚刚解析的融合 * configuration这个对象会装载所解析mybatis配置文件的所有节点元素， * 以后也会频频提到这个对象，既然configuration对象用有一系列的get/set方法, * 那是否就标志着我们可以使用java代码直接配置？ * 答案是肯定的， 不过使用配置文件进行配置，优势不言而喻 */ Properties vars = configuration.getVariables(); if (vars != null) &#123; defaults.putAll(vars); &#125; //把装有解析配置propertis对象set进解析器， 因为后面可能会用到 parser.setVariables(defaults); //set进configuration对象 configuration.setVariables(defaults); &#125; &#125; //下面再看看解析enviroments元素节点的方法 private void environmentsElement(XNode context) throws Exception &#123; if (context != null) &#123; if (environment == null) &#123; //解析environments节点的default属性的值 //例如: &lt;environments default="development"&gt; environment = context.getStringAttribute("default"); &#125; //递归解析environments子节点 for (XNode child : context.getChildren()) &#123; /** * &lt;environment id="development"&gt;, 只有enviroment节点有id属性， * 那么这个属性有何作用？environments节点下可以拥有多个environment子节点 * 类似于这样： * &lt;environments default="development"&gt; * &lt;environment id="development"&gt;...&lt;/environment&gt; * &lt;environment id="test"&gt;...&lt;/environment&gt; * &lt;/environments&gt; * 意思就是我们可以对应多个环境，比如开发环境，测试环境等， * 由environments的default属性,去选择对应的enviroment */ String id = child.getStringAttribute("id"); //isSpecial就是根据由environments的default属性去选择对应的enviroment if (isSpecifiedEnvironment(id)) &#123; /** * 事务，mybatis有两种：JDBC 和 MANAGED, 配置为JDBC则直接使用JDBC的事务， * 配置为MANAGED则是将事务托管给容器 */ TransactionFactory txFactory =transactionManagerElement(child.evalNode("transactionManager")); /** * enviroment节点下面就是dataSource节点了，解析dataSource节点 * 下面会贴出解析dataSource的具体方法 */ DataSourceFactory dsFactory = dataSourceElement(child.evalNode("dataSource")); DataSource dataSource = dsFactory.getDataSource(); Environment.Builder environmentBuilder=new Environment.Builder(id) .transactionFactory(txFactory) .dataSource(dataSource); //老规矩，会将dataSource设置进configuration对象 configuration.setEnvironment(environmentBuilder.build()); &#125; &#125; &#125; &#125; //下面看看dataSource的解析方法 private DataSourceFactory dataSourceElement(XNode context) throws Exception &#123; if (context != null) &#123; //dataSource的连接池 String type = context.getStringAttribute("type"); //子节点 name, value属性set进一个properties对象 Properties props = context.getChildrenAsProperties(); //创建dataSourceFactory DataSourceFactory factory = (DataSourceFactory) resolveClass(type).newInstance(); factory.setProperties(props); return factory; &#125; throw new BuilderException("Environment declaration requires a DataSourceFactory."); &#125; &#125; 通过以上对mybatis源码的解读，相信大家对mybatis的配置又有了一个深入的认识。 还有一个问题， 上面我们看到，在配置dataSource的时候使用了 ${driver} 这种表达式， 这种形式是怎么解析的？其实，是通过PropertyParser这个类解析： PropertyParser源码1234567891011121314151617181920212223242526/** * 这个类解析$&#123;&#125;这种形式的表达式 */public class PropertyParser &#123; public static String parse(String string, Properties variables) &#123; VariableTokenHandler handler = new VariableTokenHandler(variables); GenericTokenParser parser = new GenericTokenParser("$&#123;", "&#125;", handler); return parser.parse(string); &#125; private static class VariableTokenHandler implements TokenHandler &#123; private Properties variables; public VariableTokenHandler(Properties variables) &#123; this.variables = variables; &#125; public String handleToken(String content) &#123; if (variables != null &amp;&amp; variables.containsKey(content)) &#123; return variables.getProperty(content); &#125; return "$&#123;" + content + "&#125;"; &#125; &#125;&#125; 好啦，以上就是对于properties 和 environments元素节点的分析，比较重要的都在对于源码的注释中标出。本次文章到此结束，接下来的文章会继续分析其他节点的配置。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列四-配置详解之typeAliases别名（mybatis源码篇）]]></title>
    <url>%2F%2Fblog%2Fmybatis-4%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（三）—配置详解之properties与environments（mybatis源码篇）》 介绍了properties与environments， 本篇继续讲剩下的配置节点之一：typeAliases。 typeAliases节点主要用来设置别名，其实这是挺好用的一个功能， 通过配置别名，我们不用再指定完整的包名，并且还能取别名。 例如： 我们在使用 com.demo.entity. UserEntity 的时候，我们可以直接配置一个别名user, 这样以后在配置文件中要使用到com.demo.entity. UserEntity的时候，直接使用User即可。 就以上例为例，我们来实现一下，看看typeAliases的配置方法: typeAliases配置1234567891011121314&lt;configuration&gt; &lt;typeAliases&gt; &lt;!-- 通过package, 可以直接指定package的名字， mybatis会自动扫描你指定包下面的javabean, 并且默认设置一个别名，默认的名字为： javabean 的首字母小写的非限定类名来作为它的别名。 也可在javabean 加上注解@Alias 来自定义别名， 例如： @Alias(user) &lt;package name="com.dy.entity"/&gt; --&gt; &lt;typeAlias alias="UserEntity" type="com.dy.entity.User"/&gt; &lt;/typeAliases&gt; ...... &lt;/configuration&gt; 再写一段测试代码，看看有没生效：（我只写一段伪代码）123456Configuration con = sqlSessionFactory.getConfiguration();Map&lt;String, Class&lt;?&gt;&gt; typeMap = con.getTypeAliasRegistry().getTypeAliases();for(Entry&lt;String, Class&lt;?&gt;&gt; entry: typeMap.entrySet()) &#123; System.out.println(entry.getKey() + " ================&gt; " + entry.getValue().getSimpleName());&#125; 上面给大家简单介绍了typeAliases的用法， 接下来就看看Mybatis中的源码了。 老规矩，先从对xml的解析讲起： typeAliases源码123456789101112131415161718192021222324252627282930313233/** * 解析typeAliases节点 */private void typeAliasesElement(XNode parent) &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; //如果子节点是package, 那么就获取package节点的name属性， mybatis会扫描指定的package if ("package".equals(child.getName())) &#123; String typeAliasPackage = child.getStringAttribute("name"); /** * TypeAliasRegistry 负责管理别名， 这儿就是通过TypeAliasRegistry 进行别名注册， * 下面就会看看TypeAliasRegistry源码 */ configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage); &#125; else &#123; //如果子节点是typeAlias节点，那么就获取alias属性和type的属性值 String alias = child.getStringAttribute("alias"); String type = child.getStringAttribute("type"); try &#123; Class&lt;?&gt; clazz = Resources.classForName(type); if (alias == null) &#123; typeAliasRegistry.registerAlias(clazz); &#125; else &#123; typeAliasRegistry.registerAlias(alias, clazz); &#125; &#125; catch (ClassNotFoundException e) &#123; throw new BuilderException("Error registering typeAlias for '" + alias + "'. Cause: " + e, e); &#125; &#125; &#125; &#125; &#125; 重要的源码在这儿! TypeAliasRegistry源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162public class TypeAliasRegistry &#123; /** * 这就是核心所在啊， 原来别名就仅仅通过一个HashMap来实现， * key为别名， value就是别名对应的类型（class对象） */ private final Map&lt;String, Class&lt;?&gt;&gt; TYPE_ALIASES = new HashMap&lt;String, Class&lt;?&gt;&gt;(); /** * 以下就是mybatis默认为我们注册的别名 */ public TypeAliasRegistry() &#123; registerAlias("string", String.class); registerAlias("byte", Byte.class); registerAlias("long", Long.class); registerAlias("short", Short.class); registerAlias("int", Integer.class); registerAlias("integer", Integer.class); registerAlias("double", Double.class); registerAlias("float", Float.class); registerAlias("boolean", Boolean.class); registerAlias("byte[]", Byte[].class); registerAlias("long[]", Long[].class); registerAlias("short[]", Short[].class); registerAlias("int[]", Integer[].class); registerAlias("integer[]", Integer[].class); registerAlias("double[]", Double[].class); registerAlias("float[]", Float[].class); registerAlias("boolean[]", Boolean[].class); registerAlias("_byte", byte.class); registerAlias("_long", long.class); registerAlias("_short", short.class); registerAlias("_int", int.class); registerAlias("_integer", int.class); registerAlias("_double", double.class); registerAlias("_float", float.class); registerAlias("_boolean", boolean.class); registerAlias("_byte[]", byte[].class); registerAlias("_long[]", long[].class); registerAlias("_short[]", short[].class); registerAlias("_int[]", int[].class); registerAlias("_integer[]", int[].class); registerAlias("_double[]", double[].class); registerAlias("_float[]", float[].class); registerAlias("_boolean[]", boolean[].class); registerAlias("date", Date.class); registerAlias("decimal", BigDecimal.class); registerAlias("bigdecimal", BigDecimal.class); registerAlias("biginteger", BigInteger.class); registerAlias("object", Object.class); registerAlias("date[]", Date[].class); registerAlias("decimal[]", BigDecimal[].class); registerAlias("bigdecimal[]", BigDecimal[].class); registerAlias("biginteger[]", BigInteger[].class); registerAlias("object[]", Object[].class); registerAlias("map", Map.class); registerAlias("hashmap", HashMap.class); registerAlias("list", List.class); registerAlias("arraylist", ArrayList.class); registerAlias("collection", Collection.class); registerAlias("iterator", Iterator.class); registerAlias("ResultSet", ResultSet.class); &#125; /** * 处理别名， 直接从保存有别名的hashMap中取出即可 */ @SuppressWarnings("unchecked") public &lt;T&gt; Class&lt;T&gt; resolveAlias(String string) &#123; try &#123; if (string == null) return null; String key = string.toLowerCase(Locale.ENGLISH); // issue #748 Class&lt;T&gt; value; if (TYPE_ALIASES.containsKey(key)) &#123; value = (Class&lt;T&gt;) TYPE_ALIASES.get(key); &#125; else &#123; value = (Class&lt;T&gt;) Resources.classForName(string); &#125; return value; &#125; catch (ClassNotFoundException e) &#123; throw new TypeException("Could not resolve type alias '" + string + "'. Cause: " + e, e); &#125; &#125; /** * 配置文件中配置为package的时候， 会调用此方法，根据配置的报名去扫描javabean ， * 然后自动注册别名，默认会使用 Bean 的首字母小写的非限定类名来作为它的别名 * 也可在javabean 加上注解@Alias 来自定义别名， 例如： @Alias(user) */ public void registerAliases(String packageName)&#123; registerAliases(packageName, Object.class); &#125; public void registerAliases(String packageName, Class&lt;?&gt; superType)&#123; ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;Class&lt;?&gt;&gt;(); resolverUtil.find(new ResolverUtil.IsA(superType), packageName); Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; typeSet = resolverUtil.getClasses(); for(Class&lt;?&gt; type : typeSet)&#123; // Ignore inner classes and interfaces (including package-info.java) // Skip also inner classes. See issue #6 if (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !type.isMemberClass()) &#123; registerAlias(type); &#125; &#125; &#125; public void registerAlias(Class&lt;?&gt; type) &#123; String alias = type.getSimpleName(); Alias aliasAnnotation = type.getAnnotation(Alias.class); if (aliasAnnotation != null) &#123; alias = aliasAnnotation.value(); &#125; registerAlias(alias, type); &#125; /** * 这就是注册别名的本质方法， 其实就是向保存别名的hashMap新增值而已， * 呵呵，别名的实现太简单了，对吧 */ public void registerAlias(String alias, Class&lt;?&gt; value) &#123; if (alias == null) throw new TypeException("The parameter alias cannot be null"); String key = alias.toLowerCase(Locale.ENGLISH); // issue #748 if (TYPE_ALIASES.containsKey(key) &amp;&amp; TYPE_ALIASES.get(key) != null &amp;&amp; !TYPE_ALIASES.get(key).equals(value)) &#123; throw new TypeException("The alias '" + alias + "' is already mapped to the value '" + TYPE_ALIASES.get(key).getName() + "'."); &#125; TYPE_ALIASES.put(key, value); &#125; public void registerAlias(String alias, String value) &#123; try &#123; registerAlias(alias, Resources.classForName(value)); &#125; catch (ClassNotFoundException e) &#123; throw new TypeException("Error registering type alias " +alias+" for "+value+". Cause: " + e, e); &#125; &#125; /** * 获取保存别名的HashMap, Configuration对象持有对TypeAliasRegistry的引用， * 因此，如果需要，我们可以通过Configuration对象获取 */ public Map&lt;String, Class&lt;?&gt;&gt; getTypeAliases() &#123; return Collections.unmodifiableMap(TYPE_ALIASES); &#125;&#125; 由源码可见，设置别名的原理就这么简单，Mybatis默认给我们设置了不少别名，在上面代码中都可以见到。 好啦，本篇内容就是这么简单，到此为止。 下篇将继续讲解还没讲完的配置节点。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列二-配置简介（mybatis源码篇）]]></title>
    <url>%2F%2Fblog%2Fmybatis-2%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（一）—Mybatis入门》， 写了一个Demo简单体现了一下Mybatis的流程。本次，将简单介绍一下Mybatis的配置文件： 上次例子中，我们以 SqlSessionFactoryBuilder 去创建 SqlSessionFactory, 那么，我们就先从SqlSessionFactoryBuilder入手， 咱们先看看源码是怎么实现的： SqlSessionFactoryBuilder源码123456789101112131415161718192021222324252627282930313233343536373839404142434445public class SqlSessionFactoryBuilder &#123; /** * Reader读取mybatis配置文件，传入构造方法 * 除了Reader外，其实还有对应的inputStream作为参数的构造方法， * 这也体现了mybatis配置的灵活性 */ public SqlSessionFactory build(Reader reader) &#123; return build(reader, null, null); &#125; public SqlSessionFactory build(Reader reader, String environment) &#123; return build(reader, environment, null); &#125; //mybatis配置文件 + properties, 此时mybatis配置文件中可以不配置properties，也能使用$&#123;&#125;形式 public SqlSessionFactory build(Reader reader, Properties properties) &#123; return build(reader, null, properties); &#125; //通过XMLConfigBuilder解析mybatis配置，然后创建SqlSessionFactory对象 public SqlSessionFactory build(Reader reader , String environment , Properties properties) &#123; try &#123; XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties); //下面看看这个方法的源码 return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException("Error building SqlSession.", e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; reader.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125; public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config); &#125;&#125; 通过源码，我们可以看到SqlSessionFactoryBuilder 通过XMLConfigBuilder 去解析我们传入的mybatis的配置文件， 下面就接着看看 XMLConfigBuilder 部分源码： XMLConfigBuilder源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * mybatis 配置文件解析 */public class XMLConfigBuilder extends BaseBuilder &#123; public XMLConfigBuilder(InputStream inputStream,String environment,Properties props)&#123; this(new XPathParser(inputStream, true, props , new XMLMapperEntityResolver()), environment, props); &#125; private XMLConfigBuilder(XPathParser parser, String environment, Properties props) &#123; super(new Configuration()); ErrorContext.instance().resource("SQL Mapper Configuration"); this.configuration.setVariables(props); this.parsed = false; this.environment = environment; this.parser = parser; &#125; //外部调用此方法对mybatis配置文件进行解析 public Configuration parse() &#123; if (parsed) &#123; throw new BuilderException("Each XMLConfigBuilder can only be used once."); &#125; parsed = true; //从根节点configuration parseConfiguration(parser.evalNode("/configuration")); return configuration; &#125; //此方法就是解析configuration节点下的子节点 //由此也可看出，我们在configuration下面能配置的节点为以下10个节点 private void parseConfiguration(XNode root) &#123; try &#123; //issue #117 read properties first propertiesElement(root.evalNode("properties")); typeAliasesElement(root.evalNode("typeAliases")); pluginElement(root.evalNode("plugins")); objectFactoryElement(root.evalNode("objectFactory")); objectWrapperFactoryElement(root.evalNode("objectWrapperFactory")); settingsElement(root.evalNode("settings")); // read it after objectFactory and objectWrapperFactory issue #631 environmentsElement(root.evalNode("environments")); databaseIdProviderElement(root.evalNode("databaseIdProvider")); typeHandlerElement(root.evalNode("typeHandlers")); mapperElement(root.evalNode("mappers")); &#125; catch (Exception e) &#123; throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e); &#125; &#125;&#125; 通过以上源码，我们就能看出，在mybatis的配置文件中： configuration节点为根节点。 在configuration节点之下，我们可以配置10个子节点， 分别为：properties、typeAliases、plugins、objectFactory、objectWrapperFactory、settings、environments、databaseIdProvider、typeHandlers、mappers。 本篇文章就先只介绍这些内容，接下来的文章将依次分析解析这个10个节点中比较重要的几个节点的源码，看看在解析这些节点的时候，到底做了些什么。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列一-Mybatis入门]]></title>
    <url>%2F%2Fblog%2Fmybatis-1%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 最近两年 springmvc + mybatis 的在这种搭配还是蛮火的，楼主我呢，也从来没真正去接触过mybatis, 趁近日得闲， 就去学习一下mybatis吧。 本次拟根据自己的学习进度，做一次关于mybatis 的一系列教程， 记录自己的学习历程， 同时也给还没接触过mybatis的朋友探一次道。本系列教程拟 由浅（使用）入深（分析mybatis源码实现），故可能需要好长几天才能更新完。好啦，下面就开始本次的mybatis 学习之旅啦， 本次为第一篇教程， 就先简单地写个demo, 一起来认识一下mybatis吧。 为了方便，我使用了maven，至于maven怎么使用，我就不做介绍了。没用过maven的，也不影响阅读。 Mybatis环境搭建新建web项目， 添加依赖包：mybatis包、数据库驱动包(我使用的是mysql)、日志包(我使用的是log4j)， 由于我的是maven项目， 那么添加依赖包就简单了，直接在pom.xml添加依赖即可。 pom.xml 12345678910111213141516171819202122232425262728293031&lt;dependencies&gt; &lt;!-- 添加junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 添加log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置mybatis在classpath建立一个用于配置log4j的配置文件log4j.properties, 再建立一个用于配置Mybatis的配置文件configuration.xml（文件可随便命名）。log4j的配置，我就不多说，这儿主要说一下configuration.xml: configuration.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 指定properties配置文件， 我这里面配置的是数据库相关 --&gt; &lt;properties resource="dbConfig.properties"&gt;&lt;/properties&gt; &lt;!-- 指定Mybatis使用log4j --&gt; &lt;settings&gt; &lt;setting name="logImpl" value="LOG4J"/&gt; &lt;/settings&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 如果上面没有指定数据库配置的properties文件，那么此处可以这样直接配置 &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test1"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; --&gt; &lt;!-- 上面指定了数据库配置文件， 配置文件里面也是对应的这四个属性 --&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射文件，mybatis精髓， 后面才会细讲 --&gt; &lt;mappers&gt; &lt;mapper resource="com/dy/dao/userDao-mapping.xml"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 开始写Demo首先，在mysql数据库test1建立一张表user。 先编写一个实体类User: User类用于与User表相对应。 User12345678910public class User &#123; private int id; private String name; private String password; private int age; private int deleteFlag; //setter和getter方法省略...&#125; 再编写一个UserDao 接口： UserDao12345public interface UserDao &#123; public void insert(User user); public User findUserById (int userId); public List&lt;User&gt; findAllUsers();&#125; 再编写一个userDao-mapping.xml （可随便命名）: userDao-mapping.xml123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN" "http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.dy.dao.UserDao"&gt; &lt;select id="findUserById" resultType="com.dy.entity.User" &gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; userDao-mapping.xml相当于是UserDao的实现， 同时也将User实体类与数据表User成功关联起来。 测试代码DemoUserDaoTest12345678910111213141516171819202122public class UserDaoTest &#123; @Test public void findUserById() &#123; SqlSession sqlSession = getSessionFactory().openSession(); UserDao userMapper = sqlSession.getMapper(UserDao.class); User user = userMapper.findUserById(2); Assert.assertNotNull("没找到数据", user); &#125; //Mybatis 通过SqlSessionFactory获取SqlSession, 然后才能通过SqlSession与数据库进行交互 private static SqlSessionFactory getSessionFactory() &#123; SqlSessionFactory sessionFactory = null; String resource = "configuration.xml"; try &#123; sessionFactory = new SqlSessionFactoryBuilder().build(Resources .getResourceAsReader(resource)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return sessionFactory; &#125; &#125; 好啦，这样一个简单的mybatis 的demo就能成功运行啦。通过这个demo, 应该你就也能初步看出mybatis的运行机制，如果不清楚，也没关系。从下一篇文章开始，才开始正式讲解mybatis。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo一站式部署个人博客]]></title>
    <url>%2F%2Fblog%2Fhexo-blog%2F</url>
    <content type="text"><![CDATA[写在前面注：本文出自博主：chloneda 本文档是Github + Hexo 的搭建个人博客教程，其中Hexo基于Hexo v3.8.0版本，themes主题基于为NexT v7.0.0版本。 搭建博客前置条件可参考 如何搭建个人独立博客？ 个人博客地址： Chloneda’s blog 注： 点开侧栏浏览目录可快速定位内容 安装主题在 Hexo 项目源码目录下，有两个重要的配置文件，其名称均为 _config.yml 。 其中，一份位于站点根目录下，主要包含 Hexo本身的配置；另一份位于主题目录下，主要用于主题相关的配置。为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。 下载NexT主题12cd hexogit clone https://github.com/theme-next/hexo-theme-next themes/next 启用NexT主题修改站点配置文件，查找关键词theme，并修改为主题名字next：1234# Extensions #(注意冒号间的空格)## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 主题设置设置Scheme在Hexo主题中，有四种不同的模式！进入主题配置文件，搜索关键词找到scheme属性，选择自己喜欢的模式：12345678# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes# scheme: Muse # 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白scheme: Mist # Muse 的紧凑版本，整洁有序的单栏外观# scheme: Pisces # 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白# scheme: Gemini # 类似 Pisces 设置语言编辑站点配置文件，搜索关键词language，并设置成你所需要的语言：1language: zh-CN 设置菜单进入主题配置文件，找到menu字段，菜单内容的设置格式是：item name: link || menu photo，其中item name 是一个名称，link时具体菜单分类，菜单的||后面是菜单的图标,具体菜单图标可参考Font Awesome网站。12345678# 菜单示例配置menu: home: / || home reading: /reading/ || book archives: /archives/ || archive categories: /categories/ || th #tags: /tags/ || tags about: /about/ || user 头像设置在主题配置文件，搜索字段avatar，值设置成头像的链接地址。1234567# 将头像放置主题目录下的 source/uploads/ （新建uploads目录若不存在） 配置为：avatar: /uploads/avatar.png# 放置在 source/images/ 目录下, 配置为：avatar: /images/avatar.png# 完整的互联网 URIavatar: url: http://example.com/avatar.png 设置侧边栏在主题配置文件，搜索sidebar关键词，设置为hide模式，如下图所示：12345sidebar: #display: post // 默认显示方式 #display: always // 一直显示 display: hide // 初始隐藏 #display: remove // 移除侧边栏 各位可根据个人喜好进行设置。 设置站点描述在站点配置文件中，搜索关键词Site，如下：123456# Sitetitle: Chloneda #你的站点标题subtitle: Less is moredescription: Less is more #你的站点描述keywords: chlonedaauthor: chloneda #站点作者 进阶设定添加标签页面hexo根目录下，执行以下命令，新建标签页面。1hexo new page tags 修改站点目录source/tags的 index.md 文件：123456---title: 添加标签页面测试tags: Test #添加标签categories: Test #添加分类comments: false--- 修改主题配置文件，搜索关键词menu，取消 #tags: /tags/ || tags注释，内容如下:12345678# 菜单示例配置menu: home: / || home reading: /reading/ || book archives: /archives/ || archive categories: /categories/ || th tags: /tags/ || tags about: /about/ || user 注：添加其他页面也类似。 首页显示预览首页显示文章列表，列表里的每一篇文章只显示预览，不显示全文。 进入主题配置文件，搜索关键词auto_excerpt，把enable对应的false改为true。12345# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 友情链接打开主题配置文件,搜索关键字 Blog rolls,添加自己需要的链接：123links: #连接 baidu: https://www.baidu.com/ google: https://www.google.com/ 本地搜索在Hexo的根目录下执行以下命令。1$ npm install hexo-generator-searchdb --save 打开主题配置文件,搜索关键字local_search,将enable的值设置为 true：1234# Local search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search: enable: true 打开站点配置文件，搜索关键词search，修改为如下内容：123456# 本地搜索search: path: search.xml field: post format: html limit: 10000 添加RSS在Hexo根目录执行安装指令，安装 hexo-generator-feed 插件：1npm install hexo-generator-feed --save 打开站点配置文件，追加feed信息:1234567# 设置RSSfeed: type: rss2 path: rss2.html limit: 5 hub: content: 'true' 打开主题配置文件，找到rss，设置为:1rss: /atom.xml 添加社交链接在主题配置文件中，找到social属性，添加社交链接，步骤如下：12345social: E-Mail: mailto:yourname@gmail.com || envelope Google: https://plus.google.com/yourname || google Twitter: https://twitter.com/yourname || twitter Facebook: https://www.facebook.com/yourname || facebook 格式为： 社交平台名称：链接 设置代码高亮首先需要改动的地方有： 站点配置文件_config.yml。 主题配置文件_config.yml。 在站点配置文件中，搜索highlight关键词:12345highlight: enable: true line_number: true auto_detect: true tab_replace: 文字自动检测默认不启动，改成true使其起作用。 再到主题配置文件，搜索highlight_theme关键词，修改代码主题样式：1234# Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night 添加复制按钮在主题配置文件中，搜索关键词codeblock，将copy_button的enable值修改为true。1234567codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1 border_radius: # Add copy button on codeblock copy_button: enable: true 添加阅读次数统计主题配置文件中，搜索关键词busuanzi_count，设置文章阅读次数统计及网站访客量:12345678910# Show Views/Visitors of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzibusuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye 添加 README.md每个项目README.md文件可以简单说明这个项目的用途。在Hexo目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件，将 skip_render 参数的值设置为：1skip_render: README.md 再次使用hexo d命令部署博客的时候就不会在渲染 README.md 这个文件。 进阶配置自定义网站头像自定义头像可以使用 比特虫 网站制作！ 在主题配置文件中，按以下修改：1234567favicon: small: /images/favicon-16x16-next.png #你的头像名称 medium: /images/favicon-32x32-next.png #你的头像名称 apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 添加自定义页面[友链]设置菜单项的显示中文文本，打开themes/next/languages/zh-CN.yml文件,搜索 menu 关键字，修改对应中文或者新增。123456789101112menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 # schedule: 日程表 # sitemap: 站点地图 # commonweal: 公益404 # 新增menu links: 友链 # 新增该选项表示新增“友链”菜单 在主题配置文件，搜索menu，新增links: /links/ || link：123456789# 菜单示例配置menu: home: / || home reading: /reading/ || book archives: /archives/ || archive categories: /categories/ || th #tags: /tags/ || tags about: /about/ || user links: /links/ || link hexo根目录下，执行以下命令，新建友链页面。1hexo new page links 修改站点目录下source/links的 index.md 文件：123456---title: 友链tags: linkscategories: linkscomments: false--- 注：其它自定义菜单也是类似步骤 增加背景音乐在本博客的侧边栏增加网易云音乐，生成音乐外链可参考链接 ，复制链接，将外链插入到Hexo根路径的侧边栏文件中：/themes/next/layout/_macro/sidebar.swig，即侧边栏友情链接theme.links这一项之后。12345678910111213141516&#123;% if theme.links %&#125; &lt;div&gt; &lt;div class="links-of-blogroll-title"&gt; ....省略部分代码 &lt;/div&gt; &lt;ul class="links-of-blogroll-list"&gt; ....省略部分代码 &lt;/ul&gt; &lt;/div&gt;&#123;% endif %&#125; &lt;div id="music163player"&gt; &lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&amp;id=5239700&amp;auto=0&amp;height=66"&gt; &lt;/iframe&gt; &lt;/div&gt; 添加打赏功能如今已进入知识付费时代，打赏是读者对笔者创造的最大支持，更是对劳动者的尊重。打赏功能具体步骤为：获取二维码 微信二维码的获取（可百度）。 获取支付宝收款二维码（可百度）。 添加二维码图片资源得到二维码图片资源后，读者们可将二维码图片放到NexT根目录/source/images/文件夹下。 开启打赏功能打开主题配置文件，搜索reward关键词，添加打赏的配置信息。12345678# Reward# If true, reward would be displayed in every article by default.# And you can show or hide one article specially through add page variable `reward: true/false`.reward: enable: true //默认是false，改为true comment: 您的支持是对我最大的鼓励 wechatpay: /images/wechatpay.jpg #图片链接或图片相对路径 alipay: /images/alipay.jpg #图片链接或图片相对路径 开启版权声明打开主题配置文件,搜索关键字 creative_commons , post 改为 true：1234creative_commons: license: by-nc-sa sidebar: false post: true 优化及设置优化urlseo搜索引擎优化认为，网站的最佳结构是三层，但是默认hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，url不利于搜索引擎搜索。 因此，我们可以将url直接改成sitename/blog/title的形式，同时title最好是用英文，在站点配置文件搜索permalink关键词，并修改如下。1234url: https://chloneda.github.io/root: /permalink: /blog/:title.htmlpermalink_defaults: Hexo博客备份利用github分支功能进行博客备份，思路说明: master分支：存放博客的静态网页(默认分支)。 hexo分支：存放Hexo博客的源码文件。 master分支部署进入站点配置文件编辑，搜索deploy关键词：1234deploy: type: git repo: https://github.com/你的github用户名/你的github用户名.github.io.git branch: master 修改更新博客内容并保存。 执行hexo clean清除本地旧代码。 执行hexo g -d生成静态网站并部署到GitHub的master分支上。 hexo分支配置 hexo分支，该分支为博客源码分支。 使用git clone -b hexo 你的github仓库路径， 拷贝源码仓库。 修改hexo主配置_config.xml的deploy部分配置，设置静态页面的发布分支为master。 添加.gitignore文件，将静态网页的目录及其他无需提交的源文件及目录排除掉。 博客源码更新在本地对博客进行修改后，提交hexo源代码：1234git checkout hexogit add .git commit -m 'Code update'git push origin hexo 发布hexo静态文件hexo根目录依次执行以下命令：123hexo cleanhexo generate 或者 hexo ghexo deploy 或者 hexo d 本地资料丢失或其他主机搭建博客步骤： 拷贝hexo分支源码到本地：git clone -b hexo github项目地址.git。 安装hexo及各类插件。 本地安装调试。 Hexo部署脚本Hexo修改后利用deploy.sh脚本一键部署，提高部署效率。123456789101112131415161718192021#!/bin/bashDIR=`dirname $0`# Generate bloghexo cleanhexo generatesleep 5# Deployhexo deploysleep 5# Push hexo codegit add .current_date=`date "+%Y-%m-%d %H:%M:%S"`git commit -m "Blog updated: $current_date"sleep 2git push origin hexoecho "=====&gt;Finish!&lt;=====" 把该脚本存放至 hexo根目录中，并附加脚本执行权限:1chmod 775 deploy.sh 在hexo目录根执行脚本:1./deploy.sh 可一键部署博客及备份博客源码至github的分支hexoCode上。 提升你的博客更多提升NexT主题的方法请参考以下网页。 Hexo高阶教程：打造定制化博客 让你的hexo博客在搜索引擎中排第一 结束小语本文采用Github + Hexo搭建的个人博客，在搭建过程优化总结，及时记录，希望对各位有所帮助！本文如有错误，欢迎在 Github 的issue中提出，非常感谢！！！ 更多详情请参考： Hexo官网 NexT主题 Hexo插件 Markdown]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Chloneda]]></title>
    <url>%2F%2Fblog%2Fhello-chloneda%2F</url>
    <content type="text"><![CDATA[Welcome to chloneda‘s blog!This is my very first post.You can check the Hexo official website and the Markdown website for related commands and syntax. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartOther reference website NexT 比特虫 Font Awesome Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中FTP安装配置及基本概念]]></title>
    <url>%2F%2Fblog%2Fftp%2F</url>
    <content type="text"><![CDATA[注：本文出自博主：chloneda 安装用apt-get工具安装vsftpd1$ sudo apt-get install vsftpd 检查FTP端口是否已经打开1$ netstat -tnl 或 ps -ef | grep ftp 检查FTP服务是否开启1$ service vsftpd status 如果FTP服务已经开启，则会显示如下信息，由Active关键词可知FTP服务正在运行FTP启动、停止、重启、查看状态的三种方式。123$ service vsftpd start|stop|restart|status$ systemctl start|stop|restart|status vsftpd$ /etc/init.d/vsftpd start|stop|restart|status|reload reload为重新加载配置文件 配置修改FTP配置文件1$ sudo vi /etc/vsftpd.conf FTP主要配置主要配置说明：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 设置登录FTP欢迎信息ftpd_banner=Welcome to CHL FTP service. # 基本配置1listen=YES # 服务器监听local_enable=YES # 是否允许本地用户访问write_enable=YES # 是否允许上传文件，不开启会报 550 permission deniedanonymous_enable=NO # 匿名访问允许，默认不要开启anon_upload_enable=YES # 匿名上传允许，默认是NOanon_mkdir_write_enable=YES # 匿名创建文件夹允许 # 基本配置2local_umask=022 # FTP上本地的文件权限，默认是077。此时umask为022，则目录为777-022=755，文件为666-022=644。dirmessage_enable=YES # 进入文件夹允许 connect_from_port_20=YES # 启用20号端口作为数据传送的端口 data_connection_timeout=120 # 设置数据连接超时时间# 日志配置utf8_filesystem=YES # vsftpd使用utf8文件系统use_localtime=YESxferlog_enable=YES # 激活上传和下传的日志 xferlog_file=/var/log/vsftpd.log # 设定系统维护记录FTP服务器上传和下载情况的日志文件xferlog_std_format=YES # 使用标准的日志格式 # 自定义local_root=/share/vsftpd # 设置自定义的ftp根目录的位置# 读写权限allow_writeable_chroot=YES # 解决"500 OOPS: vsftpd: refusing to run with writable root inside chroot()" 问题write_enable=YES # 允许向FTP服务器写入权限chown_uploads=YES # 设定是否允许改变上传文件的属主，与下面一个设定项配合使用chown_username=whoever # 设置想要改变的上传文件的属主，可设为ftpascii_upload_enable=YES # 允许服务器以ASCII方式传输数据,但引起"SIZE /big/file"方式的DoS攻击ascii_download_enable=YESdeny_email_enable=YES # 黑名单设置。如果很讨厌某些email address，可以取消他的登录权限banned_email_file=/etc/vsftpd.banned_emails# FTP限制最大连接数和传输速率，进行资源控制，避免负担过大而运行异常max_client=50 # FTP服务器的所有客户端最大连接数不超过50个max_per_ip=5 # 同一IP地址的FTP客户机与FTP服务器建立的最大连接数不超过5个local_max_rate=100000 # FTP服务器的本地用户最大传输速率设置为100KB/s.anon_max_rate=50000 # FTP服务器的匿名用户最大传输速率设置为50KB/s.# 权限设置#是否启动userlist为禁止模式，YES表示在userlist中的用户禁止登录ftp（黑名单），NO表示黑名单失效userlist_deny=NOuserlist_enable=NO # 是否启动限制用户的名单为允许模式，上面的YES限制了所有用户，可以用这个名单作为白名单，作为例外允许访问ftp根目录以外userlist_file=/etc/vsftpd.user_list# 在默认配置下，本地用户登入FTP后可以使用cd命令切换到其他目录，这样会对系统带来安全隐患,可配置如下chroot_list_enable=YES # 设置是否启用chroot_list_file配置项指定的用户列表文件。默认值为NO。chroot_local_user=YES # 用于指定用户列表文件中的用户是否允许切换到上级目录。默认值为NO。chroot_list_file=/etc/vsftpd.chroot_list # 禁用名单，用于指定用户列表，该文件用于控制哪些用户可以切换到home目录的上级目录。 通过搭配能实现以下几种效果 当chroot_list_enable=YES，chroot_local_user=YES时，在/etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录；未在文件中列出的用户，不能切换到其他目录。 当chroot_list_enable=YES，chroot_local_user=NO时，在/etc/vsftpd.chroot_list文件中列出的用户，不能切换到其他目录；未在文件中列出的用户，可以切换到其他目录。 当chroot_list_enable=NO，chroot_local_user=YES时，所有的用户均不能切换到其他目录。 当chroot_list_enable=NO，chroot_local_user=NO时，所有的用户均可以切换到其他目录。 配置正确后可浏览器或终端输入以下信息访问123ftp://服务器IP # 浏览器方式访问$ ftp 服务器IP # 终端方式访问 也可以通过浏览器这样访问。1ftp://用户名:密码@IP/具体FTP路径 # 如:ftp://vsftpd:vsftpd@192.167.2.20/chl 修改默认端口默认FTP服务器端口号是21，出于安全目的，有时需修改默认端口号，编辑/etc/vsftpd.conf文件。1listen_port=6666 重新指定了FTP服务器的端口号，需重启服务使配置生效,并利用终端访问。12$ /etc/init.d/vsftpd restart$ ftp 服务器IP 6666 注：端口号需正确，否则连接失败。 设置FTP目录创建FTP根目录，需与配置文件一致。1$ mkdir -p /share/vsftpd 创建FTP用户1$ sudo useradd -g vsftpd -d /share/vsftpd -m test 命令参数说明： g：用户所在的组 d：指定FTP目录 m：不建立默认家目录 设置FTP用户密码1$ sudo passwd vsftpd 编辑/etc/vsftpd.chroot_list文件，将vsftpd的帐户名添加进去，保存退出,并重启FTP服务。 卸载当我们不需要FTP时，可以卸载FTP并删除FTP用户。1$ sudo apt-get remove --purge vsftpd # purge 选项表示彻底删除改软件和相关文件 删除FTP用户1$ sudo userdel vsftpd 常用命令路径切换FTP可以定位服务器与本地硬盘的路径。其中使用 lcd 命令切换宿主机本地路径，命令如下：1$ lcd 目录名 # 进入宿主机目录 而用 cd 命令切换远程服务器的路径,命令如下:1$ cd 目录名 # 进入FTP服务器目录 说到这里，得说说 ! 命令的作用，在FTP中!会执行宿主机shell命令，如:12$ !cmd [args] # 在宿主机中执行交互shell，exit回到FTP环境,例：$ !dir 或 !ls 或如果不加!,显示FTP服务器当前目录内容,如：1$ dir 或 ls 此外，ftp命令支持”含有空格”的文件夹/文件名，即在引用时加上双引号””。 下载文件 get:一次只下载一个文件。 mget:一次可以下载多个文件，而且支持通配符。 上传文件 send: 上传一个文件。 put：上传一个文件。 mput: 上传多个文件。 其他命令其实FTP命令的核心就是善用 help 或 ? 查看具体命令的含义，例如：1ftp&gt; help 或 ? 可利用 ? [cmd] 或 help [cmd] 查看具体命令含义，如图。 有时侯我们会对多个文件进行操作，此时需要对每一个文件都选择y/n，挺麻烦的！可用prompt命令关掉交互方式。12prompt off # 关闭prompt on # 打开 其他信息FTP 数字代码的意义 参考资料vsftpd最详细的配置文件]]></content>
      <categories>
        <category>FTP</category>
      </categories>
      <tags>
        <tag>FTP</tag>
      </tags>
  </entry>
</search>
