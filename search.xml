<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[pom.xml配置文件详解(Maven)！]]></title>
    <url>%2F%2Fblog%2Fmaven-pom%2F</url>
    <content type="text"><![CDATA[注：本文转载自：https://blog.csdn.net/u012152619/article/details/51485297 注：博主 Chloneda：个人博客 | 博客园 | Github | Gitee | 知乎 最近打算对Maven的pom.xml文件进行一下深入研究，做一下总结，惊喜的是网上已经有比较详细的资料，为避免重复造轮子，所以转载了这篇文章。 前言setting.xml主要用于配置maven的运行环境等一系列通用的属性，是全局级别的配置文件；而pom.xml主要描述了项目的maven坐标，依赖关系，开发者需要遵循的规则，缺陷管理系统，组织和licenses，以及其他所有的项目相关因素，是项目级别的配置文件。 基础配置一个典型的pom.xml文件配置如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!-- 模型版本。maven2.0必须是这样写，现在是maven2唯一支持的版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.winner.trade，maven会将该项目打成的jar包放本地路径：/com/winner/trade --&gt; &lt;groupId&gt;com.winner.trade&lt;/groupId&gt; &lt;!-- 本项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt; &lt;artifactId&gt;trade-core&lt;/artifactId&gt; &lt;!-- 本项目目前所处的版本号 --&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- 打包的机制，如pom,jar, maven-plugin, ejb, war, ear, rar, par，默认为jar --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- 帮助定义构件输出的一些附属构件,附属构件与主构件对应，有时候需要加上classifier才能唯一的确定该构件 不能直接定义项目的classifer,因为附属构件不是项目直接默认生成的，而是由附加的插件帮助生成的 --&gt; &lt;classifier&gt;...&lt;/classifier&gt; &lt;!-- 定义本项目的依赖关系 --&gt; &lt;dependencies&gt; &lt;!-- 每个dependency都对应这一个jar包 --&gt; &lt;dependency&gt; &lt;!--一般情况下，maven是通过groupId、artifactId、version这三个元素值（俗称坐标）来检索该构件， 然后引入你的工程。如果别人想引用你现在开发的这个项目（前提是已开发完毕并发布到了远程仓库），--&gt; &lt;!--就需要在他的pom文件中新建一个dependency节点，将本项目的groupId、artifactId、version写入， maven就会把你上传的jar包下载到他的本地 --&gt; &lt;groupId&gt;com.winner.trade&lt;/groupId&gt; &lt;artifactId&gt;trade-test&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- maven认为，程序对外部的依赖会随着程序的所处阶段和应用场景而变化，所以maven中的依赖关系有作用域(scope)的限制。 --&gt; &lt;!--scope包含如下的取值：compile（编译范围）、provided（已提供范围）、runtime（运行时范围）、test（测试范围）、system（系统范围） --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 设置指依赖是否可选，默认为false,即子项目默认都继承:为true,则子项目必需显示的引入，与dependencyManagement里定义的依赖类似 --&gt; &lt;optional&gt;false&lt;/optional&gt; &lt;!-- 屏蔽依赖关系。 比如项目中使用的libA依赖某个库的1.0版，libB依赖某个库的2.0版，现在想统一使用2.0版，就应该屏蔽掉对1.0版的依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 为pom定义一些常量，在pom中的其它地方可以直接引用 使用方式 如下 ：$&#123;file.encoding&#125; --&gt; &lt;properties&gt; &lt;file.encoding&gt;UTF-8&lt;/file.encoding&gt; &lt;java.source.version&gt;1.5&lt;/java.source.version&gt; &lt;java.target.version&gt;1.5&lt;/java.target.version&gt; &lt;/properties&gt; ...&lt;/project&gt; 一般来说，上面的几个配置项对任何项目都是必不可少的，定义了项目的基本属性。 这里有必要对一个不太常用的属性classifier做一下解释，因为有时候引用某个jar包，classifier不写的话会报错。 classifier元素用来帮助定义构件输出的一些附属构件。附属构件与主构件对应，比如主构件是 kimi-app-2.0.0.jar，该项目可能还会通过使用一些插件生成 如kimi-app-2.0.0-javadoc.jar （Java文档）、 kimi-app-2.0.0-sources.jar（Java源代码） 这样两个附属构件。这时候，javadoc、sources就是这两个附属构件的classifier，这样附属构件也就拥有了自己唯一的坐标。 classifier的用途 maven download javadoc / sources jar包的时候，需要借助classifier指明要下载那个附属构件 引入依赖的时候，有时候仅凭groupId、artifactId、version无法唯一的确定某个构件，需要借助classifier来进一步明确目标。比如JSON-lib，有时候会同一个版本会提供多个jar包，在JDK1.5环境下是一套，在JDK1.3环境下是一套： 引用它的时候就要注明JDK版本，否则maven不知道你到底需要哪一套jar包：123456&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt;&lt;/dependency&gt; 构建配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;build&gt; &lt;!-- 产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt; &lt;finalName&gt;myPorjectName&lt;/finalName&gt; &lt;!-- 构建产生的所有文件存放的目录,默认为$&#123;basedir&#125;/target，即项目根目录下的target --&gt; &lt;directory&gt;$&#123;basedir&#125;/target&lt;/directory&gt; &lt;!--当项目没有规定目标（Maven2叫做阶段（phase））时的默认值， --&gt; &lt;!--必须跟命令行上的参数相同例如jar:jar，或者与某个阶段（phase）相同例如install、compile等 --&gt; &lt;defaultGoal&gt;install&lt;/defaultGoal&gt; &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表。 --&gt; &lt;!--项目配置信息中诸如$&#123;spring.version&#125;之类的占位符会被属性文件中的实际值替换掉 --&gt; &lt;filters&gt; &lt;filter&gt;../filter.properties&lt;/filter&gt; &lt;/filters&gt; &lt;!--项目相关的所有资源路径列表，例如和项目相关的配置文件、属性文件，这些资源被包含在最终的打包文件里。 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;!--描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。 --&gt; &lt;!--举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven/messages。 --&gt; &lt;!--然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt; &lt;targetPath&gt;resources&lt;/targetPath&gt; &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;!--描述存放资源的目录，该路径相对POM路径 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!--包含的模式列表 --&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;!--排除的模式列表 如果&lt;include&gt;与&lt;exclude&gt;划定的范围存在冲突，以&lt;exclude&gt;为准 --&gt; &lt;excludes&gt; &lt;exclude&gt;jdbc.properties&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--单元测试相关的所有资源路径，配制方法与resources类似 --&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!--项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;sourceDirectory&gt;$&#123;basedir&#125;\src\main\java&lt;/sourceDirectory&gt; &lt;!--项目脚本源码目录，该目录和源码目录不同， &lt;!-- 绝大多数情况下，该目录下的内容会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt; &lt;scriptSourceDirectory&gt;$&#123;basedir&#125;\src\main\scripts &lt;/scriptSourceDirectory&gt; &lt;!--项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;testSourceDirectory&gt;$&#123;basedir&#125;\src\test\java&lt;/testSourceDirectory&gt; &lt;!--被编译过的应用程序class文件存放的目录。 --&gt; &lt;outputDirectory&gt;$&#123;basedir&#125;\target\classes&lt;/outputDirectory&gt; &lt;!--被编译过的测试class文件存放的目录。 --&gt; &lt;testOutputDirectory&gt; $&#123;basedir&#125;\target\test-classes &lt;/testOutputDirectory&gt; &lt;!--项目的一系列构建扩展,它们是一系列build过程中要使用的产品，会包含在running bulid‘s classpath里面。 --&gt; &lt;!--他们可以开启extensions，也可以通过提供条件来激活plugins。 --&gt; &lt;!--简单来讲，extensions是在build过程被激活的产品 --&gt; &lt;extensions&gt; &lt;!--例如，通常情况下，程序开发完成后部署到线上Linux服务器，可能需要经历打包、 --&gt; &lt;!--将包文件传到服务器、SSH连上服务器、敲命令启动程序等一系列繁琐的步骤。 --&gt; &lt;!--实际上这些步骤都可以通过Maven的一个插件 wagon-maven-plugin 来自动完成 --&gt; &lt;!--下面的扩展插件wagon-ssh用于通过SSH的方式连接远程服务器， --&gt; &lt;!--类似的还有支持ftp方式的wagon-ftp插件 --&gt; &lt;extension&gt; &lt;groupId&gt;org.apache.maven.wagon&lt;/groupId&gt; &lt;artifactId&gt;wagon-ssh&lt;/artifactId&gt; &lt;version&gt;2.8&lt;/version&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;!--使用的插件列表 。 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.5&lt;/version&gt; &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt; &lt;executions&gt; &lt;execution&gt; &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt; &lt;id&gt;assembly&lt;/id&gt; &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;!--配置的执行目标 --&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;!--配置是否被传播到子POM --&gt; &lt;inherited&gt;false&lt;/inherited&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!--作为DOM对象的配置,配置项因插件而异 --&gt; &lt;configuration&gt; &lt;finalName&gt;$&#123;finalName&#125;&lt;/finalName&gt; &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt; &lt;descriptor&gt;assembly.xml&lt;/descriptor&gt; &lt;/configuration&gt; &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器）， --&gt; &lt;!--由于性能原因，只有在真需要下载时，该元素才被设置成true。 --&gt; &lt;extensions&gt;false&lt;/extensions&gt; &lt;!--项目引入插件所需要的额外依赖 --&gt; &lt;dependencies&gt; &lt;dependency&gt;...&lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--任何配置是否被传播到子项目 --&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!--主要定义插件的共同元素、扩展元素集合，类似于dependencyManagement， --&gt; &lt;!--所有继承于此项目的子项目都能使用。该插件配置项直到被引用时才会被解析或绑定到生命周期。 --&gt; &lt;!--给定插件的任何本地配置都会覆盖这里的配置 --&gt; &lt;pluginManagement&gt; &lt;plugins&gt;...&lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; pom里面的仓库与setting.xml里的仓库功能是一样的。主要的区别在于，pom里的仓库是个性化的。比如一家大公司里的setting文件是公用的，所有项目都用一个setting文件，但各个子项目却会引用不同的第三方库，所以就需要在pom里设置自己需要的仓库地址。 分发配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。 --&gt;&lt;!--有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;&lt;distributionManagement&gt; &lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt; &lt;repository&gt; &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号），还是每次都使用相同的版本号 --&gt; &lt;!--参见repositories/repository元素 --&gt; &lt;uniqueVersion&gt;true&lt;/uniqueVersion&gt; &lt;id&gt; repo-id &lt;/id&gt; &lt;name&gt; repo-name&lt;/name&gt; &lt;url&gt;file://$&#123;basedir&#125;/target/deploy &lt;/url&gt; &lt;layout /&gt; &lt;/repository&gt; &lt;!--构件的快照部署到哪里,如果没有配置该元素，默认部署到repository元素配置的仓库 --&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion /&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/snapshotRepository&gt; &lt;!--部署项目的网站需要的信息 --&gt; &lt;site&gt; &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt; &lt;id&gt; site-id &lt;/id&gt; &lt;!--部署位置的名称 --&gt; &lt;name&gt; site-name&lt;/name&gt; &lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web &lt;/url&gt; &lt;/site&gt; &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。 --&gt; &lt;!--使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt; &lt;downloadUrl /&gt; &lt;!--如果构件有了新的groupID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt; &lt;relocation&gt; &lt;!--构件新的group ID --&gt; &lt;groupId /&gt; &lt;!--构件新的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--构件新的版本号 --&gt; &lt;version /&gt; &lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt; &lt;message /&gt; &lt;/relocation&gt; &lt;!--给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。 --&gt; &lt;!--有效的值有：none（默认），converted（仓库管理员从Maven 1 POM转换过来）， --&gt; &lt;!--partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。 --&gt; &lt;status /&gt; &lt;/distributionManagement&gt; 仓库配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;&lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!--如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled /&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。 --&gt; &lt;!--这里的选项是：always（一直），daily（默认，每日）， --&gt; &lt;!--interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy /&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做： --&gt; &lt;!--ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置， --&gt; &lt;!--POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。 --&gt; &lt;!--例如，可能有人会决定只为开发目的开启对快照版本下载的支持 --&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt; &lt;id&gt; repo-id &lt;/id&gt; &lt;!--远程仓库名称 --&gt; &lt;name&gt; repo-name&lt;/name&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;http://192.168.1.169:9999/repository/ &lt;/url&gt; &lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。 --&gt; &lt;!--Maven 2为其仓库提供了一个默认的布局； --&gt; &lt;!--然而，Maven1.x有一种不同的布局。 --&gt; &lt;!--我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt; default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;&lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository /&gt; &lt;/pluginRepositories&gt; profile配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt;&lt;profiles&gt; &lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt; &lt;profile&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。 --&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标识 --&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;!--activation有一个内建的java版本检测，如果检测到jdk版本与期待的一样，profile被激活。 --&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字 --&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 'windows') --&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本 --&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。 --&gt; &lt;!-- 如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt; &lt;property&gt; &lt;!--激活profile的属性的名称 --&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值 --&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。 --&gt; &lt;!--另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。 --&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。 --&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;id /&gt; &lt;build /&gt; &lt;modules /&gt; &lt;repositories /&gt; &lt;pluginRepositories /&gt; &lt;dependencies /&gt; &lt;reporting /&gt; &lt;dependencyManagement /&gt; &lt;distributionManagement /&gt; &lt;properties /&gt; &lt;/profile&gt; profile配置项在setting.xml中也有，是pom.xml中profile元素的裁剪版本，包含了id，activation, repositories, pluginRepositories和 properties元素。这里的profile元素只包含这五个子元素是因为setting.xml只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。如果一个settings中的profile被激活，它的值会覆盖任何其它定义在POM中或者profile.xml中的带有相同id的profile。 pom.xml中的profile可以看做pom.xml的副本，拥有与pom.xml相同的子元素与配置方法。它包含可选的activation（profile的触发器）和一系列的changes。例如test过程可能会指向不同的数据库（相对最终的deployment）或者不同的dependencies或者不同的repositories，并且是根据不同的JDK来改变的。只需要其中一个成立就可以激活profile，如果第一个条件满足了，那么后面就不会在进行匹配。 报表配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!--描述使用报表插件产生报表的规范,特定的maven 插件能输出相应的定制和配置报表. --&gt;&lt;!--当用户执行“mvn site”，这些报表就会运行,在页面导航栏能看到所有报表的链接。 --&gt;&lt;reporting&gt; &lt;!--true，则网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --&gt; &lt;excludeDefaults /&gt; &lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt; &lt;outputDirectory /&gt; &lt;!--使用的报表插件和他们的配置。 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;inherited /&gt; &lt;configuration&gt; &lt;links&gt; &lt;link&gt;http://java.sun.com/j2se/1.5.0/docs/api/&lt;/link&gt; &lt;/links&gt; &lt;/configuration&gt; &lt;!--一组报表的多重规范，每个规范可能有不同的配置。 --&gt; &lt;!--一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。 --&gt; &lt;!--1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt; &lt;reportSets&gt; &lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt; &lt;reportSet&gt; &lt;!--报表集合的唯一标识符，POM继承时用到 --&gt; &lt;id&gt;sunlink&lt;/id&gt; &lt;!--产生报表集合时，被使用的报表的配置 --&gt; &lt;configuration /&gt; &lt;!--配置是否被继承到子POMs --&gt; &lt;inherited /&gt; &lt;!--这个集合里使用到哪些报表 --&gt; &lt;reports&gt; &lt;report&gt;javadoc&lt;/report&gt; &lt;/reports&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt; 环境配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;&lt;issueManagement&gt; &lt;!--问题管理系统（例如jira）的名字， --&gt; &lt;system&gt; jira &lt;/system&gt; &lt;!--该项目使用的问题管理系统的URL --&gt; &lt;url&gt; http://jira.clf.com/&lt;/url&gt; &lt;/issueManagement&gt; &lt;!--项目持续集成信息 --&gt;&lt;ciManagement&gt; &lt;!--持续集成系统的名字，例如continuum --&gt; &lt;system /&gt; &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt; &lt;url /&gt; &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt; &lt;notifiers&gt; &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt; &lt;notifier&gt; &lt;!--传送通知的途径 --&gt; &lt;type /&gt; &lt;!--发生错误时是否通知 --&gt; &lt;sendOnError /&gt; &lt;!--构建失败时是否通知 --&gt; &lt;sendOnFailure /&gt; &lt;!--构建成功时是否通知 --&gt; &lt;sendOnSuccess /&gt; &lt;!--发生警告时是否通知 --&gt; &lt;sendOnWarning /&gt; &lt;!--不赞成使用。通知发送到哪里 --&gt; &lt;address /&gt; &lt;!--扩展配置项 --&gt; &lt;configuration /&gt; &lt;/notifier&gt; &lt;/notifiers&gt; &lt;/ciManagement&gt; 项目信息配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157&lt;!--项目的名称, Maven产生的文档用 --&gt;&lt;name&gt;banseon-maven &lt;/name&gt; &lt;!--项目主页的URL, Maven产生的文档用 --&gt;&lt;url&gt;http://www.clf.com/ &lt;/url&gt; &lt;!--项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时 --&gt;&lt;!--（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标签），不鼓励使用纯文本描述。 --&gt;&lt;!-- 如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;&lt;description&gt;A maven project to study maven. &lt;/description&gt; &lt;!--描述了这个项目构建环境中的前提条件。 --&gt;&lt;prerequisites&gt; &lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt; &lt;maven /&gt; &lt;/prerequisites&gt; &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;&lt;inceptionYear /&gt; &lt;!--项目相关邮件列表信息 --&gt;&lt;mailingLists&gt; &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt; &lt;mailingList&gt; &lt;!--邮件的名称 --&gt; &lt;name&gt; Demo &lt;/name&gt; &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;post&gt; clf@126.com&lt;/post&gt; &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;subscribe&gt; clf@126.com&lt;/subscribe&gt; &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;unsubscribe&gt; clf@126.com&lt;/unsubscribe&gt; &lt;!--你可以浏览邮件信息的URL --&gt; &lt;archive&gt; http:/hi.clf.com/&lt;/archive&gt; &lt;/mailingList&gt; &lt;/mailingLists&gt; &lt;!--项目开发者列表 --&gt;&lt;developers&gt; &lt;!--某个项目开发者的信息 --&gt; &lt;developer&gt; &lt;!--SCM里项目开发者的唯一标识符 --&gt; &lt;id&gt; HELLO WORLD &lt;/id&gt; &lt;!--项目开发者的全名 --&gt; &lt;name&gt; banseon &lt;/name&gt; &lt;!--项目开发者的email --&gt; &lt;email&gt; banseon@126.com&lt;/email&gt; &lt;!--项目开发者的主页的URL --&gt; &lt;url /&gt; &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt; &lt;roles&gt; &lt;role&gt; Project Manager&lt;/role&gt; &lt;role&gt;Architect &lt;/role&gt; &lt;/roles&gt; &lt;!--项目开发者所属组织 --&gt; &lt;organization&gt; demo&lt;/organization&gt; &lt;!--项目开发者所属组织的URL --&gt; &lt;organizationUrl&gt;http://hi.clf.com/ &lt;/organizationUrl&gt; &lt;!--项目开发者属性，如即时消息如何处理等 --&gt; &lt;properties&gt; &lt;dept&gt; No &lt;/dept&gt; &lt;/properties&gt; &lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt; &lt;timezone&gt; -5&lt;/timezone&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;!--项目的其他贡献者列表 --&gt;&lt;contributors&gt; &lt;!--项目的其他贡献者。参见developers/developer元素 --&gt; &lt;contributor&gt; &lt;name /&gt; &lt;email /&gt; &lt;url /&gt; &lt;organization /&gt; &lt;organizationUrl /&gt; &lt;roles /&gt; &lt;timezone /&gt; &lt;properties /&gt; &lt;/contributor&gt; &lt;/contributors&gt; &lt;!--该元素描述了项目所有License列表。应该只列出该项目的license列表，不要列出依赖项目的license列表。 --&gt;&lt;!--如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;&lt;licenses&gt; &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt; &lt;license&gt; &lt;!--license用于法律上的名称 --&gt; &lt;name&gt; Apache 2 &lt;/name&gt; &lt;!--官方的license正文页面的URL --&gt; &lt;url&gt;http://www.clf.com/LICENSE-2.0.txt &lt;/url&gt; &lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt; &lt;distribution&gt; repo&lt;/distribution&gt; &lt;!--关于license的补充信息 --&gt; &lt;comments&gt; Abusiness-friendly OSS license &lt;/comments&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;&lt;scm&gt; &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt; &lt;connection&gt;scm:svn:http://svn.baidu.com/banseon/maven/&lt;/connection&gt; &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt; &lt;developerConnection&gt;scm:svn:http://svn.baidu.com/banseon/maven/ &lt;/developerConnection&gt; &lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt; &lt;tag /&gt; &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt; &lt;url&gt; http://svn.baidu.com/banseon&lt;/url&gt; &lt;/scm&gt; &lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;&lt;organization&gt; &lt;!--组织的全名 --&gt; &lt;name&gt; demo &lt;/name&gt; &lt;!--组织主页的URL --&gt; &lt;url&gt; http://www.clf.com/&lt;/url&gt; &lt;/organization&gt; Maven POM]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java:如何优雅地使用close()?]]></title>
    <url>%2F%2Fblog%2Fjava-close%2F</url>
    <content type="text"><![CDATA[注：本文出自博主 Chloneda：个人博客 | 博客园 | Github | Gitee | 知乎 前言本文尽量采用通俗易懂、循序渐进的方式，让大家真正优雅地使用close()方法！ 问题场景平时我们使用资源后一般都会关闭资源，即close()方法，但这个步骤重复性很高，还面临上述执行顺序不明的风险，而且很多人还是不能正确合理地关闭资源。 我们来看看close()是怎么错误地关闭资源的？ 错误的close()先来看看如下的错误关闭资源方式： 1234567891011121314151617181920212223242526272829303132333435package com.chloneda.jutils.test;import java.sql.*;/** * @author chloneda * @description: close()方法测试 * 错误的close() */public class CloseTest &#123; public static void main(String[] args) &#123; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; //1.加载驱动程序 Class.forName("com.mysql.jdbc.Driver"); //2.获得数据库链接 conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/common", "root", "123456"); //3.通过数据库的连接操作数据库，实现增删改查 st = conn.createStatement(); rs = st.executeQuery("select * from new_table"); //4.处理数据库的返回结果 while (rs.next()) &#123; System.out.println(rs.getString("id") + " " + rs.getString("name")); &#125; //5.关闭资源 rs.close(); st.close(); conn.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上面代码的资源关闭写在了try代码块中，一旦close方法调用之前(比如3步骤)就抛出异常，那么关闭资源的代码就永远不会得到执行。 如果我们把关闭资源的代码放在finally中行不行呢？123456789101112131415161718192021222324try &#123; //1.加载驱动程序 Class.forName("com.mysql.jdbc.Driver"); //2.获得数据库链接 conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/common", "root", "123456"); //3.通过数据库的连接操作数据库，实现增删改查 st = conn.createStatement(); rs = st.executeQuery("select * from new_table"); //4.处理数据库的返回结果 while (rs.next()) &#123; System.out.println(rs.getString("id") + " " + rs.getString("name")); &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125; finally &#123; //5.关闭资源 try &#123; rs.close(); st.close(); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 答案是不行！如果在 2步骤 的try中conn获得数据库链接抛出异常，那么conn仍然为null，此时进入finally代码块中，执行close()就报空指针异常了，关闭资源没有意义！因此，我们需要在close()之前判断一下conn等是否为空，只有不为空的时候才需要close。 常见的close()针对上述场景，得到常见的使用close()方式如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @author chloneda * @description: close()方法测试 * 常见的close() */public class CloseTest &#123; public static void main(String[] args) &#123; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; //1.加载驱动程序 Class.forName("com.mysql.jdbc.Driver"); //2.获得数据库链接 conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/common", "root", "123456"); //3.通过数据库的连接操作数据库，实现增删改查 st = conn.createStatement(); rs = st.executeQuery("select * from new_table"); //4.处理数据库的返回结果 while (rs.next()) &#123; System.out.println(rs.getString("id") + " " + rs.getString("name")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //5.关闭资源 if (null != rs) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (null != st) &#123; try &#123; st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (null != conn) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 这是常见的close()！但是finally代码块的代码重复性太高了，这还只是三个资源的关闭，如果有很多个资源需要在finally中关闭，那不是需要编写很多不优雅的代码？其实，关闭资源是没啥逻辑的代码，我们需要精简代码，减少代码重复性，优雅地编程！ 使用AutoCloseable接口自从Java7以后，我们可以使用 AutoCloseable接口 (Closeable接口也可以)来优雅的关闭资源了 看看修改例子：123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author chloneda * @description: close()方法测试 * 使用AutoCloseable接口 */public class CloseTest &#123; public static void main(String[] args) &#123; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; //1.加载驱动程序 Class.forName("com.mysql.jdbc.Driver"); //2.获得数据库链接 conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/common", "root", "123456"); //3.通过数据库的连接操作数据库，实现增删改查 st = conn.createStatement(); rs = st.executeQuery("select * from new_table"); //4.处理数据库的返回结果 while (rs.next()) &#123; System.out.println(rs.getString("id") + " " + rs.getString("name")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //5.关闭资源，调用自定义的close()方法 close(rs); close(st); close(conn); &#125; &#125; public static void close(AutoCloseable closeable) &#123; if (closeable != null) &#123; try &#123; closeable.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上面的finally代码块的代码量是不是减少了许多，就单纯地调用的静态的 close(AutoCloseable closeable) 方法。为什么可以这样呢？ 其实Connection、Statement、ResultSet三个接口都继承了AutoCloseable接口。所以只要涉及到资源的关闭，继承了AutoCloseable接口，实现了close()方法，我们都可以调用 close(AutoCloseable closeable) 方法进行资源关闭。 此外，java IO流的很多类都实现了 Closeable接口，而Closeable接口又继承自 AutoCloseable接口，也可以调用上面的 close(AutoCloseable closeable) 方法进行资源关闭。是不是一语惊醒梦中人啊？ 使用try-with-resources其实Java7以后，还有一种关闭资源的方式，也就是 try-with-resources，这种方式也是我们推荐的！很优雅！ 我们来看看它是怎么优雅地关闭资源的！123456789101112131415161718192021222324/** * @author chloneda * @description: close()方法测试 * 使用try-with-resources */public class CloseTest &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //1.加载驱动程序 Class.forName("com.mysql.jdbc.Driver"); try (//2.获得数据库链接 Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/common", "root", "123456"); //3.通过数据库的连接操作数据库，实现增删改查 Statement st = conn.createStatement(); ResultSet rs = st.executeQuery("select * from new_table") ) &#123; //4.处理数据库的返回结果 while (rs.next()) &#123; System.out.println(rs.getString("id") + " " + rs.getString("name")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这种方式就省略了finally，不必重复编写关闭资源的代码了！而且资源也得到了关闭！怎么验证这个问题？可以查看底下的 实际应用 章节！ 其实try-with-resources关闭资源的操作，本质上是继承了java.lang.AutoCloseable接口，实现了close方法，所以使用try-with-resources能关闭资源。很神奇吧！ 实际应用这个章节就是验证使用try-with-resources可以关闭资源的问题的！ 上面我们说了使用try-with-resources关闭资源，只要是继承了java.lang.AutoCloseable接口 实现close()方法就可以使用！ 我们自定义一个资源类，来看看实际应用吧！12345678910111213141516171819202122232425262728293031323334package com.chloneda.jutils.test;/** * @author chloneda * @description: 资源类, 实现AutoCloseable接口. */public class Resources implements AutoCloseable &#123; public void useResource() &#123; System.out.println("useResource:&#123;&#125; 正在使用资源!"); &#125; @Override public void close() &#123; System.out.println("close:&#123;&#125; 自动关闭资源!"); &#125;&#125;/** * @description: 使用try-with-resources自动关闭资源测试. */class AutoClosableTest &#123; public static void main(String[] args) &#123; /** 使用try-with-resource，自动关闭资源 */ try ( Resources resource = new Resources() ) &#123; resource.useResource(); &#125; catch (Exception e) &#123; e.getMessage(); &#125; finally &#123; System.out.println("Finally!"); &#125; &#125;&#125; 结果输出。123useResource:&#123;&#125; 正在使用资源!close:&#123;&#125; 自动关闭资源!Finally! 看到运行结果了吗？Resources类实现AutoCloseable接口，实现了close()方法，try-with-resources 就会自动关闭资源！ 一旦Resources类没有继承java.lang.AutoCloseable接口，没有实现close()方法，AutoClosableTest类的try模块就在编译期报错，提示信息如下。123Incompatible types.Required: java.lang.AutoCloseableFound: com.chloneda.jutils.test.Resources 最后，需要说明的是try-with-resources就是一个JVM语法糖！关于JVM语法糖可以查查相关资料，看看Java中有哪些有趣的语法糖！ 尾语《Effective Java》在第三版中也推荐使用try-with-resources语句替代try-finally语句。 所以在处理必须关闭的资源时，使用try-with-resources语句替代try-finally语句。生成的代码更简洁，更清晰，并且生成的异常更有用。 try-with-resources语句在编写必须关闭资源的代码时会更容易，也不会出错，而使用try-finally语句实际上是不可能的。 如此，推荐大家使用try-with-resources优雅地关闭资源！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出设计模式系列--单例模式]]></title>
    <url>%2F%2Fblog%2Fpattern-singleton%2F</url>
    <content type="text"><![CDATA[注：本文出自博主 Chloneda：个人博客 | 博客园 | Github | Gitee | 知乎 前言深入浅出设计模式系列，尽量采用通俗易懂、循序渐进的方式，让大家真正理解设计模式的精髓！ 先了解一下单例模式定义：确保一个类只有一个自行实例化的实例，并提供一个全局访问点，向整个系统提供这个实例。 单例模式的本质：控制实例的数目。 单例模式的主要问题我们经常使用的单例模式主要涉及的问题有： 如何保证一个类只有一个实例？ 如何保证单例模式在多线程环境下的线程安全？ 如何防止反射对单例模式的破坏？ 如何保证单例模式在序列化与反序列化过程中实例的唯一性？ 下面针对以上的问题进行深入研究！ 单例模式的实现单例模式常见的有饿汉式、懒汉式、双重检验锁、静态内部类方式、枚举方式，这里主要讨论多线程环境下的单例模式。 饿汉式这种饿汉式单例是比较常见的，我们看看它是怎么实现的！ 12345678910111213141516package com.chloneda.jutils.test;/** * @Created by chloneda * @Description: 饿汉式单例模式 */public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 饿汉式单例本身是线程安全的，但它采用空间换取时间的方式，当类加载时马上就实例化Singleton对象，不管使用者用不用，后续每次调用 getInstance() 方法的时候，就不需要判断它是否实例化，从而节约了时间。但有些情况下需要懒加载实例化对象，针对这种情形，于是有了懒汉式的单例模式。 懒汉式我们看一下懒汉式单例模式的实现。 12345678910111213141516171819package com.chloneda.jutils.test;/** * @Created by chloneda * @Description: 懒汉式单例模式 */public class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 这就是我们常见的懒汉式单例模式！大家发现没？这种懒汉式单例模式在多线程环境下，存在线程安全的问题！那它是怎么引发多线程安全的问题的呢？ 为便于大家理解单例模式在多线程环境下容易出现的问题，下面直接采用图片的方式，请看图片： 从上图可知多线程环境下懒汉式单例模式的问题了吧！ 针对上面单例模式存在多线程安全的缺陷，有人说这还不容易解决，直接在 getInstance 方法上加上Java关键词 synchronized， 即。123456public synchronized static Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton;&#125; 可是你可别忘了，在Java中每个语句都是执行都需要时间的，加上 synchronized 关键词需要底层执行更多的语句，并且每次都需要通过 getInstance() 方法获取实例，效率非常底，更别说在多线程高并发下的执行情况了，因此必须对此加以改进。 双重检验锁针对上面懒汉式单例的性能问题，我通过修改得到双重检验锁单例。1234567891011121314151617181920212223package com.chloneda.jutils.test;/** * @Created by chloneda * @Description: 双重检验锁单例模式 */public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; // 双重检测机制 synchronized (Singleton.class) &#123; // 同步锁 if (instance == null) &#123; // 双重检测机制 instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 上面双重检验锁单例的写法，是不是比懒汉式单例效率高，因为每次需要通过 getInstance 方法获取实例时，只在第一次实例化 instance 加同步锁，后续多线程进入该方法后，直接进入外层 if (instance == null) 判断语句，得知instance实例不为空，就直接返回instance实例了。 虽然上面的双重校验锁机制的单例增加了一定的安全性，提高了效率，但是这个双重检验锁单例也有缺陷，因为它没有考虑到 JVM 编译器的指令重排。 1、什么是指令重排比如 java 中简单的一句 instance = new Singleton()，会被编译器编译成如下 JVM 指令。123memory = allocate(); //1：分配对象的内存空间 ctorInstance(memory); //2：初始化对象 instance = memory; //3：设置instance指向刚分配的内存地址 但是这些指令顺序并非一成不变，有可能会经过 JVM 和 CPU 的优化，指令重排成下面的顺序。123memory = allocate(); //1：分配对象的内存空间 instance = memory; //3：设置instance指向刚分配的内存地址 ctorInstance(memory); //2：初始化对象 2、影响 高并发情况下，线程 A 执行 instance = new Singleton(); 完上面的1、3步骤时，准备走2，即 instance 对象还未完成初始化，但此时 instance 已经不再指向 null 。 此时线程 B 抢占到CPU资源，执行 if(instance == null) 时，返回的结果会是 false， 从而返回一个没有初始化完成的instance对象。 3、解决方法如何去解决这个问题呢？很简单，可以利用关键字 volatile 来修饰 instance 对象，如下优化： 双重检验锁改进 1234567891011121314151617181920212223package com.chloneda.jutils.test;/** * @Created by chloneda * @Description: 单例模式使用双重检验锁方式实现，优点：延迟初始化、性能优化、线程安全 */public class Singleton &#123; private volatile static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; volatile 修饰符在此处的作用就是阻止变量访问前后的指令重排，从而保证了指令的执行顺序。 即指令的执行顺序是严格按照上文的 1、2、3 步骤来执行，从而保证对象不会出现中间态。 但是上面的双重检验锁改进版单例模式也有问题，因为它无法解决反射对单例模式的破坏性。我将在静态内部类单例模式中加以阐述。 静态内部类在了解静态内部类单例模式之前，让我们先了解一下静态内部类的两个知识。 静态内部类加载一个类时，其内部类不会同时被加载。 一个类被加载，当且仅当其某个静态成员如静态域、构造器、静态方法等被调用时才会被加载。 我们先看一个静态内部类的测试，以验证上面这两个观点。123456789101112131415161718192021222324252627282930313233package com.chloneda.jutils.test;/** * @Created by chloneda * @Description: 静态内部类测试类 */public class OuterClassTest &#123; private OuterClassTest() &#123;&#125; static &#123; System.out.println("1、我是外部类静态模块..."); &#125; // 静态内部类 private static final class StaticInnerTest &#123; private static OuterClassTest oct = new OuterClassTest(); static &#123; System.out.println("2、我是静态内部类的静态模块... " + oct); &#125; static void staticInnerMethod() &#123; System.out.println("3、静态内部类方法模块... " + oct); &#125; &#125; public static void main(String[] args) &#123; OuterClassTest oct = new OuterClassTest(); // 此刻内部类不会被加载 System.out.println("===========分割线==========="); OuterClassTest.StaticInnerTest.staticInnerMethod(); // 调用内部类的静态方法 &#125;&#125; 输出如下。12341、我是外部类静态模块...=========分割线=========2、我是静态内部类的静态模块... com.chloneda.jutils.test.OuterClassTest@b1bc7ed3、静态内部类的方法模块... com.chloneda.jutils.test.OuterClassTest@b1bc7ed 从运行结果来看，验证是正确的！ 由于静态内部类的特性，只有在其被第一次引用的时候才会被加载，所以可以保证其线程安全性。 由此可得出静态内部类单例模式的写法。 静态内部类12345678910111213141516171819package com.chloneda.jutils.test;/** * @Created by chloneda * @Description: * 单例模式使用静态内部类方式实现，优点：实现代码简洁、延迟初始化、线程安全 */public class Singleton &#123; private static final class SingletonHolder &#123; private static Singleton INSTANCE = new Singleton(); &#125; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return SingletonHolder.INSTANCE; &#125;&#125; 这种写法的单例，外部无法访问静态内部类 SingletonHolder，只有当调用 Singleton.getInstance() 方法的时候，才能得到单例对象 INSTANCE。 而且静态内部类单例的 getInstance() 方法中没有使用 synchronized 关键字，提高了执行效率，同时兼顾了懒汉模式的内存优化（使用时才初始化，节约空间，达到懒加载的目的）以及饿汉模式的安全性。 但这种单例也有问题！这种方式需要两个类去做到这一点，也就是说，虽然懒加载静态内部类的对象，但其 外部类及内部静态类的 Class 对象还是会被创建，同时也无法防止反射对单例的破坏性（很多单例的写法都有这个通病），从而无法保证对象的唯一性。 我们通过以下测试类测试反射对静态内部类的破坏性。 12345678910111213141516171819202122232425/** * @Created by chloneda * @Description: 反射破坏静态内部类单例模式的测试类 */public class SingletonReflectTest &#123; public static void main(String[] args) &#123; //创建第一个实例 Singleton instance1 = Singleton.getInstance(); //通过反射创建第二个实例 Singleton instance2 = null; try &#123; Class&lt;Singleton&gt; clazz = Singleton.class; Constructor&lt;Singleton&gt; cons = clazz.getDeclaredConstructor(); cons.setAccessible(true); instance2 = cons.newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //检查两个实例的hash值 System.out.println("Instance1 hashCode: " + instance1.hashCode()); System.out.println("Instance2 hashCode: " + instance2.hashCode()); &#125;&#125; 输出结果如下。12Instance1 hashCode: 186370029Instance2 hashCode: 2094548358 从输出结果可以看出，通过反射获取构造函数，并调用 setAccessible(true) 就可以调用私有的构造函数，从而得到Instance1和Instance2两个不同的对象。 静态内部类改进 如何防止这种反射对单例的破坏呢？我们可以通过修改构造器，让它在被要求创建第二个实例的时候抛出异常。 静态内部类修改如下。1234567891011121314151617181920212223242526272829package com.chloneda.jutils.test;/** * @Created by chloneda * @Description: 防止反射破坏静态内部类单例模式 */public class Singleton &#123; private static boolean initialized = false; private static final class SingletonHolder &#123; private static Singleton INSTANCE = new Singleton(); &#125; private Singleton() &#123; synchronized (Singleton.class) &#123; if (initialized == false) &#123; initialized = !initialized; &#125; else &#123; throw new RuntimeException("单例模式禁止二次创建，防止反射！"); &#125; &#125; &#125; public static Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 我们还用一个 SingletonReflectTest 测试类测试一下，输出结果如下。123456789101112java.lang.reflect.InvocationTargetException at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:423) at com.chloneda.jutils.test.SingletonReflectTest.main(Singleton.java:46)Caused by: java.lang.RuntimeException: 单例模式禁止二次创建，防止反射！ at com.chloneda.jutils.test.Singleton.&lt;init&gt;(Singleton.java:24) ... 5 moreInstance1 hashCode: 1053782781Exception in thread "main" java.lang.NullPointerException at com.chloneda.jutils.test.SingletonReflectTest.main(Singleton.java:53) 所以我们通过修改构造器防止反射对单例的破坏性。 但是这种方式的单例也存在问题！什么问题呢？即序列化和反序列化之后无法继续保持单例（很多单例的写法也有这个通病）。 我们让上面防止反射破坏静态内部类的单例实现 Serializable 接口。1public class Singleton implements Serializable 并通过以下测试类进行序列化和反序列化测试。123456789101112131415161718192021222324252627/** * @Created by chloneda * @Description: 序列化破坏静态内部类单例模式的测试类 */pubic class SingletonSerializableTest &#123; public static void main(String[] args) &#123; try &#123; Singleton instance1 = Singleton.getInstance(); ObjectOutput out = null; out = new ObjectOutputStream(new FileOutputStream("Singleton.ser")); out.writeObject(instance1); out.close(); //从文件中反序列化一个Singleton对象 ObjectInput in = new ObjectInputStream(new FileInputStream("Singleton.ser")); Singleton instance2 = (Singleton) in.readObject(); in.close(); System.out.println("instance1 hashCode: " + instance1.hashCode()); System.out.println("instance2 hashCode: " + instance2.hashCode()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出结果如下。12instance1 hashCode: 240650537instance2 hashCode: 1566502717 从结果可以看出，很明显不是同一个单例对象！ 那如何解决这个问题呢？ 静态内部类再改进 我们可以实现 readResolve() 方法，它代替了从流中读取对象，确保了在序列化和反序列化的过程中没人可以创建新的实例。 可以得到改进版的静态内部类单例，可以有效防止序列化及反射的破坏！12345678910111213141516171819202122232425262728293031323334package com.chloneda.jutils.test;import java.io.*;/** * @Created by chloneda * @Description: 可以防止序列化及反射破坏的静态内部类单例模式 */public class Singleton implements Serializable &#123; private static boolean initialized = false; private static final class SingletonHolder &#123; private static Singleton INSTANCE = new Singleton(); &#125; private Singleton() &#123; synchronized (Singleton.class) &#123; if (initialized == false) &#123; initialized = !initialized; &#125; else &#123; throw new RuntimeException("单例模式禁止二次创建，防止反射！"); &#125; &#125; &#125; public static Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; private Object readResolve() &#123; return getInstance(); &#125;&#125; 我们再用上面的 SingletonSerializableTest 测试类测试一下结果。 输出结果如下。12instance1 hashCode: 240650537instance2 hashCode: 240650537 此时就说明，单例在序列化和反序列化时的对象是一致的了。 其实上面饿汉式、懒汉式、双重校验锁及静态内部类单例所出现的问题，都可以通过枚举型单例进行解决，这也是《Effective Java》中推荐的写法。 枚举型我们知道java中的枚举类是在JDK5中才有的，因此枚举型单例对大部分人来说是比较陌生的，先举一个例子吧！ 枚举型单例实现很简单。123public enum Singleton &#123; INSTANCE;&#125; 就三行，很简单吧。那么为了大家更方便理解，我再用以下例子来剖析一下枚举型单例吧！ 1234567891011121314151617181920212223package com.chloneda.jutils.test;/** * @Created by chloneda * @Description: 单例类 */public class Singleton&#123;&#125;/** * 枚举型单例 */public enum SingletonEnum &#123; INSTANCE; private Singleton singleton = null; private SingletonEnum() &#123; singleton = new Singleton(); &#125; public Singleton getInstance() &#123; return singleton; &#125;&#125; 上面这个枚举型单例，通过反编译你就会得到以下代码。1234567public final class SingletonEnum extends java.lang.Enum&lt;SingletonEnum&gt; &#123; public static final SingletonEnum INSTANCE; public static SingletonEnum[] values(); public static SingletonEnum valueOf(String); public Singleton getSingleton(); static &#123;&#125;;&#125; 上面代码经过处理（只是去掉包名，便于阅读）！ 可以发现枚举型单例相关属性都被 static 关键词修饰，仔细一看还是 final 修饰的一个普通类，只不过继承自 java.lang.Enum 枚举类而已。也就是说这个枚举型单例是经过编译器处理的，这是JDK5提供的语法糖（Syntactic Sugar），所谓语法糖是指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，只是在编译器上做了手脚，可以更方便我们程序员使用。 枚举型单例天生就是线程安全的，这是因为 JVM类加载机制 的缘故，这里就不展开论述了，可以参考一下相关资料！ 枚举型单例反射问题我们先了解一下枚举型单例为什么可以防止反射的问题？ 其实在JDK5中，Java虚拟机对枚举类做了特殊处理，即 JVM 会阻止反射获取枚举类的私有构造方法。 我们用这个枚举型单例作为例子。123456public enum Singleton &#123; INSTANCE; Singleton() &#123; &#125;&#125; 继续使用上文的反射代码 SingletonReflectTest 来进行测试，先把SingletonReflectTest类的创建第一个实例的语句改成这样。 12//创建第一个实例Singleton instance1 = Singleton.INSTANCE; 运行后输出结果如下。1234567java.lang.NoSuchMethodException: com.chloneda.jutils.test.Singleton.&lt;init&gt;() at java.lang.Class.getConstructor0(Class.java:3082) at java.lang.Class.getDeclaredConstructor(Class.java:2178) at com.chloneda.jutils.test.SingletonReflectTest.main(SingletonReflectTest.java:18)Instance1 hashCode: 1929600551Exception in thread "main" java.lang.NullPointerException at com.chloneda.jutils.test.SingletonReflectTest.main(SingletonReflectTest.java:27) 直接报异常，也就是说枚举型单例可以完美解决反射的问题。 枚举型单例反序列化问题下面再深入了解一下为什么枚举会满足反序列化的问题 Java规范中规定，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，因此在枚举类型的序列化和反序列化上，Java做了特殊的规定。 在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过 java.lang.Enum 的 valueOf() 方法来根据名字查找枚举对象。 以上面的public enum SingletonEnum 枚举为例，序列化的时候只将 INSTANCE 这个名称输出，反序列化的时候再通过这个名称，查找对于的枚举类型，因此反序列化后的实例也会和之前被序列化的对象实例相同。 我们通过测试类测试一下，我们首先让枚举型单例 SingletonEnum 实现 Serializable 接口。1public enum SingletonEnum implements Serializable 再使用序列化测试类 SingletonSerializableTest 进行测试，输出结果如下。 12instance1 hashCode: 1674896058instance2 hashCode: 1674896058 也就是说枚举型单例可以解决反序列化带来的问题。 综上所述，枚举型单例可以有效解决线程安全、反射、反序列化带来的问题！ 然而你别得意，枚举型单例也有问题，就是它无法进行懒加载，因为枚举型单例的实例对象是在静态代码块即static块进行初始化的，是不是一语惊醒梦中人啊！ 中场休息说了这么多单例模式，知道了各个单例模式利弊，所以当我们使用时，我们要根据实际情况做出取舍，因为我们不可能实现一个单例可以满足所有情况。 下面让我们来看看单例模式的实际应用场景吧！ 单例模式的实际应用生活中的单例我们计算机上有很多场景应用到单例模式，可能经常看到，但我们并没有认识到，比如以下例子。 Windows的任务管理器（Task Manager）就是很典型的单例模式。你试过能打开两个windows的任务管理器吗？ windows的回收站也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。 网站的计数器，一般也是采用单例模式实现，否则难以同步。 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。 Web应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。 多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。 当然还有很多单例模式的应用，希望大家可以发现哦！ JDK中的单例java.lang.RuntimeRuntime类封装了Java运行时的环境。每一个java程序实际上都是启动了一个JVM进程，那么每个JVM进程都是对应这一个Runtime实例，此实例是由JVM为其实例化的。每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。 由于Java是单进程的，所以，在一个JVM中，Runtime的实例应该只有一个，所以应该使用单例来实现。 我们来看看 java.lang.Runtime 的单例模式实现。123456789public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); public static Runtime getRuntime() &#123; return currentRuntime; &#125; private Runtime() &#123;&#125;&#125; 看见没，这里使用的单例模式是饿汉式单例模式，也就是说，当类第一次被classloader加载的时候，实例就被创建出来了，当调用者每次调用的时候，就不需要再判断这个实例是否已经初始化，典型的空间换时间方案。 这里使用的是饿汉式单例模式，无疑是非常合适的！ java.awt.ToolkitToolkit是GUI中的类，与RunTime不同的是Toolkit采用的是懒汉式单例模式，因为它们并不需要事先创建好，只要在第一次真正用到的时候再创建就可以了。 我们来看看Toolkit类的代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344public abstract class Toolkit &#123; private static Toolkit toolkit; public static synchronized Toolkit getDefaultToolkit() &#123; if (toolkit == null) &#123; java.security.AccessController.doPrivileged( new java.security.PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; Class&lt;?&gt; cls = null; String nm = System.getProperty("awt.toolkit"); try &#123; cls = Class.forName(nm); &#125; catch (ClassNotFoundException e) &#123; ClassLoader cl = ClassLoader.getSystemClassLoader(); if (cl != null) &#123; try &#123; cls = cl.loadClass(nm); &#125; catch (final ClassNotFoundException ignored) &#123; throw new AWTError("Toolkit not found: " + nm); &#125; &#125; &#125; try &#123; if (cls != null) &#123; toolkit = (Toolkit)cls.newInstance(); if (GraphicsEnvironment.isHeadless()) &#123; toolkit = new HeadlessToolkit(toolkit); &#125; &#125; &#125; catch (final InstantiationException ignored) &#123; throw new AWTError("Could not instantiate Toolkit: " + nm); &#125; catch (final IllegalAccessException ignored) &#123; throw new AWTError("Could not access Toolkit: " + nm); &#125; return null; &#125; &#125;); loadAssistiveTechnologies(); &#125; return toolkit; &#125; &#125; 观察上面的代码你会发现Toolkit是一个抽象类，本身就无法实例化，而是通过反射机制加载类并创建新的实例。 懒汉式单例模式，并不会第一时间创建实例，提高了JVM的启动速度，典型的时间换空间方案，同时也体现了延迟加载的思想。 此外，需要注意的是懒汉式单例模式的线程安全问题，关于网上也有很多版本，都各有优势，大家适当取舍吧！ 框架中的单例 Mybatis中的单例模式：如ErrorContext和LogFactory。 Spring框架中的单例模式：采用单例注册表的方式进行实现中的单例模式，如AbstractBeanFactory抽象类的getBeans()方法。 小结这篇文章有点长，不过总算把单例模式说清楚了，哎，我的脑细胞！]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git rm与git rm -cached的区别]]></title>
    <url>%2F%2Fblog%2Fgit-rm%2F</url>
    <content type="text"><![CDATA[git rm与git rm –cached的区别 当我们需要删除暂存区或分支上的文件, 同时工作区也不需要这个文件了, 可以使用。123git rm file_pathgit commit -m 'delete somefile'git push 当我们需要删除暂存区或分支上的文件, 但本地又需要使用, 只是不希望这个文件被版本控制, 可以使用。123git rm --cached file_pathgit commit -m 'delete remote somefile'git push]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH自动断开后重连的解决方案]]></title>
    <url>%2F%2Fblog%2Fssh-connect%2F</url>
    <content type="text"><![CDATA[注：本文出自博主 Chloneda：个人博客 | 博客园 | Github | Gitee | 知乎 问题场景终端连接远程 SSH 服务，经常会出现长时间无操作后就自动断开，或者无响应，无法再通过键盘输入，只能强行断开重连。 那么有没有办法保持 SSH 连接不断开，或者断开连接后自动重连呢？有的！ 解决方法方案一：客户端发送心跳 Linux / Unix 下，编辑 ssh 配置文件：1vim /etc/ssh/ssh_config 在文件中添加以下内容：12ServerAliveInterval 20ServerAliveCountMax 999 ServerAliveInterval：表示每隔多少秒，从客户端向服务器端发送一次心跳（alive 检测）。 ServerAliveCountMax：表示服务端多少次心跳无响应之后，客户端才会认为与服务器的 SSH 连接已经断开，然后断开连接。 上述配置则表示：每隔20秒，向服务器发出一次心跳。若超过999次请求都没有发送成功，则会主动断开与服务器端的连接。 方案二：服务器端发送心跳 在服务器端中，编辑 ssh 配置文件：1sudo vim /etc/ssh/sshd_config 在文件中添加以下内容：12ClientAliveInterval 60ClientAliveCountMax 3 ClientAliveInterval：表示每隔多少秒，从服务器端向客户端发送一次心跳。 ClientAliveInterval：表示客户端多少次心跳无响应之后，服务端才会认为客户端已经断开连接，然后断开连接。 上述配置则表示：每隔60秒，服务器向客户端发出一次心跳。若客户端超过3次请求未响应，则会从服务器端断开与客户端的连接。 所以，总共允许无响应的时间是 60 * 3 = 180 秒以内。 其实，依赖 ssh 客户端定时发送心跳，putty、SecureCRT、XShell 工具也有这个功能。 完！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch启动、停止脚本]]></title>
    <url>%2F%2Fblog%2Fes-shell%2F</url>
    <content type="text"><![CDATA[注：本文出自博主 Chloneda：个人博客 | 博客园 | Github | Gitee | 知乎 Elasticsearch官网 构建Elasticsearch启动脚本 start_es.sh。12345#!/bin/bashexport ES_HOME=xxxsu elastic -c "sh $&#123;ES_HOME&#125;/bin/elasticsearch -d -p $&#123;ES_HOME&#125;/pid" 参数说明： su：登录用户。 elastic：部署Elasticsearch用户，避免root用户而无法启动。 c：c参数后跟具体命令。 d：Elasticsearch作为守护线程后台启动。 p：指定线程ID文件，需要新建。 构建Elasticsearch停止脚本 stop_es.sh。123456#!/bin/bashexport ES_HOME=xxxkill `cat $&#123;ES_HOME&#125;/pid` ``` `cat $&#123;ES_HOME&#125;/pid`]]></content>
      <categories>
        <category>采坑日记</category>
      </categories>
      <tags>
        <tag>采坑日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Mac无法写入U盘问题]]></title>
    <url>%2F%2Fblog%2Fupan-for-mac%2F</url>
    <content type="text"><![CDATA[注：本文出自博主 Chloneda：个人博客 | 博客园 | Github | Gitee | 知乎 前言​ 新手使用MacBook Pro时，会发现Mac系统下只能读取U盘，但不能写入。其实这个问题是因为，Mac OS系统硬盘格式为HFS， Windows 的硬盘格式为 NTFS，二者互不兼容。那么有没有解决的办法呢？ 网上的资料一般都安装第三方软件，如 NTFS for MAC 等，但一般都是收费的。或者，格式化U盘，将U盘磁盘格式设定为 FAT 或 exFAT，但个人不提倡。 现在提供一种方法进行开启 Mac OS 读写 NTFS格式 U盘的功能。经过测试！ 实现步骤1、打开 终端，输入：1diskutil list 该命令用于列出系统下的各个磁盘信息，找到你要处理的U盘名称，如名称为：Chloneda。 2、在终端中，输入：1sudo vim /etc/fstab 然后输入电脑密码（没有密码的不用输），输入电脑密码后，加入以下内容，进行配置：1LABEL=U盘名称 none ntfs rw,auto,nobrowse 如下图： 注意：如果你的U盘只有一个，只需添加一个即可，不能有空行！其次，如果你的U盘含有空格，如 Chloneda X，U盘名称中的空格用\040代替，即命令应该写成：1LABEL=Chloneda\040X none ntfs rw,auto,nobrowse 参数说明： U盘名称：建议不要有中文。 ntfs rw： 表示把这个分区挂载为可读写的 ntfs格式。 nobrowse：这个代表了在 finder 里不显示这个分区，这个选项非常重要，如果不打开的话挂载会失败。完成后，按 esc 键退出编辑模式，并按 :wq! 命令，然后回车进行保存。 3、创建快捷方式终端中输入以下内容，创建桌面快捷方式。1sudo ln -s /Volumes/U盘名称 ~/Desktop/U盘名称 因为刚刚创建的分区是不会在 Finder 里不显示的,创建桌面快捷方式，方便以后再次访问U盘（可将 快捷方式 拖拽至 Finder 的侧边栏喔）。 4、拔掉U盘，重新插入，可见正常显示，正常读写。 补充1、如果不可以写入U盘，请重启一下电脑。2、如果要恢复之前样子，请输入命令 sudo vim /etc/fstab 重新编辑，把写入的 LABEL 一行删除，重新保存即可。]]></content>
      <categories>
        <category>采坑日记</category>
      </categories>
      <tags>
        <tag>采坑日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker容器Centos不能使用systemctl命令问题]]></title>
    <url>%2F%2Fblog%2Fbug-dock-os%2F</url>
    <content type="text"><![CDATA[注：本文出自博主 Chloneda：个人博客 | 博客园 | Github | Gitee | 知乎 最近使用Docker搭建Centos容器时遇到这样的问题：Centos系统的不能使用systemctl命令! 具体场景使用 systemctl 或 service 命令重启服务时。1systemctl restart snmpd.service 会报无权限的错误：1Failed to get D-Bus connection: Operation not permitted； 这是docker中centos7的bug，官网上也提到了这个问题，并给出了 解决办法，但有点复杂。我们可以通过以下方法解决！ 首先，使用docker构建centos容器加上 privileged 参数，即在docker run命令是要加上 –privileged=true，该参数在docker容器运行时，让系统拥有真正的root权限。 其次，在启动容器时，在docker run 命令最后，加上/usr/sbin/init，最终命令为：1docker run -v /tmp/:/tmp --privileged --cap-add SYS_ADMIN -e container=docker -it --name=centos -d --restart=always centos /usr/sbin/init 参数说明： -v /tmp/:/tmp：挂载宿主机的一个目录，冒号”:”前面的目录是宿主机目录，后面的目录是容器内目录。 –privileged： 指定容器是否是特权容器。 –cap-add SYS_ADMIN： 添加系统的权限，不然系统很多功能都用不了的。 -e container=docker：设置容器的类型。 -it： 启动互动模式。 /usr/sbin/init：初始容器里的CENTOS，用于启动dbus-daemon。 最后，如果想查看Docker更多内容，请查看Docker官网文档。]]></content>
      <categories>
        <category>采坑日记</category>
      </categories>
      <tags>
        <tag>采坑日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些优秀的软件工具！]]></title>
    <url>%2F%2Fblog%2Ftools%2F</url>
    <content type="text"><![CDATA[注：本文出自博主 Chloneda：个人博客 | 博客园 | Github | Gitee | 知乎 本博客用于收录那些优秀的软件工具，并且长期更新！ Windowseverythingeverything：是速度最快的文件名搜索软件。其速度之快令人震惊，百G硬盘几十万个文件，可以在几秒钟之内完成索引；文件名搜索瞬间呈现结果。它小巧免费，支持中文，支持正则表达式，可以通过HTTP或FTP分享搜索结果。如果不满意Windows自带的搜索工具，那就用它吧！ MacOseZipeZip：是一款 Mac 上完全免费的压缩与解压缩工具软件，主要是提供了文件预览以及加密压缩和解压缩功能，功能足够实用，基本可以替代市面上大部分的 macOS 商业收费压缩工具，个人认为值得力荐。 OmniGraffleOmniGraffle：Windows下使用Visio画框图、流程图非常方便，切换到MAC后，我们可以使用OmniGraffle。 CheatSheetCheatSheet：Mac上的快捷键神器 LinuxRemminaRemmina：是一款在 Linux 和其他类 Unix 系统下的自由开源、功能丰富、强大的远程桌面客户端，它用 GTK+ 3 编写而成。它适用于那些需要远程访问及使用许多计算机的系统管理员和在外出行人员。]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git同步代码至github和gitee(码云)]]></title>
    <url>%2F%2Fblog%2Fgit-to-github-gitee%2F</url>
    <content type="text"><![CDATA[注：本文出自博主 Chloneda：个人博客 | 博客园 | Github | Gitee | 知乎 我们有时候开发代码需要把代码同步到多个远程库中，如何操作才能做到呢？ 我们知道，git是分布式版本控制系统，同步到多个远程库时，需要用不同的名称来标识不同的远程库，而git给远程库起的默认名称是origin。所以我们需要修改、配置名称，以关联不同远程库。有两种方式！ 为了方便举例，我以GitHub和Gitee(码云)作为示例！ 同步方式命令方式同步先删除已关联的名为origin的远程库：1git remote rm origin 然后，再关联GitHub的远程库：1git remote add github git@github.com:chloneda/demo.git 接着，再关联码云的远程库：1git remote add gitee git@gitee.com:chloneda/demo.git 配置方式同步修改.git文件夹内的config文件：1234567891011[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true[remote "origin"] url = git@github.com:chloneda/demo.git fetch = +refs/heads/*:refs/remotes/github/*[branch "master"] remote = origin merge = refs/heads/master 将上述文件内容[remote “origin”]内容复制，修改origin名称，内容如下：1234567891011121314[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true[remote "github"] url = git@github.com:chloneda/demo.git fetch = +refs/heads/*:refs/remotes/github/*[remote "gitee"] url = git@gitee.com:chloneda/demo.git fetch = +refs/heads/*:refs/remotes/gitee/*[branch "master"] remote = origin merge = refs/heads/master 查看远程库通过以上两种方式的任一种方式配置完成后，我们用git remote -v查看远程库信息：1234gitee git@gitee.com:chloneda/demo.git (fetch)gitee git@gitee.com:chloneda/demo.git (push)github git@github.com:chloneda/demo.git (fetch)github git@github.com:chloneda/demo.git (push) 可以看到两个远程库，说明配置生效了。 上传代码12git add .git commit -m "update" 提交到github1git push github master 提交到码云1git push gitee master 更新代码12345# 从github拉取更新git pull github# 从gitee拉取更新git pull gitee 踩到的坑上述过程中，更新或提交代码时可能会遇到fatal:refusing to merge unrelated histories (拒绝合并无关的历史) 错误，解决办法： 首先将远程仓库和本地仓库关联起来。 1git branch --set-upstream-to=origin/remote_branch your_branch 其中，origin/remote_branch是你本地分支对应的远程分支，your_branch是你当前的本地分支。 然后使用git pull整合远程仓库和本地仓库。1git pull --allow-unrelated-histories (忽略版本不同造成的影响) 重新更新、提交即可。 注： 如遇到 Git没有共同祖先的两个分支合并 的情形请自行查询！]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊SNMP协议]]></title>
    <url>%2F%2Fblog%2Fsnmp-protocol%2F</url>
    <content type="text"><![CDATA[注：本文出自博主 Chloneda：个人博客 | 博客园 | Github | Gitee | 知乎 SNMP概述SNMP(Simple Network Management Protocol):简单网络管理协议,是基于TCP/IP五层协议中的应用层协议。由于其简单可靠，提供了一种监控和管理网络设备的系统方法，因此受到了众多厂商的欢迎，成为了目前最为广泛的网管协议。 SNMP的基本思想：为不同种类、厂家、型号的设备，定义一个统一的接口和协议，使得管理员可以是使用统一的外观面对这些需要管理的网络设备。通过网络，管理员可以管理位于不同物理空间的设备，从而大大提高网络管理的效率，简化网络管理员的工作。 Snmp版本SNMP目前共有v1，v2，v3这三个版本，三个版本的联系与区别。 SNMP v1：是SNMP协议的最初版本，存在较多安全缺陷，现在这个版本是使用的比较少了。 SNMP v2：也采用团体名认证,在兼容SNMPv1的同时又扩充了SNMPv1的功能，具体是扩展了数据类型、支持分布式网络管理、可以实现大量数据的传输，提高了效率和性能、丰富了故障处理能力及增加了集合处理功能。 SNMP v3：是最新版本的SNMP。它相对于V2版本，在安全性上得到了重要提升，增加了对认证和密文传输的支持。 SNMP核心概念SNMP管理架构SNMP管理架构应包含四个部分进行网络管理：SNMP管理站、SNMP代理、MIB(管理信息库)和SNMP管理协议。 SNMP管理站（management station）：通常被称作为网络管理工作站（NMS），负责收集维护各个SNMP元素的信息，通过UDP协议向SNMP代理发送各种命令，当SNMP代理收到命令后，对收集的信息进行处理，并返回SNMP管理站需要的参数。而此时被管理对象中一定要有代理进程，这样才能响应管理站发来的请求。 SNMP代理(Agent)：运行在各个被管理的网络节点之上，负责统计该节点的各项信息，并且负责与SNMP管理站交互，接收并执行管理站的命令，上传各种本地的网络信息。 注：协议栈中带有阴影的部分是原主机或路由器所具有的，而没有阴影的部分是为实现网络管理而增加的。 MIB(管理信息库)：是对象的集合，它代表网络中可以管理的资源和设备。每个对象基本上是一个数据变量，它代表被管理的对象的一方面的信息。 SNMP管理协议：用于管理站与SNMP代理之间的通信规则，其SNMP报文格式请查看底下章节。 管理站和代理之间利用 SNMP 报文进行通信，而 SNMP 报文又使用 UDP协议来传送，由于采用UDP协议，不需要在代理和管理站之间保持连接。 SNMP报文格式管理站（NMS）和代理（Agent）之间交换的管理信息构成了SNMP报文，报文的基本格式如下图： 下面将对该SNMP报文格式逐个进行说明！ SNMP消息报文包含两个部分：SNMP报头和PDU(协议数据单元)。 SNMP报头 版本：版本号字段，规则为版本号减 1，如SNMP V1则应写入 0。如果SNMP代理使用不相同的协议，会直接抛弃与自己协议版本不同的数据报。 共同体(community)：即团体名，作为管理进程和代理进程之间的明文口令，相当于密码，默认为public，该字段可读可写，用来限制NMS对Agent的访问。如果团体名没有得到NMS/Agent的认可，该报文将被丢弃。 PDU 类型：填入 0～4 中的一个数字，其对应关系如图。 PDU类型请参考PDU(协议数据单元)章节！ Get/Set 首部 请求标识符(request ID)，这是由管理进程设置的一个整数值。代理进程在发送 get-response 报文时也要返回此请求标识符。管理进程可同时向许多代理发出 get 报文，这些报文都使用 UDP 传送，先发送的有可能后到达。设置了请求标识符可使管理进程能够识别返回的响应报文对于哪一个请求。 差错状态（error status）：由代理进程回答时填入 0～5 中的一个数字，见表 3 的描述。 差错索引(error index)：当出现 noSuchName、badValue 或 readOnly 的差错时，由代理进程在回答时设置的一个整数，它指明有差错的变量在变量列表中的偏移。 Trap 首部 企业（enterprise）：填入 trap 报文的网络设备的对象标识符。此对象标识符肯定是在图 3 的对象命名树上的 enterprise 结点{1.3.6.1.4.1}下面的一棵子树上。 Trap 类型：此字段正式的名称是 generic-trap，共分为表 4 中的 7 种。 当使用上述类型 2、3、5 时，在报文后面变量部分的第一个变量应标识响应的接口。 特定代码(specific-code)：指明代理自定义的时间（若 trap 类型为 6），否则为 0。 时间戳(timestamp)：指明自代理进程初始化到 trap 报告的事件发生所经历的时间，单位为 10ms。例如时间戳为 1908 表明在代理初始化后 1908ms 发生了该时间。 变量绑定(variable-bindings)：指明一个或多个变量的名和对应的值。在 get 或 get-next 报文中，变量的值应忽略。 PDU(协议数据单元)SNMP v1 版本规定了 5 种核心 PDU(协议数据单元)，用来在管理进程和代理之间信息的交换。 get-request 操作：从代理进程处提取一个OID值。 get-next-request 操作：从代理进程(MIB中)处提取紧跟当前参数值的下一个OID值，常被用于检索表数据，也被用于不能指定名称的变量,可以浏览MIB树。 set-request 操作：设置代理进程的一个或多个参数值。 get-response 操作：返回的一个或多个参数值。这个操作是由代理进程发出的，它是前面三种操作的响应操作。 trap 操作：代理进程主动发出的报文，通知管理进程有某些事情发生。 前面的 3 种操作是由管理进程向代理进程发出的，后面的 2 个操作是代理进程发给管理进程的，其中代理进程端是用 161 端口接收 get 或 set 报文，而在管理进程端是用 162 端口来接收 trap 报文。 另外，在SNMP v2版本又增加了 3 种PDU(协议数据单元)，它们分别是： inform-request 操作：允许路由器向SNMP管理器发送通知请求。 getBulk-request 操作：从代理进程处提取多个参数值,该操作会根据最大重试值执行一连串的GetNext操作，减少管理站与代理之间的交互,提高效率。 report 操作： SNMP的操作类型其实上述 8 种PDU(协议数据单元)按照功能不同，可以归结为三类操作。 查询、设置SNMP变量,如get-request、get-next-request、set-request、getBulk-request、inform-request。 应答请求,如 get-response。 事件报告，如trap。 实际上，在SNMP中，SNMP管理站对被管理设备的SNMP变量的操作只能有 读 与 写 两种基本动作。 ASN.1(抽象语法标记)ASN.1：高级的数据描述语言。描述数据的类型、结构、组织、及编码方法。包括符号和语法两部分。SNMP使用ASN.1描述PDU和MIB(管理信息库)。 关于ASN.1详细信息请查看这篇博文：SNMP从入门到开发：进阶篇 BER(基本编码规则)BER(Basic Encoding Rule)，中文名称：基本编码规则。描述具体的ASN.1对象如何编码为比特流在网络上传输。SNMP使用BER(Basic Encoding Rule)作为编码方案，数据首先先经过BER编码，再经由传输层协议(一边是UDP)发往接收方。接收方在SNMP端口上收到PDU后，经过BER解码后，得到具体的SNMP操作数据。 BER的数据都由三个域构成:标识域(tag)+长度域(length)+值域(value)。 SMI(管理信息结构)SMI(Structure of Managerment Intormation)，中文名称：管理信息结构，是SNMP的描述方法。规定了使用ASN.1子类型、符号。ASN.1功能强大，但SNMP只用到了其中很小一部分，对于这一部分内容的描述，限定了范围，即为SMI。SMI规定了使用到的ASN.1类型、宏、符号等。SMI是ASN.1的一个子集和超集。 MIB(管理信息库)MIB(Management Information Base)，中文名称：管理信息库，由网络管理协议访问的管理对象数据库。MIB是对象的集合，它代表网络中可以管理的资源和设备。每个对象基本上是一个数据变量，它代表被管理的对象的一方面的信息。 管理信息库 MIB 指明了网络元素所维持的变量（即能够被管理进程查询和设置的信息）。MIB 给出了一个网络中所有可能的被管理对象的集合的数据结构。SNMP 的管理信息库采用和域名系统 DNS 相似的树型结构，它的根在最上面，根没有名字。底下的图 画的是管理信息库的一部分，它又称为对象命名（object naming tree）。 MIB采用分层树形结构，对象命名树的顶级对象有三个，即 ISO、ITU-T 和这两个组织的联合体。在 ISO 的下面有 4 个结点，其中的饿一个（标号 3）是被标识的组织。在其下面有一个美国国防部（Department of Defense）的子树（标号是 6），再下面就是 Internet（标号是 1）。在只讨论 Internet 中的对象时，可只画出 Internet 以下的子树（图中带阴影的虚线方框），并在 Internet 结点旁边标注上{1.3.6.1}即可。 在 Internet 结点下面的第二个结点是 mgmt（管理），标号是 2。再下面是管理信息库，原先的结点名是 mib。1991 年定义了新的版本 MIB-II，故结点名现改为 mib-2，其标识为{1.3.6.1.2.1}，或{Internet(1) .2.1}。这种标识为对象标识符。 最初的结点 mib 将其所管理的信息分为 8 个类别，如图，现在的 mib-2 所包含的信息类别已超过 40 个。 应当指出，MIB 的定义与具体的网络管理协议无关，这对于厂商和用户都有利。厂商可以在产品（如路由器）中包含 SNMP 代理软件，并保证在定义新的 MIB 项目后该软件仍遵守标准。用户可以使用同一网络管理客户软件来管理具有不同版本的 MIB 的多个路由器。当然，一个没有新的 MIB 项目的路由器不能提供这些项目的信息。这里要提一下MIB中的对象{1.3.6.1.4.1}，即enterprises（企业），其所属结点数已超过 3000。例如IBM为{1.3.6.1.4.1.2}，Cisco为{1.3.6.1.4.1.9}，Novell为{1.3.6.1.4.1.23}等。世界上任何一个公司、学校只要用电子邮件发往iana-mib@isi.edu进行申请即可获得一个结点名。这样各厂家就可以定义自己的产品的被管理对象名，使它能用SNMP进行管理。 ASN.1、BER、SMI、MIB、PDU的关系关于ASN.1、BER、SMI、MIB、PDU的关系如下图所示。 OID(对象标识符)OID(Object Identifier)，中文名称：对象标识符，被管理设备的每个管理资源和对象都有自己的OID(Object Identifier)，管理对象通过树状结构进行组织，OID由树上的一系列整数组成，整数之间用点( . )分隔开，树的叶子节点才是真正能够被管理的对象。 常用OID这里总结了一些常用的OID，当需要时可以及时查询。SNMP监控常用OID查询SNMP监控一些常用OID的总结下载不同厂商的MIB包查看不同厂商的OID代号 SNMP协议实现SNMP协议的Java实现是SNMP4J，其jar包可以在SNMP官方网站上下载。开发前请简单了解一下SNMP4J，具体细节请看这篇博文：SNMP4J介绍；更多SNMP4J示例请参考Github。 本文小结SNMP支持Window、Linux、MacOS系统的安装，关于SNMP的安装步骤请自行查询。]]></content>
      <categories>
        <category>SNMP</category>
      </categories>
      <tags>
        <tag>SNMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列九-强大的动态SQL]]></title>
    <url>%2F%2Fblog%2Fmybatis-9%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（八）—mapper映射文件配置之select、resultMap》简单介绍了mybatis的查询，至此，CRUD都已讲完。本文将介绍mybatis强大的动态SQL。 那么，问题来了： 什么是动态SQL? 动态SQL有什么作用？ 传统的使用JDBC的方法，相信大家在组合复杂的的SQL语句的时候，需要去拼接，稍不注意哪怕少了个空格，都会导致错误。Mybatis的动态SQL功能正是为了解决这种问题， 其通过 if, choose, when, otherwise, trim, where, set, foreach标签，可组合成非常灵活的SQL语句，从而提高开发人员的效率。下面就去感受Mybatis动态SQL的魅力吧： mybatis中if判断作为程序猿，谁不懂if !在mybatis中也能用 if 啦：1234567&lt;select id="findUserById" resultType="user"&gt; select * from user where &lt;if test="id != null"&gt; id=#&#123;id&#125; &lt;/if&gt; and deleteFlag=0;&lt;/select&gt; 上面例子： 如果传入的id 不为空， 那么才会SQL才拼接id = #{id}。 这个相信大家看一样就能明白，不多说。 细心的人会发现一个问题：“你这不对啊！ 要是你传入的id为null, 那么你这最终的SQL语句不就成了 select * from user where and deleteFlag=0, 这语句有问题！” 是啊，这时候，mybatis的 where 标签就该隆重登场啦： mybatis中where咱们通过where改造一下上面的例子：123456789&lt;select id="findUserById" resultType="user"&gt; select * from user &lt;where&gt; &lt;if test="id != null"&gt; id=#&#123;id&#125; &lt;/if&gt; and deleteFlag=0; &lt;/where&gt; &lt;/select&gt; 有些人就要问了： “你这都是些什么玩意儿！ 跟上面的相比， 不就是多了个where标签嘛！ 那这个还会不会出现 select * from user where and deleteFlag=0 ？” 的确，从表面上来看，就是多了个where标签而已， 不过实质上， mybatis是对它做了处理，当它遇到AND或者OR这些，它知道怎么处理。其实我们可以通过 trim 标签去自定义这种处理规则。 trim:我的地盘，我做主上面的where标签，其实用trim 可以表示如下：123&lt;trim prefix="WHERE" prefixOverrides="AND |OR "&gt; ... &lt;/trim&gt; 它的意思就是： 当WHERE后紧随AND或则OR的时候，就去除AND或者OR。 除了WHERE以外， 其实还有一个比较经典的实现，那就是SET。 set: 信我，不出错123456789101112131415161718&lt;update id="updateUser" parameterType="com.dy.entity.User"&gt; update user set &lt;if test="name != null"&gt; name = #&#123;name&#125;, &lt;/if&gt; &lt;if test="password != null"&gt; password = #&#123;password&#125;, &lt;/if&gt; &lt;if test="age != null"&gt; age = #&#123;age&#125; &lt;/if&gt; &lt;where&gt; &lt;if test="id != null"&gt; id = #&#123;id&#125; &lt;/if&gt; and deleteFlag = 0; &lt;/where&gt;&lt;/update&gt; 问题又来了： “如果我只有name不为null, 那么这SQL不就成了 update set name = #{name}, where …….. ? 你那name后面那逗号会导致出错啊！” 是的，这时候，就可以用mybatis为我们提供的set 标签了。下面是通过set标签改造后：1234567891011121314&lt;update id="updateUser" parameterType="com.dy.entity.User"&gt; update user &lt;set&gt; &lt;if test="name != null"&gt;name = #&#123;name&#125;,&lt;/if&gt; &lt;if test="password != null"&gt;password = #&#123;password&#125;,&lt;/if&gt; &lt;if test="age != null"&gt;age = #&#123;age&#125;,&lt;/if&gt; &lt;/set&gt; &lt;where&gt; &lt;if test="id != null"&gt; id = #&#123;id&#125; &lt;/if&gt; and deleteFlag = 0; &lt;/where&gt;&lt;/update&gt; 这个用trim 可表示为：123&lt;trim prefix="SET" suffixOverrides=","&gt; ...&lt;/trim&gt; foreach: 你有for, 我有foreach！java中有for, 可通过for循环， 同样， mybatis中有foreach, 可通过它实现循环，循环的对象当然主要是java容器和数组。123456789&lt;select id="selectPostIn" resultType="domain.blog.Post"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item="item" index="index" collection="list" open="(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; 将一个 List 实例或者数组作为参数对象传给 MyBatis，当这么做的时候，MyBatis 会自动将它包装在一个 Map 中并以名称为键。List 实例将会以“list”作为键，而数组实例的键将是“array”。同样， 当循环的对象为map的时候，index其实就是map的key。 choose: 我选择了你，你选择了我Java中有switch, mybatis有choose1234567891011121314&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test="title != null"&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 以上例子中： 当title和author都不为null的时候， 那么选择二选一（前者优先）， 如果都为null, 那么就选择 otherwise中的， 如果tilte和author只有一个不为null, 那么就选择不为null的那个。 纵观mybatis的动态SQL， 强大而简单， 相信大家简单看一下就能使用了。 好啦，本次就写到这！下篇文章将结合mybatis的源码分析一次sql语句执行的整个过程。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列五-TypeHandler简介及配置（mybatis源码篇）]]></title>
    <url>%2F%2Fblog%2Fmybatis-5%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（四）—配置详解之typeAliases别名（mybatis源码篇）》为大家介绍了mybatis中别名的使用，以及其源码。本篇将为大家介绍TypeHandler， 并简单分析其源码。 Mybatis中的TypeHandler是什么？ 无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时，都会用类型处理器将获取的值以合适的方式转换成 Java 类型。Mybatis默认为我们实现了许多TypeHandler, 当我们没有配置指定TypeHandler时，Mybatis会根据参数或者返回结果的不同，默认为我们选择合适的TypeHandler处理。 那么，Mybatis为我们实现了哪些TypeHandler呢? 我们怎么自定义实现一个TypeHandler ? 这些都会在接下来的mybatis的源码中看到。 在看源码之前，还是像之前一样，先看看怎么配置吧？ 配置TypeHandler123456789101112131415161718192021222324252627282930&lt;configuration&gt; &lt;typeHandlers&gt; &lt;!-- 当配置package的时候，mybatis会去配置的package扫描TypeHandler &lt;package name="com.dy.demo"/&gt; --&gt; &lt;!-- handler属性直接配置我们要指定的TypeHandler --&gt; &lt;typeHandler handler=""/&gt; &lt;!-- javaType 配置java类型，例如String, 如果配上javaType, 那么指定的typeHandler就只作用于指定的类型 --&gt; &lt;typeHandler javaType="" handler=""/&gt; &lt;!-- jdbcType 配置数据库基本数据类型，例如varchar, 如果配上jdbcType, 那么指定的typeHandler就只作用于指定的类型 --&gt; &lt;typeHandler jdbcType="" handler=""/&gt; &lt;!-- 也可两者都配置 --&gt; &lt;typeHandler javaType="" jdbcType="" handler=""/&gt; &lt;/typeHandlers&gt; ...... &lt;/configuration&gt; 上面简单介绍了一下TypeHandler, 下面就看看mybatis中TypeHandler的源码了。 老规矩，先从对xml的解析讲起： typeHandlers节点源码123456789101112131415161718192021222324252627282930313233343536373839404142/** * 解析typeHandlers节点 */private void typeHandlerElement(XNode parent) throws Exception &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; //子节点为package时，获取其name属性的值，然后自动扫描package下的自定义typeHandler if ("package".equals(child.getName())) &#123; String typeHandlerPackage = child.getStringAttribute("name"); typeHandlerRegistry.register(typeHandlerPackage); &#125; else &#123; /** * 子节点为typeHandler时， 可以指定javaType属性， * 也可以指定jdbcType, 也可两者都指定 * javaType 是指定java类型 * jdbcType 是指定jdbc类型（数据库类型： 如varchar） */ String javaTypeName = child.getStringAttribute("javaType"); String jdbcTypeName = child.getStringAttribute("jdbcType"); //handler就是我们配置的typeHandler String handlerTypeName = child.getStringAttribute("handler"); //resolveClass方法就是我们上篇文章所讲的TypeAliasRegistry里面处理别名的方法 Class&lt;?&gt; javaTypeClass = resolveClass(javaTypeName); //JdbcType是一个枚举类型，resolveJdbcType方法是在获取枚举类型的值 JdbcType jdbcType = resolveJdbcType(jdbcTypeName); Class&lt;?&gt; typeHandlerClass = resolveClass(handlerTypeName); //注册typeHandler, typeHandler通过TypeHandlerRegistry这个类管理 if (javaTypeClass != null) &#123; if (jdbcType == null) &#123; typeHandlerRegistry.register(javaTypeClass, typeHandlerClass); &#125; else &#123; typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass); &#125; &#125; else &#123; typeHandlerRegistry.register(typeHandlerClass); &#125; &#125; &#125; &#125;&#125; 接下来看看TypeHandler的管理注册类： TypeHandlerRegistry源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379/** * typeHandler注册管理类 */public final class TypeHandlerRegistry &#123; //源码一上来，二话不说，几个大大的HashMap就出现，这不又跟上次讲的typeAliases的注册类似么 //基本数据类型与其包装类 private static final Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; reversePrimitiveMap = new HashMap&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;() &#123; private static final long serialVersionUID = 1L; &#123; put(Byte.class, byte.class); put(Short.class, short.class); put(Integer.class, int.class); put(Long.class, long.class); put(Float.class, float.class); put(Double.class, double.class); put(Boolean.class, boolean.class); put(Character.class, char.class); &#125; &#125;; //这几个MAP不用说就知道存的是什么东西吧，命名的好处 private final Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; JDBC_TYPE_HANDLER_MAP = new EnumMap&lt;JdbcType, TypeHandler&lt;?&gt;&gt;(JdbcType.class); private final Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; TYPE_HANDLER_MAP = new HashMap&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt;(); private final TypeHandler&lt;Object&gt; UNKNOWN_TYPE_HANDLER = new UnknownTypeHandler(this); private final Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; ALL_TYPE_HANDLERS_MAP = new HashMap&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt;(); //就像上篇文章讲的typeAliases一样，mybatis也默认给我们注册了不少的typeHandler //具体如下 public TypeHandlerRegistry() &#123; register(Boolean.class, new BooleanTypeHandler()); register(boolean.class, new BooleanTypeHandler()); register(JdbcType.BOOLEAN, new BooleanTypeHandler()); register(JdbcType.BIT, new BooleanTypeHandler()); register(Byte.class, new ByteTypeHandler()); register(byte.class, new ByteTypeHandler()); register(JdbcType.TINYINT, new ByteTypeHandler()); register(Short.class, new ShortTypeHandler()); register(short.class, new ShortTypeHandler()); register(JdbcType.SMALLINT, new ShortTypeHandler()); register(Integer.class, new IntegerTypeHandler()); register(int.class, new IntegerTypeHandler()); register(JdbcType.INTEGER, new IntegerTypeHandler()); register(Long.class, new LongTypeHandler()); register(long.class, new LongTypeHandler()); register(Float.class, new FloatTypeHandler()); register(float.class, new FloatTypeHandler()); register(JdbcType.FLOAT, new FloatTypeHandler()); register(Double.class, new DoubleTypeHandler()); register(double.class, new DoubleTypeHandler()); register(JdbcType.DOUBLE, new DoubleTypeHandler()); register(String.class, new StringTypeHandler()); register(String.class, JdbcType.CHAR, new StringTypeHandler()); register(String.class, JdbcType.CLOB, new ClobTypeHandler()); register(String.class, JdbcType.VARCHAR, new StringTypeHandler()); register(String.class, JdbcType.LONGVARCHAR, new ClobTypeHandler()); register(String.class, JdbcType.NVARCHAR, new NStringTypeHandler()); register(String.class, JdbcType.NCHAR, new NStringTypeHandler()); register(String.class, JdbcType.NCLOB, new NClobTypeHandler()); register(JdbcType.CHAR, new StringTypeHandler()); register(JdbcType.VARCHAR, new StringTypeHandler()); register(JdbcType.CLOB, new ClobTypeHandler()); register(JdbcType.LONGVARCHAR, new ClobTypeHandler()); register(JdbcType.NVARCHAR, new NStringTypeHandler()); register(JdbcType.NCHAR, new NStringTypeHandler()); register(JdbcType.NCLOB, new NClobTypeHandler()); register(Object.class, JdbcType.ARRAY, new ArrayTypeHandler()); register(JdbcType.ARRAY, new ArrayTypeHandler()); register(BigInteger.class, new BigIntegerTypeHandler()); register(JdbcType.BIGINT, new LongTypeHandler()); register(BigDecimal.class, new BigDecimalTypeHandler()); register(JdbcType.REAL, new BigDecimalTypeHandler()); register(JdbcType.DECIMAL, new BigDecimalTypeHandler()); register(JdbcType.NUMERIC, new BigDecimalTypeHandler()); register(Byte[].class, new ByteObjectArrayTypeHandler()); register(Byte[].class, JdbcType.BLOB, new BlobByteObjectArrayTypeHandler()); register(Byte[].class, JdbcType.LONGVARBINARY,new BlobByteObjectArrayTypeHandler()); register(byte[].class, new ByteArrayTypeHandler()); register(byte[].class, JdbcType.BLOB, new BlobTypeHandler()); register(byte[].class, JdbcType.LONGVARBINARY, new BlobTypeHandler()); register(JdbcType.LONGVARBINARY, new BlobTypeHandler()); register(JdbcType.BLOB, new BlobTypeHandler()); register(Object.class, UNKNOWN_TYPE_HANDLER); register(Object.class, JdbcType.OTHER, UNKNOWN_TYPE_HANDLER); register(JdbcType.OTHER, UNKNOWN_TYPE_HANDLER); register(Date.class, new DateTypeHandler()); register(Date.class, JdbcType.DATE, new DateOnlyTypeHandler()); register(Date.class, JdbcType.TIME, new TimeOnlyTypeHandler()); register(JdbcType.TIMESTAMP, new DateTypeHandler()); register(JdbcType.DATE, new DateOnlyTypeHandler()); register(JdbcType.TIME, new TimeOnlyTypeHandler()); register(java.sql.Date.class, new SqlDateTypeHandler()); register(java.sql.Time.class, new SqlTimeTypeHandler()); register(java.sql.Timestamp.class, new SqlTimestampTypeHandler()); // issue #273 register(Character.class, new CharacterTypeHandler()); register(char.class, new CharacterTypeHandler()); &#125; public boolean hasTypeHandler(Class&lt;?&gt; javaType) &#123; return hasTypeHandler(javaType, null); &#125; public boolean hasTypeHandler(TypeReference&lt;?&gt; javaTypeReference) &#123; return hasTypeHandler(javaTypeReference, null); &#125; public boolean hasTypeHandler(Class&lt;?&gt; javaType, JdbcType jdbcType) &#123; return javaType != null &amp;&amp; getTypeHandler((Type) javaType, jdbcType) != null; &#125; public boolean hasTypeHandler(TypeReference&lt;?&gt; javaTypeReference, JdbcType jdbcType) &#123; return javaTypeReference != null &amp;&amp; getTypeHandler(javaTypeReference, jdbcType) != null; &#125; public TypeHandler&lt;?&gt; getMappingTypeHandler( Class&lt;? extends TypeHandler&lt;?&gt;&gt; handlerType) &#123; return ALL_TYPE_HANDLERS_MAP.get(handlerType); &#125; public &lt;T&gt; TypeHandler&lt;T&gt; getTypeHandler(Class&lt;T&gt; type) &#123; return getTypeHandler((Type) type, null); &#125; public &lt;T&gt; TypeHandler&lt;T&gt; getTypeHandler(TypeReference&lt;T&gt; javaTypeReference) &#123; return getTypeHandler(javaTypeReference, null); &#125; public TypeHandler&lt;?&gt; getTypeHandler(JdbcType jdbcType) &#123; return JDBC_TYPE_HANDLER_MAP.get(jdbcType); &#125; public &lt;T&gt; TypeHandler&lt;T&gt; getTypeHandler(Class&lt;T&gt; type, JdbcType jdbcType) &#123; return getTypeHandler((Type) type, jdbcType); &#125; public &lt;T&gt; TypeHandler&lt;T&gt; getTypeHandler( TypeReference&lt;T&gt; javaTypeReference, JdbcType jdbcType) &#123; return getTypeHandler(javaTypeReference.getRawType(), jdbcType); &#125; private &lt;T&gt; TypeHandler&lt;T&gt; getTypeHandler(Type type, JdbcType jdbcType) &#123; Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; jdbcHandlerMap = TYPE_HANDLER_MAP.get(type); TypeHandler&lt;?&gt; handler = null; if (jdbcHandlerMap != null) &#123; handler = jdbcHandlerMap.get(jdbcType); if (handler == null) &#123; handler = jdbcHandlerMap.get(null); &#125; &#125; if (handler == null &amp;&amp; type != null &amp;&amp; type instanceof Class &amp;&amp; Enum.class.isAssignableFrom((Class&lt;?&gt;) type)) &#123; handler = new EnumTypeHandler((Class&lt;?&gt;) type); &#125; @SuppressWarnings("unchecked") // type drives generics here TypeHandler&lt;T&gt; returned = (TypeHandler&lt;T&gt;) handler; return returned; &#125; public TypeHandler&lt;Object&gt; getUnknownTypeHandler() &#123; return UNKNOWN_TYPE_HANDLER; &#125; public void register(JdbcType jdbcType, TypeHandler&lt;?&gt; handler) &#123; JDBC_TYPE_HANDLER_MAP.put(jdbcType, handler); &#125; // // REGISTER INSTANCE // /** * 只配置了typeHandler, 没有配置jdbcType 或者javaType */ @SuppressWarnings("unchecked") public &lt;T&gt; void register(TypeHandler&lt;T&gt; typeHandler) &#123; boolean mappedTypeFound = false; //在自定义typeHandler的时候，可以加上注解MappedTypes 去指定关联的javaType //因此，此处需要扫描MappedTypes注解 MappedTypes mappedTypes = typeHandler.getClass().getAnnotation(MappedTypes.class); if (mappedTypes != null) &#123; for (Class&lt;?&gt; handledType : mappedTypes.value()) &#123; register(handledType, typeHandler); mappedTypeFound = true; &#125; &#125; // @since 3.1.0 - try to auto-discover the mapped type if (!mappedTypeFound &amp;&amp; typeHandler instanceof TypeReference) &#123; try &#123; TypeReference&lt;T&gt; typeReference = (TypeReference&lt;T&gt;) typeHandler; register(typeReference.getRawType(), typeHandler); mappedTypeFound = true; &#125; catch (Throwable t) &#123; /** * maybe users define the TypeReference with a different * type and are not assignable, so just ignore it */ &#125; &#125; if (!mappedTypeFound) &#123; register((Class&lt;T&gt;) null, typeHandler); &#125; &#125; /** * 配置了typeHandlerhe和javaType */ public &lt;T&gt; void register(Class&lt;T&gt; javaType, TypeHandler&lt;? extends T&gt; typeHandler) &#123; register((Type) javaType, typeHandler); &#125; private &lt;T&gt; void register(Type javaType, TypeHandler&lt;? extends T&gt; typeHandler) &#123; //扫描注解MappedJdbcTypes MappedJdbcTypes mappedJdbcTypes = typeHandler.getClass().getAnnotation(MappedJdbcTypes.class); if (mappedJdbcTypes != null) &#123; for (JdbcType handledJdbcType : mappedJdbcTypes.value()) &#123; register(javaType, handledJdbcType, typeHandler); &#125; if (mappedJdbcTypes.includeNullJdbcType()) &#123; register(javaType, null, typeHandler); &#125; &#125; else &#123; register(javaType, null, typeHandler); &#125; &#125; public &lt;T&gt; void register(TypeReference&lt;T&gt; javaTypeReference, TypeHandler&lt;? extends T&gt; handler) &#123; register(javaTypeReference.getRawType(), handler); &#125; /** * typeHandlerhe、javaType、jdbcType都配置了 */ public &lt;T&gt; void register(Class&lt;T&gt; type, JdbcType jdbcType, TypeHandler&lt;? extends T&gt; handler) &#123; register((Type) type, jdbcType, handler); &#125; /** * 注册typeHandler的核心方法 * 就是向Map新增数据而已 */ private void register(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler) &#123; if (javaType != null) &#123; Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = TYPE_HANDLER_MAP.get(javaType); if (map == null) &#123; map = new HashMap&lt;JdbcType, TypeHandler&lt;?&gt;&gt;(); TYPE_HANDLER_MAP.put(javaType, map); &#125; map.put(jdbcType, handler); if (reversePrimitiveMap.containsKey(javaType)) &#123; register(reversePrimitiveMap.get(javaType), jdbcType, handler); &#125; &#125; ALL_TYPE_HANDLERS_MAP.put(handler.getClass(), handler); &#125; // // REGISTER CLASS // // Only handler type public void register(Class&lt;?&gt; typeHandlerClass) &#123; boolean mappedTypeFound = false; MappedTypes mappedTypes = typeHandlerClass.getAnnotation(MappedTypes.class); if (mappedTypes != null) &#123; for (Class&lt;?&gt; javaTypeClass : mappedTypes.value()) &#123; register(javaTypeClass, typeHandlerClass); mappedTypeFound = true; &#125; &#125; if (!mappedTypeFound) &#123; register(getInstance(null, typeHandlerClass)); &#125; &#125; // java type + handler type public void register(Class&lt;?&gt; javaTypeClass, Class&lt;?&gt; typeHandlerClass) &#123; register(javaTypeClass, getInstance(javaTypeClass, typeHandlerClass)); &#125; // java type + jdbc type + handler type public void register(Class&lt;?&gt; javaTypeClass, JdbcType jdbcType, Class&lt;?&gt; typeHandlerClass) &#123; register(javaTypeClass, jdbcType, getInstance(javaTypeClass, typeHandlerClass)); &#125; // Construct a handler (used also from Builders) @SuppressWarnings("unchecked") public &lt;T&gt; TypeHandler&lt;T&gt; getInstance(Class&lt;?&gt; javaTypeClass, Class&lt;?&gt; typeHandlerClass) &#123; if (javaTypeClass != null) &#123; try &#123; Constructor&lt;?&gt; c = typeHandlerClass.getConstructor(Class.class); return (TypeHandler&lt;T&gt;) c.newInstance(javaTypeClass); &#125; catch (NoSuchMethodException ignored) &#123; // ignored &#125; catch (Exception e) &#123; throw new TypeException("Failed invoking constructor for handler " + typeHandlerClass, e); &#125; &#125; try &#123; Constructor&lt;?&gt; c = typeHandlerClass.getConstructor(); return (TypeHandler&lt;T&gt;) c.newInstance(); &#125; catch (Exception e) &#123; throw new TypeException("Unable to find a usable constructor for " + typeHandlerClass, e); &#125; &#125; /** * 根据指定的pacakge去扫描自定义的typeHander，然后注册 */ public void register(String packageName) &#123; ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;Class&lt;?&gt;&gt;(); resolverUtil.find(new ResolverUtil.IsA(TypeHandler.class), packageName); Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; handlerSet = resolverUtil.getClasses(); for (Class&lt;?&gt; type : handlerSet) &#123; /** * Ignore inner classes and interfaces (including package-info.java) * and abstract classes */ if (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !Modifier.isAbstract(type.getModifiers())) &#123; register(type); &#125; &#125; &#125; // get information /** * 通过configuration对象可以获取已注册的所有typeHandler */ public Collection&lt;TypeHandler&lt;?&gt;&gt; getTypeHandlers() &#123; return Collections.unmodifiableCollection(ALL_TYPE_HANDLERS_MAP.values()); &#125; &#125; 由源码可以看到， mybatis为我们实现了那么多TypeHandler, 随便打开一个TypeHandler，看其源码，都可以看到，它继承自一个抽象类：BaseTypeHandler， 那么我们是不是也能通过继承BaseTypeHandler，从而实现自定义的TypeHandler ? 答案是肯定的， 那么现在下面就为大家演示一下自定义TypeHandler: 自定义TypeHandler1234567891011121314151617181920212223242526272829303132@MappedJdbcTypes(JdbcType.VARCHAR) /*** 此处如果不用注解指定jdbcType, 那么，就可以在配置文件中通过"jdbcType"属性指定，* 同理， javaType 也可通过 @MappedTypes指定*/public class ExampleTypeHandler extends BaseTypeHandler&lt;String&gt; &#123; @Override public void setNonNullParameter(PreparedStatement ps , int i , String parameter , JdbcType jdbcType) throws SQLException &#123; ps.setString(i, parameter); &#125; @Override public String getNullableResult(ResultSet rs , String columnName) throws SQLException &#123; return rs.getString(columnName); &#125; @Override public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123; return rs.getString(columnIndex); &#125; @Override public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123; return cs.getString(columnIndex); &#125;&#125; 然后，就该配置我们的自定义TypeHandler了：1234567891011&lt;configuration&gt; &lt;typeHandlers&gt; &lt;!-- 由于自定义的TypeHandler在定义时已经通过注解指定了jdbcType, 所以此处不用再配置jdbcType --&gt; &lt;typeHandler handler="ExampleTypeHandler"/&gt; &lt;/typeHandlers&gt; ...... &lt;/configuration&gt; 也就是说，我们在自定义TypeHandler的时候，可以在TypeHandler通过@MappedJdbcTypes指定jdbcType, 通过 @MappedTypes 指定javaType, 如果没有使用注解指定，那么我们就需要在配置文件中配置。 好啦，本篇文章到此结束。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列六-objectFactory、plugins、mappers简介与配置]]></title>
    <url>%2F%2Fblog%2Fmybatis-6%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（五）—TypeHandler简介及配置（mybatis源码篇）》简单看了一下TypeHandler， 本次将结束对于mybatis的配置文件的学习， 本次涉及到剩下没提及到的几个节点的配置：objectFactory、databaseIdProvider、plugins、mappers。 那么，接下来，就简单介绍一下这几个配置的作用吧： 1、objectFactory是干什么的？ 需要配置吗？ MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。默认情况下，我们不需要配置，mybatis会调用默认实现的objectFactory。 除非我们要自定义ObjectFactory的实现， 那么我们才需要去手动配置。 那么怎么自定义实现ObjectFactory？ 怎么配置呢？ 自定义ObjectFactory只需要去继承DefaultObjectFactory（是ObjectFactory接口的实现类），并重写其方法即可。具体的，本处不多说，后面再具体讲解。 写好了ObjectFactory, 仅需做如下配置：1234567&lt;configuration&gt; ...... &lt;objectFactory type="org.mybatis.example.ExampleObjectFactory"&gt; &lt;property name="someProperty" value="100"/&gt; &lt;/objectFactory&gt; ...... &lt;/configuration plugin有何作用？ 需要配置吗？ plugins 是一个可选配置。mybatis中的plugin其实就是个interceptor， 它可以拦截Executor 、ParameterHandler 、ResultSetHandler 、StatementHandler 的部分方法，处理我们自己的逻辑。Executor就是真正执行sql语句的东西， ParameterHandler 是处理我们传入参数的，还记得前面讲TypeHandler的时候提到过，mybatis默认帮我们实现了不少的typeHandler, 当我们不显示配置typeHandler的时候，mybatis会根据参数类型自动选择合适的typeHandler执行，其实就是ParameterHandler 在选择。ResultSetHandler 就是处理返回结果的。 怎么自定义plugin? 怎么配置？ 要自定义一个plugin, 需要去实现Interceptor接口， 这儿不细说， 后面实战部分会详细讲解。定义好之后，配置如下：123456789&lt;configuration&gt; ...... &lt;plugins&gt; &lt;plugin interceptor="org.mybatis.example.ExamplePlugin"&gt; &lt;property name="someProperty" value="100"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; ...... &lt;/configuration&gt; mappers, 这下引出mybatis的核心之一了，mappers作用 ? 需要配置吗？ mappers 节点下，配置我们的mapper映射文件， 所谓的mapper映射文件，就是让mybatis 用来建立数据表和javabean映射的一个桥梁。在我们实际开发中，通常一个mapper文件对应一个dao接口， 这个mapper可以看做是dao的实现。所以,mappers必须配置。 那么怎么配置呢？12345678910111213141516171819202122232425&lt;configuration&gt; ...... &lt;mappers&gt; &lt;!-- 第一种方式：通过resource指定 --&gt; &lt;mapper resource="com/dy/dao/userDao.xml"/&gt; &lt;!-- 第二种方式， 通过class指定接口，进而将接口与对应的xml文件形成映射关系 不过，使用这种方式必须保证 接口与mapper文件同名(不区分大小写)， 我这儿接口是UserDao,那么意味着mapper文件为UserDao.xml &lt;mapper class="com.dy.dao.UserDao"/&gt; --&gt; &lt;!-- 第三种方式，直接指定包，自动扫描，与方法二同理 &lt;package name="com.dy.dao"/&gt; --&gt; &lt;!-- 第四种方式：通过url指定mapper文件位置 &lt;mapper url="file://........"/&gt; --&gt; &lt;/mappers&gt; ...... &lt;/configuration&gt; 本篇仅作简单介绍， 更高级的使用以及其实现原理，会在后面的实战部分进行详细讲解。 这几个节点的解析源码，与之前提到的那些节点的解析类似，源码需要的可以从这里看看。 相关节点源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * objectFactory 节点解析 */private void objectFactoryElement(XNode context) throws Exception &#123; if (context != null) &#123; //读取type属性的值， 接下来进行实例化ObjectFactory, 并set进 configuration //到此，简单讲一下configuration这个对象，其实它里面主要保存的都是mybatis的配置 String type = context.getStringAttribute("type"); //读取propertie的值， 根据需要可以配置， mybatis默认实现的objectFactory没有使用properties Properties properties = context.getChildrenAsProperties(); ObjectFactory factory = (ObjectFactory) resolveClass(type).newInstance(); factory.setProperties(properties); configuration.setObjectFactory(factory); &#125; &#125; /** * plugins 节点解析 */ private void pluginElement(XNode parent) throws Exception &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; String interceptor = child.getStringAttribute("interceptor"); Properties properties = child.getChildrenAsProperties(); /** * 由此可见，我们在定义一个interceptor的时候，需要去实现Interceptor, * 这儿先不具体讲，以后会详细讲解 */ Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance(); interceptorInstance.setProperties(properties); configuration.addInterceptor(interceptorInstance); &#125; &#125; &#125; /** * mappers 节点解析 * 这是mybatis的核心之一，这儿先简单介绍，在接下来的文章会对它进行分析 */ private void mapperElement(XNode parent) throws Exception &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; if ("package".equals(child.getName())) &#123; //如果mappers节点的子节点是package, 那么就扫描package下的文件, 注入进configuration String mapperPackage = child.getStringAttribute("name"); configuration.addMappers(mapperPackage); &#125; else &#123; String resource = child.getStringAttribute("resource"); String url = child.getStringAttribute("url"); String mapperClass = child.getStringAttribute("class"); //resource, url, class 三选一 if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) &#123; ErrorContext.instance().resource(resource); InputStream inputStream = Resources.getResourceAsStream(resource); //mapper映射文件都是通过XMLMapperBuilder解析 XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream , configuration , resource , configuration.getSqlFragments()); mapperParser.parse(); &#125; else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) &#123; ErrorContext.instance().resource(url); InputStream inputStream = Resources.getUrlAsStream(url); XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream , configuration , url , configuration.getSqlFragments()); mapperParser.parse(); &#125; else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) &#123; Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass); configuration.addMapper(mapperInterface); &#125; else &#123; throw new BuilderException("A mapper element may only specify a url , resource or class, but not more than one."); &#125; &#125; &#125; &#125; &#125; 本次就简单的到此结束， 从下篇文章开始，将会开始接触到mybatis的核心部分，不过首先还是要讲mapper文件的配置及使用， 并通过源码进一步深入核心。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列七-mapper映射文件配置之insert、update、delete]]></title>
    <url>%2F%2Fblog%2Fmybatis-7%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（六）—objectFactory、plugins、mappers简介与配置》简单地给mybatis的配置画上了一个句号。那么从本篇文章开始，将会介绍mapper映射文件的配置， 这是mybatis的核心之一，一定要学好。在mapper文件中，以mapper作为根节点，其下面可以配置的元素节点有： select, insert, update, delete, cache, cache-ref, resultMap, sql 。 本篇文章将简单介绍 insert, update, delete 的配置及使用，以后会对mybatis的源码进行深入讲解。 相信，看到insert, update, delete， 我们就知道其作用了，顾名思义嘛，myabtis 作为持久层框架，必须要对CRUD啊。 好啦，咱们就先来看看 insert, update, delete 怎么配置， 能配置哪些元素吧： 相关元素配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN" "http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd"&gt; &lt;!-- mapper 为根元素节点， 一个namespace对应一个dao --&gt;&lt;mapper namespace="com.dy.dao.UserDao"&gt; &lt;insert &lt;!-- 1. id （必须配置） id是命名空间中的唯一标识符，可被用来代表这条语句。 一个命名空间（namespace） 对应一个dao接口, 这个id也应该对应dao里面的某个方法（相当于方法的实现），因此id 应该与方法名一致 --&gt; id="insertUser" &lt;!-- 2. parameterType （可选配置, 默认为mybatis自动选择处理） 将要传入语句的参数的完全限定类名或别名， 如果不配置， mybatis会通过ParameterHandler 根据参数类型默认选择合适的typeHandler进行处理 parameterType 主要指定参数类型，可以是int, short, long, string等类型，也可以是复杂类型（如对象） --&gt; parameterType="com.demo.User" &lt;!-- 3. flushCache （可选配置，默认配置为true） 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空， 默认值：true（对应插入、更新和删除语句） --&gt; flushCache="true" &lt;!-- 4. statementType （可选配置，默认配置为PREPARED） STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement， PreparedStatement 或 CallableStatement，默认值：PREPARED。 --&gt; statementType="PREPARED" &lt;!-- 5. keyProperty (可选配置， 默认为unset) （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值， 默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 --&gt; keyProperty="" &lt;!-- 6. keyColumn (可选配置) （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库 （像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。 如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 --&gt; keyColumn="" &lt;!-- 7. useGeneratedKeys (可选配置， 默认为false) （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。 --&gt; useGeneratedKeys="false" &lt;!-- 8. timeout (可选配置， 默认为unset, 依赖驱动) 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 --&gt; timeout="20"&gt; &lt;update id="updateUser" parameterType="com.demo.User" flushCache="true" statementType="PREPARED" timeout="20"&gt; &lt;delete id="deleteUser" parameterType="com.demo.User" flushCache="true" statementType="PREPARED" timeout="20"&gt;&lt;/mapper&gt; 以上就是一个模板配置， 哪些是必要配置，哪些是根据自己实际需求，看一眼就知道了。 下面， 还是用第一篇文章《深入浅出Mybatis系列（一）—Mybatis入门》里面的demo来示例吧： User类1234567891011public class User &#123; private int id; private String name; private String password; private int age; private int deleteFlag; //setter和getter方法省略...&#125; UserDao类12345public interface UserDao &#123; public void insertUser (User user); public void updateUser (User user); public void deleteUser (User user);&#125; userDao.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN" "http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.dy.dao.UserDao"&gt; &lt;!-- 对应userDao中的insertUser方法， --&gt; &lt;insert id="insertUser" parameterType="com.dy.entity.User"&gt; insert into user(id, name, password, age, deleteFlag) values(#&#123;id&#125; , #&#123;name&#125; , #&#123;password&#125; , #&#123;age&#125; , #&#123;deleteFlag&#125;) &lt;/insert&gt; &lt;!-- 对应userDao中的updateUser方法 --&gt; &lt;update id="updateUser" parameterType="com.dy.entity.User"&gt; update user set name = #&#123;name&#125; , password = #&#123;password&#125; , age = #&#123;age&#125; , deleteFlag = #&#123;deleteFlag&#125; where id = #&#123;id&#125;; &lt;/update&gt; &lt;!-- 对应userDao中的deleteUser 方法 --&gt; &lt;delete id="deleteUser" parameterType="com.dy.entity.User"&gt; delete from user where id = #&#123;id&#125;; &lt;/delete&gt;&lt;/mapper&gt; 这样，一个简单的映射关系就建立了。仔细观察上面parameterType, “com.dy.entity.User”，包名要是再长点呢，每次都这样写，写得蛋疼了。别忘了之前讲的 typeAliases（别名）， 那么这个地方，用上别名，岂不是技能跟蛋疼的长长的包名说拜拜了。好啦，咱们配上别名，在哪儿配？ 当然是在mybatis 的全局配置文件（我这儿名字是mybatis-conf.xml）， 不要认为是在mapper的配置文件里面配置哈。 mybatis-conf.xml123456789&lt;typeAliases&gt; &lt;!-- 通过package, 可以直接指定package的名字， mybatis会自动扫描你指定包下面的javabean, 并且默认设置一个别名，默认的名字为： javabean 的首字母小写的非限定类名来作为它的别名。 也可在javabean 加上注解@Alias 来自定义别名， 例如： @Alias(user) &lt;package name="com.dy.entity"/&gt; --&gt; &lt;typeAlias alias="user" type="com.dy.entity.User"/&gt; &lt;/typeAliases&gt; 这样，一个别名就取好了，咱们可以把上面的 com.dy.entity.User 都直接改为user 了。 这多方便呀！ 我这儿数据库用的是mysql, 我把user表的主键id 设置了自动增长， 以上代码运行正常， 那么问题来了（当然，我不是要问学挖掘机哪家强），我要是换成oracle数据库怎么办？ oracle 可是不支持id自增长啊？ 怎么办？请看下面：123456789101112&lt;!-- 对应userDao中的insertUser方法， --&gt; &lt;insert id="insertUser" parameterType="com.dy.entity.User"&gt; &lt;!-- oracle等不支持id自增长的，可根据其id生成策略，先获取id &lt;selectKey resultType="int" order="BEFORE" keyProperty="id"&gt; select seq_user_id.nextval as id from dual &lt;/selectKey&gt; --&gt; insert into user(id, name, password, age, deleteFlag) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;deleteFlag&#125;) &lt;/insert&gt; 同理，如果我们在使用mysql的时候，想在数据插入后返回插入的id, 我们也可以使用 selectKey 这个元素：1234567891011121314151617&lt;!-- 对应userDao中的insertUser方法， --&gt; &lt;insert id="insertUser" parameterType="com.dy.entity.User"&gt; &lt;!-- oracle等不支持id自增长的，可根据其id生成策略，先获取id &lt;selectKey resultType="int" order="BEFORE" keyProperty="id"&gt; select seq_user_id.nextval as id from dual &lt;/selectKey&gt; --&gt; &lt;!-- mysql插入数据后，获取id --&gt; &lt;selectKey keyProperty="id" resultType="int" order="AFTER" &gt; SELECT LAST_INSERT_ID() as id &lt;/selectKey&gt; insert into user(id, name, password, age, deleteFlag) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;deleteFlag&#125;) &lt;/insert&gt; 这儿，我们就简单提一下 这个元素节点吧:1234567891011121314151617181920212223242526&lt;selectKey &lt;!-- selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列， 也可以是逗号分隔的属性名称列表。 --&gt; keyProperty="id" &lt;!-- 结果的类型。MyBatis 通常可以推算出来，但是为了更加确定写上也不会有什么问题。 MyBatis 允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列， 则可以使用一个包含期望属性的 Object 或一个 Map。 --&gt; resultType="int" &lt;!-- 这可以被设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它会首先选择主键， 设置 keyProperty 然后执行插入语句。如果设置为 AFTER，那么先执行插入语句， 然后是 selectKey 元素 - 这和像 Oracle 的数据库相似，在插入语句内部可能有嵌入索引调用。 --&gt; order="BEFORE" &lt;!-- 与前面相同，MyBatis 支持 STATEMENT，PREPARED 和 CALLABLE 语句的映射类型， 分别代表 PreparedStatement 和 CallableStatement 类型。 --&gt; statementType="PREPARED"&gt; 好啦，本篇文章主要介绍了insert, update, delete的配置及用法。 下篇文章将介绍复杂的 select相关的配置及用法， 待这些都讲完后，会先根据源码分析一下mybatis的整个运行流程，然后再深入mybatis的用法。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列八-mapper映射文件配置之select、resultMap]]></title>
    <url>%2F%2Fblog%2Fmybatis-8%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇《深入浅出Mybatis系列（七）—mapper映射文件配置之insert、update、delete》介绍了insert、update、delete的用法，本篇将介绍select、resultMap的用法。select无疑是我们最常用，也是最复杂的，mybatis通过resultMap能帮助我们很好地进行高级映射。下面就开始看看select 以及 resultMap的用法： 先看select的配置吧： select配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;select &lt;!-- 1. id （必须配置） id是命名空间中的唯一标识符，可被用来代表这条语句。 一个命名空间（namespace） 对应一个dao接口, 这个id也应该对应dao里面的某个方法（相当于方法的实现），因此id 应该与方法名一致 --&gt; id="selectPerson" &lt;!-- 2. parameterType （可选配置, 默认为mybatis自动选择处理） 将要传入语句的参数的完全限定类名或别名， 如果不配置，mybatis会通过ParameterHandler 根据参数类型默认选择合适的typeHandler进行处理 parameterType 主要指定参数类型，可以是int, short, long, string等类型，也可以是复杂类型（如对象） --&gt; parameterType="int" &lt;!-- 3. resultType (resultType 与 resultMap 二选一配置) resultType用以指定返回类型，指定的类型可以是基本类型，可以是java容器，也可以是javabean --&gt; resultType="hashmap" &lt;!-- 4. resultMap (resultType 与 resultMap 二选一配置) resultMap用于引用我们通过 resultMap标签定义的映射类型， 这也是mybatis组件高级复杂映射的关键 --&gt; resultMap="personResultMap" &lt;!-- 5. flushCache (可选配置) 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false --&gt; flushCache="false" &lt;!-- 6. useCache (可选配置) 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true --&gt; useCache="true" &lt;!-- 7. timeout (可选配置) 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动） --&gt; timeout="10000" &lt;!-- 8. fetchSize (可选配置) 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动) --&gt; fetchSize="256" &lt;!-- 9. statementType (可选配置) STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED --&gt; statementType="PREPARED" &lt;!-- 10. resultSetType (可选配置) FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个， 默认值为 unset （依赖驱动） --&gt; resultSetType="FORWARD_ONLY"&gt; 配置看起来总是这么多，不过实际常用的配置也就那么几个， 根据自己的需要吧，上面都已注明是否必须配置。 下面还是上个demo及时练练手吧! 数据库：新增两张表（t_course, t_student）,以下为相关实体类。 Course.java1234567public class Course &#123; private int id; private String name; private int deleteFlag; //setter和getter方法省略...&#125; Student.java123456789public class Student &#123; private int id; private String idCard; private String name; private List&lt;Course&gt; courseList; private int deleteFlag; //setter和getter方法省略...&#125; CourseDao.java123public interface CourseDao &#123; public Course findCourseById(int courseId); &#125; StudentDao.java123public interface StudentDao &#123; public Student findStudentById(String idCard);&#125; courseDao.xml12345678910111213141516171819202122232425&lt;mapper namespace="com.dy.dao.CourseDao"&gt; &lt;!-- 1.此处直接将resultType 设置为course, 一看就知道我设置了别名吧， 如果没有设置别名，那么resultType = com.dy.entity.Course。 2.可能细心的你会发现：Course.java中的属性名与数据库字段名不一致，下面， 我就在sql语句中用了as, 使之匹配，当然方法不止一种，在学习了resultMap之后， 你能看到一种更直观优雅的方式去将javabean中的属性与数据库字段名保持一致 3.findCourseById 与CourseDao中findCourseById方法对应， 那么传入的参数名称以及类型也应该保持对应关系。 4.可以看到，在sql语句中，通过#&#123;&#125;表达式可以获取参数。 5.下面这条sql语句，实际上的形式是怎么样的？还记得之前说过， mybatis默认为preparedStatement吧，那么，用我们jdbc代码来看，它其实就是： select course_id as id, course_name as name, course_delete_flg as deleteFlag from t_course where course_id=? --&gt; &lt;select id="findCourseById" resultType="course" &gt; select course_id as id , course_name as name , course_delete_flg as deleteFlag from t_course where course_id=#&#123;courseId&#125; &lt;/select&gt; &lt;/mapper&gt; CourseDaoTest.java123456789101112131415161718192021222324public class CourseDaoTest &#123; @Test public void findCourseById() &#123; SqlSessionFactory sqlSessionFactory = getSessionFactory(); SqlSession sqlSession = sqlSessionFactory.openSession(); CourseDao courseDao = sqlSession.getMapper(CourseDao.class); Course course = courseDao.findCourseById(1); &#125; //Mybatis 通过SqlSessionFactory获取SqlSession, 然后才能通过SqlSession与数据库进行交互 private static SqlSessionFactory getSessionFactory() &#123; SqlSessionFactory sessionFactory = null; String resource = "mybatis-conf.xml"; try &#123; sessionFactory = new SqlSessionFactoryBuilder().build(Resources .getResourceAsReader(resource)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return sessionFactory; &#125; &#125; 上面的示例，我们针对course, 简单演示了 select的用法， 不过有个问题值得思考： 一个student可以对应多个course, 那么，在mybatis中如何处理这种一对多， 甚至于多对多，一对一的关系呢？ 这儿，就不得不提到 resultMap 这个东西， mybatis的resultMap功能可谓十分强大，能够处理复杂的关系映射， 那么resultMap 该怎么配置呢？ 别急，这就来了： resultMap配置12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 1.type 对应类型，可以是javabean, 也可以是其它 2.id 必须唯一， 用于标示这个resultMap的唯一性，在使用resultMap的时候，就是通过id指定 --&gt; &lt;resultMap type="" id=""&gt; &lt;!-- id, 唯一性，注意啦，这个id用于标示这个javabean对象的唯一性， 不一定会是数据库的主键（不要把它理解为数据库对应表的主键） property属性对应javabean的属性名，column对应数据库表的列名 （这样，当javabean的属性与数据库对应表的列名不一致的时候，就能通过指定这个保持正常映射了） --&gt; &lt;id property="" column=""/&gt; &lt;!-- result与id相比， 对应普通属性 --&gt; &lt;result property="" column=""/&gt; &lt;!-- constructor对应javabean中的构造方法 --&gt; &lt;constructor&gt; &lt;!-- idArg 对应构造方法中的id参数 --&gt; &lt;idArg column=""/&gt; &lt;!-- arg 对应构造方法中的普通参数 --&gt; &lt;arg column=""/&gt; &lt;/constructor&gt; &lt;!-- collection，对应javabean中容器类型, 是实现一对多的关键 property 为javabean中容器对应字段名 column 为体现在数据库中列名 ofType 就是指定javabean中容器指定的类型 --&gt; &lt;collection property="" column="" ofType=""&gt;&lt;/collection&gt; &lt;!-- association 为关联关系，是实现N对一的关键。 property 为javabean中容器对应字段名 column 为体现在数据库中列名 javaType 指定关联的类型 --&gt; &lt;association property="" column="" javaType=""&gt;&lt;/association&gt; &lt;/resultMap&gt; 好啦，知道resutMap怎么配置后，咱们立即接着上面的demo来练习一下吧： 下面是用resultMap处理一对多关系的映射的示例 一个student对应多个course， 典型的一对多，咱们就来看看mybatis怎么配置这种映射吧： studentDao.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;mapper namespace="com.dy.dao.StudentDao"&gt; &lt;!-- 这儿定义一个resultMap --&gt; &lt;resultMap type="student" id="studentMap"&gt; &lt;!-- 数据库中主键是id, 但是我这儿却是指定idCard为主键，为什么？ 刚刚讲了，id用来表示唯一性， 我们可以认为只要idCard一样，那么他就是同一个学生。 如果此处用数据库中id， 那么mybatis将会认为数据库中每条记录都是一个student, 这显然不符合逻辑 --&gt; &lt;id property="idCard" column="stu_id_card"/&gt; &lt;result property="id" column="stu_id"/&gt; &lt;result property="name" column="stu_name"/&gt; &lt;result property="deleteFlag" column="stu_delete_flg"/&gt; &lt;!-- 这儿就是实现一对多的关键。 在Student中，courseList为List&lt;Course&gt;, 因此， ofType也应该与之对应（当然，我用了别名，不然要蛋疼的写全名了）。 collection的子标签是在指定Course的映射关系 （由于Course的javabean的属性名与数据库的列名不一致） --&gt; &lt;collection property="courseList" column="stu_course_id" ofType="Course"&gt; &lt;id property="id" column="course_id"/&gt; &lt;result property="name" column="course_name"/&gt; &lt;result property="deleteFlag" column="course_delete_flg"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 这儿将返回类型设置成了上面指定的studentMap --&gt; &lt;select id="findStudentById" resultMap="studentMap"&gt; SELECT s.*, c.* FROM t_student s LEFT JOIN t_course c ON s.stu_course_id=c.course_id WHERE s.stu_id_card=#&#123;idCard&#125; &lt;/select&gt; &lt;/mapper&gt; StudentDaoTest.java12345678910111213141516171819202122232425262728public class StudentDaoTest &#123; @Test public void findCourseById() &#123; SqlSessionFactory sqlSessionFactory = getSessionFactory(); SqlSession sqlSession = sqlSessionFactory.openSession(); StudentDao studentDao = sqlSession.getMapper(StudentDao.class); Student student = studentDao.findStudentById("20140101"); List&lt;Course&gt; courseList = student.getCourseList(); for (Course course: courseList) &#123; System.out.println(course.getId() + " " + course.getName()); &#125; &#125; //Mybatis 通过SqlSessionFactory获取SqlSession, 然后才能通过SqlSession与数据库进行交互 private static SqlSessionFactory getSessionFactory() &#123; SqlSessionFactory sessionFactory = null; String resource = "mybatis-conf.xml"; try &#123; sessionFactory = new SqlSessionFactoryBuilder().build(Resources .getResourceAsReader(resource)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return sessionFactory; &#125; &#125; 相信通过以上demo， 大家也能够使用mybatis的select 和 resultMap的用法了。上面demo只演示了一对多的映射，其实多对一、多对多也与它类似，所以我就没演示了，有兴趣的可以自己动手再做做。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列三-配置详解之properties与environments（mybatis源码篇）]]></title>
    <url>%2F%2Fblog%2Fmybatis-3%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（二）—配置简介（mybatis源码篇）》我们通过对mybatis源码的简单分析，可看出，在mybatis配置文件中，在configuration根节点下面，可配置properties、typeAliases、plugins、objectFactory、objectWrapperFactory、settings、environments、databaseIdProvider、typeHandlers、mappers这些节点。那么本次，就会先介绍properties节点和environments节点。 为了让大家能够更好地阅读mybatis源码，我先简单的给大家示例一下properties的使用方法。 properties节点1234567891011&lt;configuration&gt; &lt;!-- 方法一：从外部指定properties配置文件, 除了使用resource属性指定外，还可通过url属性指定url &lt;properties resource="dbConfig.properties"&gt;&lt;/properties&gt; --&gt; &lt;!-- 方法二： 直接配置为xml --&gt; &lt;properties&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test1"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/properties&gt; 那么，我要是 两种方法都同时用了，那么哪种方法优先？当以上两种方法都xml配置优先， 外部指定properties配置其次。至于为什么，接下来的源码分析会提到，请留意一下。 再看一下envirements元素节点的使用方法吧. envirements节点12345678910111213141516171819202122232425262728293031323334&lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 如果上面没有指定数据库配置的properties文件，那么此处可以这样直接配置 &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test1"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; --&gt; &lt;!-- 上面指定了数据库配置文件， 配置文件里面也是对应的这四个属性 --&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!-- 我再指定一个environment --&gt; &lt;environment id="test"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;!-- 与上面的url不一样 --&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/demo"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; environments元素节点可以配置多个environment子节点， 怎么理解呢？ 假如我们系统的开发环境和正式环境所用的数据库不一样（这是肯定的）， 那么可以设置两个environment, 两个id分别对应开发环境（dev）和正式环境（final），那么通过配置environments的default属性就能选择对应的environment了， 例如，我将environments的deault属性的值配置为dev, 那么就会选择dev的environment。 至于这个是怎么实现的， 下面源码就会讲。 好啦，上面简单给大家介绍了一下properties 和 environments 的配置， 接下来就正式开始看源码了： 上次我们说过mybatis 是通过XMLConfigBuilder这个类在解析mybatis配置文件的，那么本次就接着看看XMLConfigBuilder对于properties和environments的解析。 XMLConfigBuilder源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public class XMLConfigBuilder extends BaseBuilder &#123; private boolean parsed; //xml解析器 private XPathParser parser; private String environment; /** * 上次说到这个方法是在解析mybatis配置文件中能配置的元素节点 * 今天首先要看的就是properties节点和environments节点 */ private void parseConfiguration(XNode root) &#123; try &#123; //解析properties元素 //issue #117 read properties first propertiesElement(root.evalNode("properties")); typeAliasesElement(root.evalNode("typeAliases")); pluginElement(root.evalNode("plugins")); objectFactoryElement(root.evalNode("objectFactory")); objectWrapperFactoryElement(root.evalNode("objectWrapperFactory")); settingsElement(root.evalNode("settings")); //解析environments元素 // read it after objectFactory and objectWrapperFactory issue #631 environmentsElement(root.evalNode("environments")); databaseIdProviderElement(root.evalNode("databaseIdProvider")); typeHandlerElement(root.evalNode("typeHandlers")); mapperElement(root.evalNode("mappers")); &#125; catch (Exception e) &#123; throw new BuilderException("Error parsing SQL Mapper Configuration.Cause: " + e, e); &#125; &#125; //下面就看看解析properties的具体方法 private void propertiesElement(XNode context) throws Exception &#123; if (context != null) &#123; /** * 将子节点的 name 以及value属性set进properties对象 * 这儿可以注意一下顺序，xml配置优先， 外部指定properties配置其次 */ Properties defaults = context.getChildrenAsProperties(); //获取properties节点上 resource属性的值 String resource = context.getStringAttribute("resource"); //获取properties节点上 url属性的值, resource和url不能同时配置 String url = context.getStringAttribute("url"); if (resource != null &amp;&amp; url != null) &#123; throw new BuilderException("The properties element cannot specify both a URL and a resource based property file reference. Please specify one or the other."); &#125; //把解析出的properties文件set进Properties对象 if (resource != null) &#123; defaults.putAll(Resources.getResourceAsProperties(resource)); &#125; else if (url != null) &#123; defaults.putAll(Resources.getUrlAsProperties(url)); &#125; /** * 将configuration对象中已配置的Properties属性与刚刚解析的融合 * configuration这个对象会装载所解析mybatis配置文件的所有节点元素， * 以后也会频频提到这个对象，既然configuration对象用有一系列的get/set方法, * 那是否就标志着我们可以使用java代码直接配置？ * 答案是肯定的， 不过使用配置文件进行配置，优势不言而喻 */ Properties vars = configuration.getVariables(); if (vars != null) &#123; defaults.putAll(vars); &#125; //把装有解析配置propertis对象set进解析器， 因为后面可能会用到 parser.setVariables(defaults); //set进configuration对象 configuration.setVariables(defaults); &#125; &#125; //下面再看看解析enviroments元素节点的方法 private void environmentsElement(XNode context) throws Exception &#123; if (context != null) &#123; if (environment == null) &#123; //解析environments节点的default属性的值 //例如: &lt;environments default="development"&gt; environment = context.getStringAttribute("default"); &#125; //递归解析environments子节点 for (XNode child : context.getChildren()) &#123; /** * &lt;environment id="development"&gt;, 只有enviroment节点有id属性， * 那么这个属性有何作用？environments节点下可以拥有多个environment子节点 * 类似于这样： * &lt;environments default="development"&gt; * &lt;environment id="development"&gt;...&lt;/environment&gt; * &lt;environment id="test"&gt;...&lt;/environment&gt; * &lt;/environments&gt; * 意思就是我们可以对应多个环境，比如开发环境，测试环境等， * 由environments的default属性,去选择对应的enviroment */ String id = child.getStringAttribute("id"); //isSpecial就是根据由environments的default属性去选择对应的enviroment if (isSpecifiedEnvironment(id)) &#123; /** * 事务，mybatis有两种：JDBC 和 MANAGED, 配置为JDBC则直接使用JDBC的事务， * 配置为MANAGED则是将事务托管给容器 */ TransactionFactory txFactory =transactionManagerElement(child.evalNode("transactionManager")); /** * enviroment节点下面就是dataSource节点了，解析dataSource节点 * 下面会贴出解析dataSource的具体方法 */ DataSourceFactory dsFactory = dataSourceElement(child.evalNode("dataSource")); DataSource dataSource = dsFactory.getDataSource(); Environment.Builder environmentBuilder=new Environment.Builder(id) .transactionFactory(txFactory) .dataSource(dataSource); //老规矩，会将dataSource设置进configuration对象 configuration.setEnvironment(environmentBuilder.build()); &#125; &#125; &#125; &#125; //下面看看dataSource的解析方法 private DataSourceFactory dataSourceElement(XNode context) throws Exception &#123; if (context != null) &#123; //dataSource的连接池 String type = context.getStringAttribute("type"); //子节点 name, value属性set进一个properties对象 Properties props = context.getChildrenAsProperties(); //创建dataSourceFactory DataSourceFactory factory = (DataSourceFactory) resolveClass(type).newInstance(); factory.setProperties(props); return factory; &#125; throw new BuilderException("Environment declaration requires a DataSourceFactory."); &#125; &#125; 通过以上对mybatis源码的解读，相信大家对mybatis的配置又有了一个深入的认识。 还有一个问题， 上面我们看到，在配置dataSource的时候使用了 ${driver} 这种表达式， 这种形式是怎么解析的？其实，是通过PropertyParser这个类解析： PropertyParser源码1234567891011121314151617181920212223242526/** * 这个类解析$&#123;&#125;这种形式的表达式 */public class PropertyParser &#123; public static String parse(String string, Properties variables) &#123; VariableTokenHandler handler = new VariableTokenHandler(variables); GenericTokenParser parser = new GenericTokenParser("$&#123;", "&#125;", handler); return parser.parse(string); &#125; private static class VariableTokenHandler implements TokenHandler &#123; private Properties variables; public VariableTokenHandler(Properties variables) &#123; this.variables = variables; &#125; public String handleToken(String content) &#123; if (variables != null &amp;&amp; variables.containsKey(content)) &#123; return variables.getProperty(content); &#125; return "$&#123;" + content + "&#125;"; &#125; &#125;&#125; 好啦，以上就是对于properties 和 environments元素节点的分析，比较重要的都在对于源码的注释中标出。本次文章到此结束，接下来的文章会继续分析其他节点的配置。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列四-配置详解之typeAliases别名（mybatis源码篇）]]></title>
    <url>%2F%2Fblog%2Fmybatis-4%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（三）—配置详解之properties与environments（mybatis源码篇）》 介绍了properties与environments， 本篇继续讲剩下的配置节点之一：typeAliases。 typeAliases节点主要用来设置别名，其实这是挺好用的一个功能， 通过配置别名，我们不用再指定完整的包名，并且还能取别名。 例如： 我们在使用 com.demo.entity. UserEntity 的时候，我们可以直接配置一个别名user, 这样以后在配置文件中要使用到com.demo.entity. UserEntity的时候，直接使用User即可。 就以上例为例，我们来实现一下，看看typeAliases的配置方法: typeAliases配置1234567891011121314&lt;configuration&gt; &lt;typeAliases&gt; &lt;!-- 通过package, 可以直接指定package的名字， mybatis会自动扫描你指定包下面的javabean, 并且默认设置一个别名，默认的名字为： javabean 的首字母小写的非限定类名来作为它的别名。 也可在javabean 加上注解@Alias 来自定义别名， 例如： @Alias(user) &lt;package name="com.dy.entity"/&gt; --&gt; &lt;typeAlias alias="UserEntity" type="com.dy.entity.User"/&gt; &lt;/typeAliases&gt; ...... &lt;/configuration&gt; 再写一段测试代码，看看有没生效：（我只写一段伪代码）123456Configuration con = sqlSessionFactory.getConfiguration();Map&lt;String, Class&lt;?&gt;&gt; typeMap = con.getTypeAliasRegistry().getTypeAliases();for(Entry&lt;String, Class&lt;?&gt;&gt; entry: typeMap.entrySet()) &#123; System.out.println(entry.getKey() + " ================&gt; " + entry.getValue().getSimpleName());&#125; 上面给大家简单介绍了typeAliases的用法， 接下来就看看Mybatis中的源码了。 老规矩，先从对xml的解析讲起： typeAliases源码123456789101112131415161718192021222324252627282930313233/** * 解析typeAliases节点 */private void typeAliasesElement(XNode parent) &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; //如果子节点是package, 那么就获取package节点的name属性， mybatis会扫描指定的package if ("package".equals(child.getName())) &#123; String typeAliasPackage = child.getStringAttribute("name"); /** * TypeAliasRegistry 负责管理别名， 这儿就是通过TypeAliasRegistry 进行别名注册， * 下面就会看看TypeAliasRegistry源码 */ configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage); &#125; else &#123; //如果子节点是typeAlias节点，那么就获取alias属性和type的属性值 String alias = child.getStringAttribute("alias"); String type = child.getStringAttribute("type"); try &#123; Class&lt;?&gt; clazz = Resources.classForName(type); if (alias == null) &#123; typeAliasRegistry.registerAlias(clazz); &#125; else &#123; typeAliasRegistry.registerAlias(alias, clazz); &#125; &#125; catch (ClassNotFoundException e) &#123; throw new BuilderException("Error registering typeAlias for '" + alias + "'. Cause: " + e, e); &#125; &#125; &#125; &#125; &#125; 重要的源码在这儿! TypeAliasRegistry源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162public class TypeAliasRegistry &#123; /** * 这就是核心所在啊， 原来别名就仅仅通过一个HashMap来实现， * key为别名， value就是别名对应的类型（class对象） */ private final Map&lt;String, Class&lt;?&gt;&gt; TYPE_ALIASES = new HashMap&lt;String, Class&lt;?&gt;&gt;(); /** * 以下就是mybatis默认为我们注册的别名 */ public TypeAliasRegistry() &#123; registerAlias("string", String.class); registerAlias("byte", Byte.class); registerAlias("long", Long.class); registerAlias("short", Short.class); registerAlias("int", Integer.class); registerAlias("integer", Integer.class); registerAlias("double", Double.class); registerAlias("float", Float.class); registerAlias("boolean", Boolean.class); registerAlias("byte[]", Byte[].class); registerAlias("long[]", Long[].class); registerAlias("short[]", Short[].class); registerAlias("int[]", Integer[].class); registerAlias("integer[]", Integer[].class); registerAlias("double[]", Double[].class); registerAlias("float[]", Float[].class); registerAlias("boolean[]", Boolean[].class); registerAlias("_byte", byte.class); registerAlias("_long", long.class); registerAlias("_short", short.class); registerAlias("_int", int.class); registerAlias("_integer", int.class); registerAlias("_double", double.class); registerAlias("_float", float.class); registerAlias("_boolean", boolean.class); registerAlias("_byte[]", byte[].class); registerAlias("_long[]", long[].class); registerAlias("_short[]", short[].class); registerAlias("_int[]", int[].class); registerAlias("_integer[]", int[].class); registerAlias("_double[]", double[].class); registerAlias("_float[]", float[].class); registerAlias("_boolean[]", boolean[].class); registerAlias("date", Date.class); registerAlias("decimal", BigDecimal.class); registerAlias("bigdecimal", BigDecimal.class); registerAlias("biginteger", BigInteger.class); registerAlias("object", Object.class); registerAlias("date[]", Date[].class); registerAlias("decimal[]", BigDecimal[].class); registerAlias("bigdecimal[]", BigDecimal[].class); registerAlias("biginteger[]", BigInteger[].class); registerAlias("object[]", Object[].class); registerAlias("map", Map.class); registerAlias("hashmap", HashMap.class); registerAlias("list", List.class); registerAlias("arraylist", ArrayList.class); registerAlias("collection", Collection.class); registerAlias("iterator", Iterator.class); registerAlias("ResultSet", ResultSet.class); &#125; /** * 处理别名， 直接从保存有别名的hashMap中取出即可 */ @SuppressWarnings("unchecked") public &lt;T&gt; Class&lt;T&gt; resolveAlias(String string) &#123; try &#123; if (string == null) return null; String key = string.toLowerCase(Locale.ENGLISH); // issue #748 Class&lt;T&gt; value; if (TYPE_ALIASES.containsKey(key)) &#123; value = (Class&lt;T&gt;) TYPE_ALIASES.get(key); &#125; else &#123; value = (Class&lt;T&gt;) Resources.classForName(string); &#125; return value; &#125; catch (ClassNotFoundException e) &#123; throw new TypeException("Could not resolve type alias '" + string + "'. Cause: " + e, e); &#125; &#125; /** * 配置文件中配置为package的时候， 会调用此方法，根据配置的报名去扫描javabean ， * 然后自动注册别名，默认会使用 Bean 的首字母小写的非限定类名来作为它的别名 * 也可在javabean 加上注解@Alias 来自定义别名， 例如： @Alias(user) */ public void registerAliases(String packageName)&#123; registerAliases(packageName, Object.class); &#125; public void registerAliases(String packageName, Class&lt;?&gt; superType)&#123; ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;Class&lt;?&gt;&gt;(); resolverUtil.find(new ResolverUtil.IsA(superType), packageName); Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; typeSet = resolverUtil.getClasses(); for(Class&lt;?&gt; type : typeSet)&#123; // Ignore inner classes and interfaces (including package-info.java) // Skip also inner classes. See issue #6 if (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !type.isMemberClass()) &#123; registerAlias(type); &#125; &#125; &#125; public void registerAlias(Class&lt;?&gt; type) &#123; String alias = type.getSimpleName(); Alias aliasAnnotation = type.getAnnotation(Alias.class); if (aliasAnnotation != null) &#123; alias = aliasAnnotation.value(); &#125; registerAlias(alias, type); &#125; /** * 这就是注册别名的本质方法， 其实就是向保存别名的hashMap新增值而已， * 呵呵，别名的实现太简单了，对吧 */ public void registerAlias(String alias, Class&lt;?&gt; value) &#123; if (alias == null) throw new TypeException("The parameter alias cannot be null"); String key = alias.toLowerCase(Locale.ENGLISH); // issue #748 if (TYPE_ALIASES.containsKey(key) &amp;&amp; TYPE_ALIASES.get(key) != null &amp;&amp; !TYPE_ALIASES.get(key).equals(value)) &#123; throw new TypeException("The alias '" + alias + "' is already mapped to the value '" + TYPE_ALIASES.get(key).getName() + "'."); &#125; TYPE_ALIASES.put(key, value); &#125; public void registerAlias(String alias, String value) &#123; try &#123; registerAlias(alias, Resources.classForName(value)); &#125; catch (ClassNotFoundException e) &#123; throw new TypeException("Error registering type alias " +alias+" for "+value+". Cause: " + e, e); &#125; &#125; /** * 获取保存别名的HashMap, Configuration对象持有对TypeAliasRegistry的引用， * 因此，如果需要，我们可以通过Configuration对象获取 */ public Map&lt;String, Class&lt;?&gt;&gt; getTypeAliases() &#123; return Collections.unmodifiableMap(TYPE_ALIASES); &#125;&#125; 由源码可见，设置别名的原理就这么简单，Mybatis默认给我们设置了不少别名，在上面代码中都可以见到。 好啦，本篇内容就是这么简单，到此为止。 下篇将继续讲解还没讲完的配置节点。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列二-配置简介（mybatis源码篇）]]></title>
    <url>%2F%2Fblog%2Fmybatis-2%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（一）—Mybatis入门》， 写了一个Demo简单体现了一下Mybatis的流程。本次，将简单介绍一下Mybatis的配置文件： 上次例子中，我们以 SqlSessionFactoryBuilder 去创建 SqlSessionFactory, 那么，我们就先从SqlSessionFactoryBuilder入手， 咱们先看看源码是怎么实现的： SqlSessionFactoryBuilder源码123456789101112131415161718192021222324252627282930313233343536373839404142434445public class SqlSessionFactoryBuilder &#123; /** * Reader读取mybatis配置文件，传入构造方法 * 除了Reader外，其实还有对应的inputStream作为参数的构造方法， * 这也体现了mybatis配置的灵活性 */ public SqlSessionFactory build(Reader reader) &#123; return build(reader, null, null); &#125; public SqlSessionFactory build(Reader reader, String environment) &#123; return build(reader, environment, null); &#125; //mybatis配置文件 + properties, 此时mybatis配置文件中可以不配置properties，也能使用$&#123;&#125;形式 public SqlSessionFactory build(Reader reader, Properties properties) &#123; return build(reader, null, properties); &#125; //通过XMLConfigBuilder解析mybatis配置，然后创建SqlSessionFactory对象 public SqlSessionFactory build(Reader reader , String environment , Properties properties) &#123; try &#123; XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties); //下面看看这个方法的源码 return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException("Error building SqlSession.", e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; reader.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125; public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config); &#125;&#125; 通过源码，我们可以看到SqlSessionFactoryBuilder 通过XMLConfigBuilder 去解析我们传入的mybatis的配置文件， 下面就接着看看 XMLConfigBuilder 部分源码： XMLConfigBuilder源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * mybatis 配置文件解析 */public class XMLConfigBuilder extends BaseBuilder &#123; public XMLConfigBuilder(InputStream inputStream,String environment,Properties props)&#123; this(new XPathParser(inputStream, true, props , new XMLMapperEntityResolver()), environment, props); &#125; private XMLConfigBuilder(XPathParser parser, String environment, Properties props) &#123; super(new Configuration()); ErrorContext.instance().resource("SQL Mapper Configuration"); this.configuration.setVariables(props); this.parsed = false; this.environment = environment; this.parser = parser; &#125; //外部调用此方法对mybatis配置文件进行解析 public Configuration parse() &#123; if (parsed) &#123; throw new BuilderException("Each XMLConfigBuilder can only be used once."); &#125; parsed = true; //从根节点configuration parseConfiguration(parser.evalNode("/configuration")); return configuration; &#125; //此方法就是解析configuration节点下的子节点 //由此也可看出，我们在configuration下面能配置的节点为以下10个节点 private void parseConfiguration(XNode root) &#123; try &#123; //issue #117 read properties first propertiesElement(root.evalNode("properties")); typeAliasesElement(root.evalNode("typeAliases")); pluginElement(root.evalNode("plugins")); objectFactoryElement(root.evalNode("objectFactory")); objectWrapperFactoryElement(root.evalNode("objectWrapperFactory")); settingsElement(root.evalNode("settings")); // read it after objectFactory and objectWrapperFactory issue #631 environmentsElement(root.evalNode("environments")); databaseIdProviderElement(root.evalNode("databaseIdProvider")); typeHandlerElement(root.evalNode("typeHandlers")); mapperElement(root.evalNode("mappers")); &#125; catch (Exception e) &#123; throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e); &#125; &#125;&#125; 通过以上源码，我们就能看出，在mybatis的配置文件中： configuration节点为根节点。 在configuration节点之下，我们可以配置10个子节点， 分别为：properties、typeAliases、plugins、objectFactory、objectWrapperFactory、settings、environments、databaseIdProvider、typeHandlers、mappers。 本篇文章就先只介绍这些内容，接下来的文章将依次分析解析这个10个节点中比较重要的几个节点的源码，看看在解析这些节点的时候，到底做了些什么。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列一-Mybatis入门]]></title>
    <url>%2F%2Fblog%2Fmybatis-1%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 最近两年 springmvc + mybatis 的在这种搭配还是蛮火的，楼主我呢，也从来没真正去接触过mybatis, 趁近日得闲， 就去学习一下mybatis吧。 本次拟根据自己的学习进度，做一次关于mybatis 的一系列教程， 记录自己的学习历程， 同时也给还没接触过mybatis的朋友探一次道。本系列教程拟 由浅（使用）入深（分析mybatis源码实现），故可能需要好长几天才能更新完。好啦，下面就开始本次的mybatis 学习之旅啦， 本次为第一篇教程， 就先简单地写个demo, 一起来认识一下mybatis吧。 为了方便，我使用了maven，至于maven怎么使用，我就不做介绍了。没用过maven的，也不影响阅读。 Mybatis环境搭建新建web项目， 添加依赖包：mybatis包、数据库驱动包(我使用的是mysql)、日志包(我使用的是log4j)， 由于我的是maven项目， 那么添加依赖包就简单了，直接在pom.xml添加依赖即可。 pom.xml 12345678910111213141516171819202122232425262728293031&lt;dependencies&gt; &lt;!-- 添加junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 添加log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置mybatis在classpath建立一个用于配置log4j的配置文件log4j.properties, 再建立一个用于配置Mybatis的配置文件configuration.xml（文件可随便命名）。log4j的配置，我就不多说，这儿主要说一下configuration.xml: configuration.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 指定properties配置文件， 我这里面配置的是数据库相关 --&gt; &lt;properties resource="dbConfig.properties"&gt;&lt;/properties&gt; &lt;!-- 指定Mybatis使用log4j --&gt; &lt;settings&gt; &lt;setting name="logImpl" value="LOG4J"/&gt; &lt;/settings&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 如果上面没有指定数据库配置的properties文件，那么此处可以这样直接配置 &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test1"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; --&gt; &lt;!-- 上面指定了数据库配置文件， 配置文件里面也是对应的这四个属性 --&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射文件，mybatis精髓， 后面才会细讲 --&gt; &lt;mappers&gt; &lt;mapper resource="com/dy/dao/userDao-mapping.xml"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 开始写Demo首先，在mysql数据库test1建立一张表user。 先编写一个实体类User: User类用于与User表相对应。 User12345678910public class User &#123; private int id; private String name; private String password; private int age; private int deleteFlag; //setter和getter方法省略...&#125; 再编写一个UserDao 接口： UserDao12345public interface UserDao &#123; public void insert(User user); public User findUserById (int userId); public List&lt;User&gt; findAllUsers();&#125; 再编写一个userDao-mapping.xml （可随便命名）: userDao-mapping.xml123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN" "http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.dy.dao.UserDao"&gt; &lt;select id="findUserById" resultType="com.dy.entity.User" &gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; userDao-mapping.xml相当于是UserDao的实现， 同时也将User实体类与数据表User成功关联起来。 测试代码DemoUserDaoTest12345678910111213141516171819202122public class UserDaoTest &#123; @Test public void findUserById() &#123; SqlSession sqlSession = getSessionFactory().openSession(); UserDao userMapper = sqlSession.getMapper(UserDao.class); User user = userMapper.findUserById(2); Assert.assertNotNull("没找到数据", user); &#125; //Mybatis 通过SqlSessionFactory获取SqlSession, 然后才能通过SqlSession与数据库进行交互 private static SqlSessionFactory getSessionFactory() &#123; SqlSessionFactory sessionFactory = null; String resource = "configuration.xml"; try &#123; sessionFactory = new SqlSessionFactoryBuilder().build(Resources .getResourceAsReader(resource)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return sessionFactory; &#125; &#125; 好啦，这样一个简单的mybatis 的demo就能成功运行啦。通过这个demo, 应该你就也能初步看出mybatis的运行机制，如果不清楚，也没关系。从下一篇文章开始，才开始正式讲解mybatis。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列十-SQL执行流程分析（源码篇）]]></title>
    <url>%2F%2Fblog%2Fmybatis-10%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 最近太忙了，一直没时间继续更新博客，今天忙里偷闲继续我的Mybatis学习之旅。在前九篇中，介绍了mybatis的配置以及使用， 那么本篇将走进mybatis的源码，分析mybatis 的执行流程。 SqlSessionFactory 与 SqlSession通过前面的章节对于mybatis 的介绍及使用，大家都能体会到SqlSession的重要性了吧， 没错，从表面上来看，咱们都是通过SqlSession去执行sql语句（注意：是从表面看，实际的待会儿就会讲）。那么咱们就先看看是怎么获取SqlSession的吧： 首先，SqlSessionFactoryBuilder去读取mybatis的配置文件，然后build一个DefaultSqlSessionFactory。源码如下：12345678910111213141516171819202122232425262728/*** 一系列的构造方法最终都会调用本方法（配置文件为Reader时会调用本方法，还有一个InputStream方法与此对应）* @param reader* @param environment* @param properties* @return*/public SqlSessionFactory build(Reader reader,String environment,Properties properties)&#123; try &#123; //通过XMLConfigBuilder解析配置文件，解析的配置相关信息都会封装为一个Configuration对象 XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties); //这儿创建DefaultSessionFactory对象 return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException("Error building SqlSession.", e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; reader.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125;&#125;public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config);&#125; 当我们获取到SqlSessionFactory之后，就可以通过SqlSessionFactory去获取SqlSession对象。源码如下：123456789101112131415161718192021222324252627282930313233343536/*** 通常一系列openSession方法最终都会调用本方法* @param execType * @param level* @param autoCommit* @return*/private SqlSession openSessionFromDataSource(ExecutorType execType , TransactionIsolationLevel level , boolean autoCommit) &#123; Transaction tx = null; try &#123; //通过Confuguration对象获取Mybatis相关配置,Environment对象包含了数据源和事务的配置 final Environment environment = configuration.getEnvironment(); final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment); tx = transactionFactory.newTransaction(environment.getDataSource() , level , autoCommit); /** * 之前说了，从表面上来看，咱们是用sqlSession在执行sql语句， * 实际呢，其实是通过excutor执行， excutor是对于Statement的封装 */ final Executor executor = configuration.newExecutor(tx, execType); //关键看这儿，创建了一个DefaultSqlSession对象 return new DefaultSqlSession(configuration, executor, autoCommit); &#125; catch (Exception e) &#123; // may have fetched a connection so lets call close() closeTransaction(tx); throw ExceptionFactory.wrapException("Error opening session. Cause: " + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125;&#125; 通过以上步骤，咱们已经得到SqlSession对象了。接下来就是该干嘛干嘛去了（话说还能干嘛，当然是执行sql语句咯）。看了上面，咱们也回想一下之前写的Demo,1234567891011SqlSessionFactory sessionFactory = null; String resource = "mybatis-conf.xml"; try &#123; //SqlSessionFactoryBuilder读取配置文件 sessionFactory = new SqlSessionFactoryBuilder().build(Resources .getResourceAsReader(resource));&#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //通过SqlSessionFactory获取SqlSessionSqlSession sqlSession = sessionFactory.openSession(); 还真这么一回事儿，对吧！ SqlSession咱们也拿到了，咱们可以调用SqlSession中一系列的select…, insert…, update…, delete…方法轻松自如的进行CRUD操作了。 就这样？ 那咱配置的映射文件去哪儿了？ 别急， 咱们接着往下看： 利器之MapperProxy在mybatis中，通过MapperProxy动态代理咱们的dao， 也就是说， 当咱们执行自己写的dao里面的方法的时候，其实是对应的mapperProxy在代理。那么，咱们就看看怎么获取MapperProxy对象吧： 通过SqlSession从Configuration中获取。源码如下：1234567/*** 什么都不做，直接去configuration中找， 哥就是这么任性*/@Overridepublic &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123; return configuration.&lt;T&gt;getMapper(type, this);&#125; SqlSession把包袱甩给了Configuration, 接下来就看看Configuration。源码如下：123456789/*** 烫手的山芋，俺不要，你找mapperRegistry去要* @param type* @param sqlSession* @return*/public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; return mapperRegistry.getMapper(type, sqlSession);&#125; Configuration不要这烫手的山芋，接着甩给了MapperRegistry， 那咱看看MapperRegistry。 源码如下：1234567891011121314151617181920212223/*** 烂活净让我来做了，没法了，下面没人了，我不做谁来做* @param type* @param sqlSession* @return*/@SuppressWarnings("unchecked")public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; //能偷懒的就偷懒，俺把粗活交给MapperProxyFactory去做 final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type); if (mapperProxyFactory == null) &#123; throw new BindingException("Type " + type + " is not known to the MapperRegistry."); &#125; try &#123; //关键在这儿 return mapperProxyFactory.newInstance(sqlSession); &#125; catch (Exception e) &#123; throw new BindingException("Error getting mapper instance.Cause: " + e, e); &#125; &#125; MapperProxyFactory是个苦B的人，粗活最终交给它去做了。咱们看看源码：1234567891011121314151617/*** 别人虐我千百遍，我待别人如初恋* @param mapperProxy* @return*/@SuppressWarnings("unchecked")protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123; //动态代理我们写的dao接口 return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader() , new Class[] &#123; mapperInterface &#125;, mapperProxy);&#125; public T newInstance(SqlSession sqlSession) &#123; final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy);&#125; 通过以上的动态代理，咱们就可以方便地使用dao接口啦， 就像之前咱们写的demo那样：12UserDao userMapper = sqlSession.getMapper(UserDao.class); User insertUser = new User(); 这下方便多了吧， 呵呵， 貌似mybatis的源码就这么一回事儿啊。 别急，还没完， 咱们还没看具体是怎么执行sql语句的呢。 Excutor 接下来，咱们才要真正去看sql的执行过程了。 上面，咱们拿到了MapperProxy, 每个MapperProxy对应一个dao接口， 那么咱们在使用的时候，MapperProxy是怎么做的呢？ 源码奉上： MapperProxy源码12345678910111213141516/*** MapperProxy在执行时会触发此方法*/@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; try &#123; return method.invoke(this, args); &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125; final MapperMethod mapperMethod = cachedMapperMethod(method); //二话不说，主要交给MapperMethod自己去管 return mapperMethod.execute(sqlSession, args);&#125; MapperMethod源码12345678910111213141516171819202122232425262728293031323334353637383940414243/*** 看着代码不少，不过其实就是先判断CRUD类型，然后根据类型去选择到底执行sqlSession中的哪个方法，* 绕了一圈，又转回sqlSession了* @param sqlSession* @param args* @return*/public Object execute(SqlSession sqlSession, Object[] args) &#123; Object result; if (SqlCommandType.INSERT == command.getType()) &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.insert(command.getName(), param)); &#125; else if (SqlCommandType.UPDATE == command.getType()) &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.update(command.getName(), param)); &#125; else if (SqlCommandType.DELETE == command.getType()) &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.delete(command.getName(), param)); &#125; else if (SqlCommandType.SELECT == command.getType()) &#123; if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123; executeWithResultHandler(sqlSession, args); result = null; &#125; else if (method.returnsMany()) &#123; result = executeForMany(sqlSession, args); &#125; else if (method.returnsMap()) &#123; result = executeForMap(sqlSession, args); &#125; else &#123; Object param = method.convertArgsToSqlCommandParam(args); result = sqlSession.selectOne(command.getName(), param); &#125; &#125; else &#123; throw new BindingException("Unknown execution method for: " + command.getName()); &#125; if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123; throw new BindingException("Mapper method '" + command.getName() + "attempted to return null from a method with a primitive return type (" + method.getReturnType() + ")."); &#125; return result;&#125; 既然又回到SqlSession了， 那么咱们就看看SqlSession的CRUD方法了，为了省事，还是就选择其中的一个方法来做分析吧。这儿，咱们选择了selectList方法：1234567891011121314151617181920public &lt;E&gt; List&lt;E&gt; selectList(String statement , Object parameter , RowBounds rowBounds) &#123; try &#123; MappedStatement ms = configuration.getMappedStatement(statement); /** * CRUD实际上是交给Excetor去处理， excutor其实也只是穿了个马甲而已， * 小样，别以为穿个马甲我就不认识你嘞！ */ return executor.query(ms , wrapCollection(parameter) , rowBounds , Executor.NO_RESULT_HANDLER); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException("Error querying database. Cause: " + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125;&#125; 然后，通过一层一层的调用，最终会来到doQuery方法， 这儿咱们就随便找个Excutor看看doQuery方法的实现吧，我这儿选择了SimpleExecutor: SimpleExecutor12345678910111213141516171819202122public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms , Object parameter , RowBounds rowBounds , ResultHandler resultHandler , BoundSql boundSql) throws SQLException &#123; Statement stmt = null; try &#123; Configuration configuration = ms.getConfiguration(); StatementHandler handler = configuration.newStatementHandler( wrapper , ms, parameter , rowBounds , resultHandler , boundSql); stmt = prepareStatement(handler, ms.getStatementLog()); //StatementHandler封装了Statement, 让 StatementHandler 去处理 return handler.&lt;E&gt;query(stmt, resultHandler); &#125; finally &#123; closeStatement(stmt); &#125;&#125; 接下来，咱们看看StatementHandler 的一个实现类 PreparedStatementHandler（这也是我们最常用的，封装的是PreparedStatement）, 看看它使怎么去处理的：12345678public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123; //到此，原形毕露， PreparedStatement, 这个大家都已经滚瓜烂熟了吧 PreparedStatement ps = (PreparedStatement) statement; ps.execute(); //结果交给了ResultSetHandler 去处理 return resultSetHandler.&lt;E&gt; handleResultSets(ps);&#125; 到此， 一次sql的执行流程就完了。 我这儿仅抛砖引玉，建议有兴趣的去看看Mybatis3的源码。 好啦，本次就到此结束啦]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo一站式部署个人博客]]></title>
    <url>%2F%2Fblog%2Fhexo-blog%2F</url>
    <content type="text"><![CDATA[写在前面注：本文出自博主 Chloneda：个人博客 | 博客园 | Github | Gitee | 知乎 本文档是Github + Hexo 的搭建个人博客教程，其中Hexo基于Hexo v3.8.0版本，themes主题基于为NexT v7.0.0版本。 搭建博客前置条件可参考 如何搭建个人独立博客？ 个人博客地址： Chloneda’s blog 注： 点开侧栏浏览目录可快速定位内容 安装主题在 Hexo 项目源码目录下，有两个重要的配置文件，其名称均为 _config.yml 。 其中，一份位于站点根目录下，主要包含 Hexo本身的配置；另一份位于主题目录下，主要用于主题相关的配置。为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。 下载NexT主题12cd hexogit clone https://github.com/theme-next/hexo-theme-next themes/next 启用NexT主题修改站点配置文件，查找关键词theme，并修改为主题名字next：1234# Extensions #(注意冒号间的空格)## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 主题设置设置Scheme在Hexo主题中，有四种不同的模式！进入主题配置文件，搜索关键词找到scheme属性，选择自己喜欢的模式：12345678# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes# scheme: Muse # 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白scheme: Mist # Muse 的紧凑版本，整洁有序的单栏外观# scheme: Pisces # 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白# scheme: Gemini # 类似 Pisces 设置语言编辑站点配置文件，搜索关键词language，并设置成你所需要的语言：1language: zh-CN 设置菜单进入主题配置文件，找到menu字段，菜单内容的设置格式是：item name: link || menu photo，其中item name 是一个名称，link时具体菜单分类，菜单的||后面是菜单的图标,具体菜单图标可参考Font Awesome网站。12345678# 菜单示例配置menu: home: / || home reading: /reading/ || book archives: /archives/ || archive categories: /categories/ || th #tags: /tags/ || tags about: /about/ || user 头像设置在主题配置文件，搜索字段avatar，值设置成头像的链接地址。1234567# 将头像放置主题目录下的 source/uploads/ （新建uploads目录若不存在） 配置为：avatar: /uploads/avatar.png# 放置在 source/images/ 目录下, 配置为：avatar: /images/avatar.png# 完整的互联网 URIavatar: url: http://example.com/avatar.png 设置侧边栏在主题配置文件，搜索sidebar关键词，设置为hide模式，如下图所示：12345sidebar: #display: post // 默认显示方式 #display: always // 一直显示 display: hide // 初始隐藏 #display: remove // 移除侧边栏 各位可根据个人喜好进行设置。 设置站点描述在站点配置文件中，搜索关键词Site，如下：123456# Sitetitle: Chloneda #你的站点标题subtitle: Less is moredescription: Less is more #你的站点描述keywords: chlonedaauthor: chloneda #站点作者 进阶设定添加标签页面hexo根目录下，执行以下命令，新建标签页面。1hexo new page tags 修改站点目录source/tags的 index.md 文件：123456---title: 添加标签页面测试tags: Test #添加标签categories: Test #添加分类comments: false--- 修改主题配置文件，搜索关键词menu，取消 #tags: /tags/ || tags注释，内容如下:12345678# 菜单示例配置menu: home: / || home reading: /reading/ || book archives: /archives/ || archive categories: /categories/ || th tags: /tags/ || tags about: /about/ || user 新添菜单翻译对应的中文打开 hexo&gt;theme&gt;next&gt;languages&gt;zh-CN.yml 文件，在menu下添加 tags: 标签：1234567891011menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 resources: 资源 注：添加其他页面也类似。 首页显示预览首页显示文章列表，列表里的每一篇文章只显示预览，不显示全文。 进入主题配置文件，搜索关键词auto_excerpt，把enable对应的false改为true。12345# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 友情链接打开主题配置文件,搜索关键字 Blog rolls,添加自己需要的链接：123links: #连接 baidu: https://www.baidu.com/ google: https://www.google.com/ 本地搜索在Hexo的根目录下执行以下命令。1$ npm install hexo-generator-searchdb --save 打开主题配置文件,搜索关键字local_search,将enable的值设置为 true：1234# Local search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search: enable: true 打开站点配置文件，搜索关键词search，修改为如下内容：123456# 本地搜索search: path: search.xml field: post format: html limit: 10000 添加RSS在Hexo根目录执行安装指令，安装 hexo-generator-feed 插件：1npm install hexo-generator-feed --save 打开站点配置文件，追加feed信息:1234567# 设置RSSfeed: type: rss2 path: rss2.html limit: 5 hub: content: 'true' 打开主题配置文件，找到rss，设置为:1rss: /atom.xml 添加社交链接在主题配置文件中，找到social属性，添加社交链接，步骤如下：12345social: E-Mail: mailto:yourname@gmail.com || envelope Google: https://plus.google.com/yourname || google Twitter: https://twitter.com/yourname || twitter Facebook: https://www.facebook.com/yourname || facebook 格式为： 社交平台名称：链接 设置代码高亮首先需要改动的地方有： 站点配置文件_config.yml。 主题配置文件_config.yml。 在站点配置文件中，搜索highlight关键词:12345highlight: enable: true line_number: true auto_detect: true tab_replace: 文字自动检测默认不启动，改成true使其起作用。 再到主题配置文件，搜索highlight_theme关键词，修改代码主题样式：1234# Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night 添加复制按钮在主题配置文件中，搜索关键词codeblock，将copy_button的enable值修改为true。1234567codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1 border_radius: # Add copy button on codeblock copy_button: enable: true 添加阅读次数统计主题配置文件中，搜索关键词busuanzi_count，设置文章阅读次数统计及网站访客量:12345678910# Show Views/Visitors of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzibusuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye 添加 README.md每个项目README.md文件可以简单说明这个项目的用途。在Hexo目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件，将 skip_render 参数的值设置为：1skip_render: README.md 再次使用hexo d命令部署博客的时候就不会在渲染 README.md 这个文件。 进阶配置自定义网站头像自定义头像可以使用 比特虫 网站制作！ 在主题配置文件中，按以下修改：1234567favicon: small: /images/favicon-16x16-next.png #你的头像名称 medium: /images/favicon-32x32-next.png #你的头像名称 apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 添加自定义页面[友链]设置菜单项的显示中文文本，打开themes/next/languages/zh-CN.yml文件,搜索 menu 关键字，修改对应中文或者新增。123456789101112menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 # schedule: 日程表 # sitemap: 站点地图 # commonweal: 公益404 # 新增menu links: 友链 # 新增该选项表示新增“友链”菜单 在主题配置文件，搜索menu，新增links: /links/ || link：123456789# 菜单示例配置menu: home: / || home reading: /reading/ || book archives: /archives/ || archive categories: /categories/ || th #tags: /tags/ || tags about: /about/ || user links: /links/ || link hexo根目录下，执行以下命令，新建友链页面。1hexo new page links 修改站点目录下source/links的 index.md 文件：123456---title: 友链tags: linkscategories: linkscomments: false--- 注：其它自定义菜单也是类似步骤 增加背景音乐在本博客的侧边栏增加网易云音乐，生成音乐外链可参考链接 ，复制链接，将外链插入到Hexo根路径的侧边栏文件中：/themes/next/layout/_macro/sidebar.swig，即侧边栏友情链接theme.links这一项之后。12345678910111213141516&#123;% if theme.links %&#125; &lt;div&gt; &lt;div class="links-of-blogroll-title"&gt; ....省略部分代码 &lt;/div&gt; &lt;ul class="links-of-blogroll-list"&gt; ....省略部分代码 &lt;/ul&gt; &lt;/div&gt;&#123;% endif %&#125; &lt;div id="music163player"&gt; &lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&amp;id=5239700&amp;auto=0&amp;height=66"&gt; &lt;/iframe&gt; &lt;/div&gt; 添加打赏功能如今已进入知识付费时代，打赏是读者对笔者创造的最大支持，更是对劳动者的尊重。打赏功能具体步骤为：获取二维码 微信二维码的获取（可百度）。 获取支付宝收款二维码（可百度）。 添加二维码图片资源得到二维码图片资源后，读者们可将二维码图片放到NexT根目录/source/images/文件夹下。 开启打赏功能打开主题配置文件，搜索reward关键词，添加打赏的配置信息。12345678# Reward# If true, reward would be displayed in every article by default.# And you can show or hide one article specially through add page variable `reward: true/false`.reward: enable: true //默认是false，改为true comment: 您的支持是对我最大的鼓励 wechatpay: /images/wechatpay.jpg #图片链接或图片相对路径 alipay: /images/alipay.jpg #图片链接或图片相对路径 开启版权声明打开主题配置文件,搜索关键字 creative_commons , post 改为 true：1234creative_commons: license: by-nc-sa sidebar: false post: true 优化及设置优化urlseo搜索引擎优化认为，网站的最佳结构是三层，但是默认hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，url不利于搜索引擎搜索。 因此，我们可以将url直接改成sitename/blog/title的形式，同时title最好是用英文，在站点配置文件搜索permalink关键词，并修改如下。1234url: https://chloneda.github.io/root: /permalink: /blog/:title.htmlpermalink_defaults: Hexo博客备份利用github分支功能进行博客备份，思路说明: master分支：存放博客的静态网页(默认分支)。 hexo分支：存放Hexo博客的源码文件。 master分支部署进入站点配置文件编辑，搜索deploy关键词：1234deploy: type: git repo: https://github.com/你的github用户名/你的github用户名.github.io.git branch: master 修改更新博客内容并保存。 执行hexo clean清除本地旧代码。 执行hexo g -d生成静态网站并部署到GitHub的master分支上。 hexo分支配置 hexo分支，该分支为博客源码分支。 使用git clone -b hexo 你的github仓库路径， 拷贝源码仓库。 修改hexo主配置_config.xml的deploy部分配置，设置静态页面的发布分支为master。 添加.gitignore文件，将静态网页的目录及其他无需提交的源文件及目录排除掉。 博客源码更新在本地对博客进行修改后，提交hexo源代码：1234git checkout hexogit add .git commit -m 'Code update'git push origin hexo 发布hexo静态文件hexo根目录依次执行以下命令：123hexo cleanhexo generate 或者 hexo ghexo deploy 或者 hexo d 本地资料丢失或其他主机搭建博客步骤： 拷贝hexo分支源码到本地：git clone -b hexo github项目地址.git。 安装hexo及各类插件。 本地安装调试。 Hexo部署脚本Hexo修改后利用deploy.sh脚本一键部署，提高部署效率。123456789101112131415161718192021#!/bin/bashDIR=`dirname $0`# Generate bloghexo cleanhexo generatesleep 5# Deployhexo deploysleep 5# Push hexo codegit add .current_date=`date "+%Y-%m-%d %H:%M:%S"`git commit -m "Blog updated: $current_date"sleep 2git push origin hexoecho "=====&gt;Finish!&lt;=====" 把该脚本存放至 hexo根目录中，并附加脚本执行权限:1chmod 775 deploy.sh 在hexo目录根执行脚本:1./deploy.sh 可一键部署博客及备份博客源码至github的分支hexoCode上。 提升你的博客更多提升NexT主题的方法请参考以下网页。 Hexo高阶教程：打造定制化博客 让你的hexo博客在搜索引擎中排第一 结束小语本文采用Github + Hexo搭建的个人博客，在搭建过程优化总结，及时记录，希望对各位有所帮助！本文如有错误，欢迎在 Github 的issue中提出，非常感谢！！！ 更多详情请参考： Hexo官网 NexT主题 Hexo插件 Markdown]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Chloneda]]></title>
    <url>%2F%2Fblog%2Fhello-chloneda%2F</url>
    <content type="text"><![CDATA[Welcome to chloneda‘s blog!This is my very first post.You can check the Hexo official website and the Markdown website for related commands and syntax. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartOther reference website NexT 比特虫 Font Awesome Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中FTP安装配置及基本概念]]></title>
    <url>%2F%2Fblog%2Fftp%2F</url>
    <content type="text"><![CDATA[注：本文出自博主 Chloneda：个人博客 | 博客园 | Github | Gitee | 知乎 安装用apt-get工具安装vsftpd1$ sudo apt-get install vsftpd 检查FTP端口是否已经打开1$ netstat -tnl 或 ps -ef | grep ftp 检查FTP服务是否开启1$ service vsftpd status 如果FTP服务已经开启，则会显示如下信息，由Active关键词可知FTP服务正在运行FTP启动、停止、重启、查看状态的三种方式。123$ service vsftpd start|stop|restart|status$ systemctl start|stop|restart|status vsftpd$ /etc/init.d/vsftpd start|stop|restart|status|reload reload为重新加载配置文件 配置修改FTP配置文件1$ sudo vi /etc/vsftpd.conf FTP主要配置主要配置说明：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 设置登录FTP欢迎信息ftpd_banner=Welcome to CHL FTP service. # 基本配置1listen=YES # 服务器监听local_enable=YES # 是否允许本地用户访问write_enable=YES # 是否允许上传文件，不开启会报 550 permission deniedanonymous_enable=NO # 匿名访问允许，默认不要开启anon_upload_enable=YES # 匿名上传允许，默认是NOanon_mkdir_write_enable=YES # 匿名创建文件夹允许 # 基本配置2local_umask=022 # FTP上本地的文件权限，默认是077。此时umask为022，则目录为777-022=755，文件为666-022=644。dirmessage_enable=YES # 进入文件夹允许 connect_from_port_20=YES # 启用20号端口作为数据传送的端口 data_connection_timeout=120 # 设置数据连接超时时间# 日志配置utf8_filesystem=YES # vsftpd使用utf8文件系统use_localtime=YESxferlog_enable=YES # 激活上传和下传的日志 xferlog_file=/var/log/vsftpd.log # 设定系统维护记录FTP服务器上传和下载情况的日志文件xferlog_std_format=YES # 使用标准的日志格式 # 自定义local_root=/share/vsftpd # 设置自定义的ftp根目录的位置# 读写权限allow_writeable_chroot=YES # 解决"500 OOPS: vsftpd: refusing to run with writable root inside chroot()" 问题write_enable=YES # 允许向FTP服务器写入权限chown_uploads=YES # 设定是否允许改变上传文件的属主，与下面一个设定项配合使用chown_username=whoever # 设置想要改变的上传文件的属主，可设为ftpascii_upload_enable=YES # 允许服务器以ASCII方式传输数据,但引起"SIZE /big/file"方式的DoS攻击ascii_download_enable=YESdeny_email_enable=YES # 黑名单设置。如果很讨厌某些email address，可以取消他的登录权限banned_email_file=/etc/vsftpd.banned_emails# FTP限制最大连接数和传输速率，进行资源控制，避免负担过大而运行异常max_client=50 # FTP服务器的所有客户端最大连接数不超过50个max_per_ip=5 # 同一IP地址的FTP客户机与FTP服务器建立的最大连接数不超过5个local_max_rate=100000 # FTP服务器的本地用户最大传输速率设置为100KB/s.anon_max_rate=50000 # FTP服务器的匿名用户最大传输速率设置为50KB/s.# 权限设置#是否启动userlist为禁止模式，YES表示在userlist中的用户禁止登录ftp（黑名单），NO表示黑名单失效userlist_deny=NOuserlist_enable=NO # 是否启动限制用户的名单为允许模式，上面的YES限制了所有用户，可以用这个名单作为白名单，作为例外允许访问ftp根目录以外userlist_file=/etc/vsftpd.user_list# 在默认配置下，本地用户登入FTP后可以使用cd命令切换到其他目录，这样会对系统带来安全隐患,可配置如下chroot_list_enable=YES # 设置是否启用chroot_list_file配置项指定的用户列表文件。默认值为NO。chroot_local_user=YES # 用于指定用户列表文件中的用户是否允许切换到上级目录。默认值为NO。chroot_list_file=/etc/vsftpd.chroot_list # 禁用名单，用于指定用户列表，该文件用于控制哪些用户可以切换到home目录的上级目录。 通过搭配能实现以下几种效果 当chroot_list_enable=YES，chroot_local_user=YES时，在/etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录；未在文件中列出的用户，不能切换到其他目录。 当chroot_list_enable=YES，chroot_local_user=NO时，在/etc/vsftpd.chroot_list文件中列出的用户，不能切换到其他目录；未在文件中列出的用户，可以切换到其他目录。 当chroot_list_enable=NO，chroot_local_user=YES时，所有的用户均不能切换到其他目录。 当chroot_list_enable=NO，chroot_local_user=NO时，所有的用户均可以切换到其他目录。 配置正确后可浏览器或终端输入以下信息访问123ftp://服务器IP # 浏览器方式访问$ ftp 服务器IP # 终端方式访问 也可以通过浏览器这样访问。1ftp://用户名:密码@IP/具体FTP路径 # 如:ftp://vsftpd:vsftpd@192.167.2.20/chl 修改默认端口默认FTP服务器端口号是21，出于安全目的，有时需修改默认端口号，编辑/etc/vsftpd.conf文件。1listen_port=6666 重新指定了FTP服务器的端口号，需重启服务使配置生效,并利用终端访问。12$ /etc/init.d/vsftpd restart$ ftp 服务器IP 6666 注：端口号需正确，否则连接失败。 设置FTP目录创建FTP根目录，需与配置文件一致。1$ mkdir -p /share/vsftpd 创建FTP用户1$ sudo useradd -g vsftpd -d /share/vsftpd -m test 命令参数说明： g：用户所在的组 d：指定FTP目录 m：不建立默认家目录 设置FTP用户密码1$ sudo passwd vsftpd 编辑/etc/vsftpd.chroot_list文件，将vsftpd的帐户名添加进去，保存退出,并重启FTP服务。 卸载当我们不需要FTP时，可以卸载FTP并删除FTP用户。1$ sudo apt-get remove --purge vsftpd # purge 选项表示彻底删除改软件和相关文件 删除FTP用户1$ sudo userdel vsftpd 常用命令路径切换FTP可以定位服务器与本地硬盘的路径。其中使用 lcd 命令切换宿主机本地路径，命令如下：1$ lcd 目录名 # 进入宿主机目录 而用 cd 命令切换远程服务器的路径,命令如下:1$ cd 目录名 # 进入FTP服务器目录 说到这里，得说说 ! 命令的作用，在FTP中!会执行宿主机shell命令，如:12$ !cmd [args] # 在宿主机中执行交互shell，exit回到FTP环境,例：$ !dir 或 !ls 或如果不加!,显示FTP服务器当前目录内容,如：1$ dir 或 ls 此外，ftp命令支持”含有空格”的文件夹/文件名，即在引用时加上双引号””。 下载文件 get:一次只下载一个文件。 mget:一次可以下载多个文件，而且支持通配符。 上传文件 send: 上传一个文件。 put：上传一个文件。 mput: 上传多个文件。 其他命令其实FTP命令的核心就是善用 help 或 ? 查看具体命令的含义，例如：1ftp&gt; help 或 ? 可利用 ? [cmd] 或 help [cmd] 查看具体命令含义，如图。 有时侯我们会对多个文件进行操作，此时需要对每一个文件都选择y/n，挺麻烦的！可用prompt命令关掉交互方式。12prompt off # 关闭prompt on # 打开 其他信息FTP 数字代码的意义 参考资料vsftpd最详细的配置文件]]></content>
      <categories>
        <category>FTP</category>
      </categories>
      <tags>
        <tag>FTP</tag>
      </tags>
  </entry>
</search>
