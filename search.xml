<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列十-SQL执行流程分析（源码篇）]]></title>
    <url>%2F%2Fblog%2Fmybatis-10%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 最近太忙了，一直没时间继续更新博客，今天忙里偷闲继续我的Mybatis学习之旅。在前九篇中，介绍了mybatis的配置以及使用， 那么本篇将走进mybatis的源码，分析mybatis 的执行流程， 好啦，鄙人不喜欢口水话，还是直接上干活吧： SqlSessionFactory 与 SqlSession通过前面的章节对于mybatis 的介绍及使用，大家都能体会到SqlSession的重要性了吧， 没错，从表面上来看，咱们都是通过SqlSession去执行sql语句（注意：是从表面看，实际的待会儿就会讲）。那么咱们就先看看是怎么获取SqlSession的吧： 首先，SqlSessionFactoryBuilder去读取mybatis的配置文件，然后build一个DefaultSqlSessionFactory。源码如下：12345678910111213141516171819202122232425262728/** * 一系列的构造方法最终都会调用本方法（配置文件为Reader时会调用本方法，还有一个InputStream方法与此对应） * @param reader * @param environment * @param properties * @return */ public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123; try &#123; //通过XMLConfigBuilder解析配置文件，解析的配置相关信息都会封装为一个Configuration对象 XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties); //这儿创建DefaultSessionFactory对象 return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException("Error building SqlSession.", e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; reader.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125; public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config); &#125; 当我们获取到SqlSessionFactory之后，就可以通过SqlSessionFactory去获取SqlSession对象。源码如下：12345678910111213141516171819202122232425/** * 通常一系列openSession方法最终都会调用本方法 * @param execType * @param level * @param autoCommit * @return */ private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123; Transaction tx = null; try &#123; //通过Confuguration对象去获取Mybatis相关配置信息, Environment对象包含了数据源和事务的配置 final Environment environment = configuration.getEnvironment(); final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment); tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit); //之前说了，从表面上来看，咱们是用sqlSession在执行sql语句， 实际呢，其实是通过excutor执行， excutor是对于Statement的封装 final Executor executor = configuration.newExecutor(tx, execType); //关键看这儿，创建了一个DefaultSqlSession对象 return new DefaultSqlSession(configuration, executor, autoCommit); &#125; catch (Exception e) &#123; closeTransaction(tx); // may have fetched a connection so lets call close() throw ExceptionFactory.wrapException("Error opening session. Cause: " + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; 通过以上步骤，咱们已经得到SqlSession对象了。接下来就是该干嘛干嘛去了（话说还能干嘛，当然是执行sql语句咯）。看了上面，咱们也回想一下之前写的Demo,1234567891011SqlSessionFactory sessionFactory = null; String resource = "mybatis-conf.xml"; try &#123; //SqlSessionFactoryBuilder读取配置文件 sessionFactory = new SqlSessionFactoryBuilder().build(Resources .getResourceAsReader(resource));&#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //通过SqlSessionFactory获取SqlSessionSqlSession sqlSession = sessionFactory.openSession(); 还真这么一回事儿，对吧！ SqlSession咱们也拿到了，咱们可以调用SqlSession中一系列的select…, insert…, update…, delete…方法轻松自如的进行CRUD操作了。 就这样？ 那咱配置的映射文件去哪儿了？ 别急， 咱们接着往下看： 利器之MapperProxy在mybatis中，通过MapperProxy动态代理咱们的dao， 也就是说， 当咱们执行自己写的dao里面的方法的时候，其实是对应的mapperProxy在代理。那么，咱们就看看怎么获取MapperProxy对象吧： 通过SqlSession从Configuration中获取。源码如下：1234567/** * 什么都不做，直接去configuration中找， 哥就是这么任性 */ @Override public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123; return configuration.&lt;T&gt;getMapper(type, this); &#125; SqlSession把包袱甩给了Configuration, 接下来就看看Configuration。源码如下：123456789/** * 烫手的山芋，俺不要，你找mapperRegistry去要 * @param type * @param sqlSession * @return */ public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; return mapperRegistry.getMapper(type, sqlSession); &#125; Configuration不要这烫手的山芋，接着甩给了MapperRegistry， 那咱看看MapperRegistry。 源码如下：1234567891011121314151617181920/** * 烂活净让我来做了，没法了，下面没人了，我不做谁来做 * @param type * @param sqlSession * @return */ @SuppressWarnings("unchecked") public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; //能偷懒的就偷懒，俺把粗活交给MapperProxyFactory去做 final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type); if (mapperProxyFactory == null) &#123; throw new BindingException("Type " + type + " is not known to the MapperRegistry."); &#125; try &#123; //关键在这儿 return mapperProxyFactory.newInstance(sqlSession); &#125; catch (Exception e) &#123; throw new BindingException("Error getting mapper instance. Cause: " + e, e); &#125; &#125; MapperProxyFactory是个苦B的人，粗活最终交给它去做了。咱们看看源码：123456789101112131415/** * 别人虐我千百遍，我待别人如初恋 * @param mapperProxy * @return */ @SuppressWarnings("unchecked") protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123; //动态代理我们写的dao接口 return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy); &#125; public T newInstance(SqlSession sqlSession) &#123; final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy); &#125; 通过以上的动态代理，咱们就可以方便地使用dao接口啦， 就像之前咱们写的demo那样：12UserDao userMapper = sqlSession.getMapper(UserDao.class); User insertUser = new User(); 这下方便多了吧， 呵呵， 貌似mybatis的源码就这么一回事儿啊。 别急，还没完， 咱们还没看具体是怎么执行sql语句的呢。 Excutor 接下来，咱们才要真正去看sql的执行过程了。 上面，咱们拿到了MapperProxy, 每个MapperProxy对应一个dao接口， 那么咱们在使用的时候，MapperProxy是怎么做的呢？ 源码奉上： MapperProxy源码12345678910111213141516/** * MapperProxy在执行时会触发此方法 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; try &#123; return method.invoke(this, args); &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125; final MapperMethod mapperMethod = cachedMapperMethod(method); //二话不说，主要交给MapperMethod自己去管 return mapperMethod.execute(sqlSession, args); &#125; MapperMethod源码1234567891011121314151617181920212223242526272829303132333435363738/** * 看着代码不少，不过其实就是先判断CRUD类型，然后根据类型去选择到底执行sqlSession中的哪个方法，绕了一圈，又转回sqlSession了 * @param sqlSession * @param args * @return */ public Object execute(SqlSession sqlSession, Object[] args) &#123; Object result; if (SqlCommandType.INSERT == command.getType()) &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.insert(command.getName(), param)); &#125; else if (SqlCommandType.UPDATE == command.getType()) &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.update(command.getName(), param)); &#125; else if (SqlCommandType.DELETE == command.getType()) &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.delete(command.getName(), param)); &#125; else if (SqlCommandType.SELECT == command.getType()) &#123; if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123; executeWithResultHandler(sqlSession, args); result = null; &#125; else if (method.returnsMany()) &#123; result = executeForMany(sqlSession, args); &#125; else if (method.returnsMap()) &#123; result = executeForMap(sqlSession, args); &#125; else &#123; Object param = method.convertArgsToSqlCommandParam(args); result = sqlSession.selectOne(command.getName(), param); &#125; &#125; else &#123; throw new BindingException("Unknown execution method for: " + command.getName()); &#125; if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123; throw new BindingException("Mapper method '" + command.getName() + " attempted to return null from a method with a primitive return type (" + method.getReturnType() + ")."); &#125; return result; &#125; 既然又回到SqlSession了， 那么咱们就看看SqlSession的CRUD方法了，为了省事，还是就选择其中的一个方法来做分析吧。这儿，咱们选择了selectList方法：1234567891011public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123; try &#123; MappedStatement ms = configuration.getMappedStatement(statement); //CRUD实际上是交给Excetor去处理， excutor其实也只是穿了个马甲而已，小样，别以为穿个马甲我就不认识你嘞！ return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException("Error querying database. Cause: " + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125;&#125; 然后，通过一层一层的调用，最终会来到doQuery方法， 这儿咱们就随便找个Excutor看看doQuery方法的实现吧，我这儿选择了SimpleExecutor: SimpleExecutor1234567891011121314151617public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms , Object parameter , RowBounds rowBounds , ResultHandler resultHandler , BoundSql boundSql) throws SQLException &#123; Statement stmt = null; try &#123; Configuration configuration = ms.getConfiguration(); StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); stmt = prepareStatement(handler, ms.getStatementLog()); //StatementHandler封装了Statement, 让 StatementHandler 去处理 return handler.&lt;E&gt;query(stmt, resultHandler); &#125; finally &#123; closeStatement(stmt); &#125;&#125; 接下来，咱们看看StatementHandler 的一个实现类 PreparedStatementHandler（这也是我们最常用的，封装的是PreparedStatement）, 看看它使怎么去处理的：1234567public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123; //到此，原形毕露， PreparedStatement, 这个大家都已经滚瓜烂熟了吧 PreparedStatement ps = (PreparedStatement) statement; ps.execute(); //结果交给了ResultSetHandler 去处理 return resultSetHandler.&lt;E&gt; handleResultSets(ps);&#125; 到此， 一次sql的执行流程就完了。 我这儿仅抛砖引玉，建议有兴趣的去看看Mybatis3的源码。 好啦，本次就到此结束啦]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列九-强大的动态SQL]]></title>
    <url>%2F%2Fblog%2Fmybatis-9%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（八）—mapper映射文件配置之select、resultMap》简单介绍了mybatis的查询，至此，CRUD都已讲完。本文将介绍mybatis强大的动态SQL。 那么，问题来了： 什么是动态SQL? 动态SQL有什么作用？ 传统的使用JDBC的方法，相信大家在组合复杂的的SQL语句的时候，需要去拼接，稍不注意哪怕少了个空格，都会导致错误。Mybatis的动态SQL功能正是为了解决这种问题， 其通过 if, choose, when, otherwise, trim, where, set, foreach标签，可组合成非常灵活的SQL语句，从而提高开发人员的效率。下面就去感受Mybatis动态SQL的魅力吧： mybatis中if判断作为程序猿，谁不懂if !在mybatis中也能用 if 啦：1234567&lt;select id="findUserById" resultType="user"&gt; select * from user where &lt;if test="id != null"&gt; id=#&#123;id&#125; &lt;/if&gt; and deleteFlag=0;&lt;/select&gt; 上面例子： 如果传入的id 不为空， 那么才会SQL才拼接id = #{id}。 这个相信大家看一样就能明白，不多说。 细心的人会发现一个问题：“你这不对啊！ 要是你传入的id为null, 那么你这最终的SQL语句不就成了 select * from user where and deleteFlag=0, 这语句有问题！” 是啊，这时候，mybatis的 where 标签就该隆重登场啦： mybatis中where咱们通过where改造一下上面的例子：123456789&lt;select id="findUserById" resultType="user"&gt; select * from user &lt;where&gt; &lt;if test="id != null"&gt; id=#&#123;id&#125; &lt;/if&gt; and deleteFlag=0; &lt;/where&gt; &lt;/select&gt; 有些人就要问了： “你这都是些什么玩意儿！ 跟上面的相比， 不就是多了个where标签嘛！ 那这个还会不会出现 select * from user where and deleteFlag=0 ？” 的确，从表面上来看，就是多了个where标签而已， 不过实质上， mybatis是对它做了处理，当它遇到AND或者OR这些，它知道怎么处理。其实我们可以通过 trim 标签去自定义这种处理规则。 trim:我的地盘，我做主上面的where标签，其实用trim 可以表示如下：123&lt;trim prefix="WHERE" prefixOverrides="AND |OR "&gt; ... &lt;/trim&gt; 它的意思就是： 当WHERE后紧随AND或则OR的时候，就去除AND或者OR。 除了WHERE以外， 其实还有一个比较经典的实现，那就是SET。 set: 信我，不出错123456789101112131415161718&lt;update id="updateUser" parameterType="com.dy.entity.User"&gt; update user set &lt;if test="name != null"&gt; name = #&#123;name&#125;, &lt;/if&gt; &lt;if test="password != null"&gt; password = #&#123;password&#125;, &lt;/if&gt; &lt;if test="age != null"&gt; age = #&#123;age&#125; &lt;/if&gt; &lt;where&gt; &lt;if test="id != null"&gt; id = #&#123;id&#125; &lt;/if&gt; and deleteFlag = 0; &lt;/where&gt;&lt;/update&gt; 问题又来了： “如果我只有name不为null, 那么这SQL不就成了 update set name = #{name}, where …….. ? 你那name后面那逗号会导致出错啊！” 是的，这时候，就可以用mybatis为我们提供的set 标签了。下面是通过set标签改造后：1234567891011121314&lt;update id="updateUser" parameterType="com.dy.entity.User"&gt; update user &lt;set&gt; &lt;if test="name != null"&gt;name = #&#123;name&#125;,&lt;/if&gt; &lt;if test="password != null"&gt;password = #&#123;password&#125;,&lt;/if&gt; &lt;if test="age != null"&gt;age = #&#123;age&#125;,&lt;/if&gt; &lt;/set&gt; &lt;where&gt; &lt;if test="id != null"&gt; id = #&#123;id&#125; &lt;/if&gt; and deleteFlag = 0; &lt;/where&gt;&lt;/update&gt; 这个用trim 可表示为：123&lt;trim prefix="SET" suffixOverrides=","&gt; ...&lt;/trim&gt; foreach: 你有for, 我有foreach！java中有for, 可通过for循环， 同样， mybatis中有foreach, 可通过它实现循环，循环的对象当然主要是java容器和数组。123456789&lt;select id="selectPostIn" resultType="domain.blog.Post"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item="item" index="index" collection="list" open="(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; 将一个 List 实例或者数组作为参数对象传给 MyBatis，当这么做的时候，MyBatis 会自动将它包装在一个 Map 中并以名称为键。List 实例将会以“list”作为键，而数组实例的键将是“array”。同样， 当循环的对象为map的时候，index其实就是map的key。 choose: 我选择了你，你选择了我Java中有switch, mybatis有choose123456789101112131415&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test="title != null"&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 以上例子中： 当title和author都不为null的时候， 那么选择二选一（前者优先）， 如果都为null, 那么就选择 otherwise中的， 如果tilte和author只有一个不为null, 那么就选择不为null的那个。 纵观mybatis的动态SQL， 强大而简单， 相信大家简单看一下就能使用了。 好啦，本次就写到这！下篇文章将结合mybatis的源码分析一次sql语句执行的整个过程。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列八-mapper映射文件配置之select、resultMap]]></title>
    <url>%2F%2Fblog%2Fmybatis-8%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇《深入浅出Mybatis系列（七）—mapper映射文件配置之insert、update、delete》介绍了insert、update、delete的用法，本篇将介绍select、resultMap的用法。select无疑是我们最常用，也是最复杂的，mybatis通过resultMap能帮助我们很好地进行高级映射。下面就开始看看select 以及 resultMap的用法： 先看select的配置吧： select配置1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;select &lt;!-- 1. id （必须配置） id是命名空间中的唯一标识符，可被用来代表这条语句。 一个命名空间（namespace） 对应一个dao接口, 这个id也应该对应dao里面的某个方法（相当于方法的实现），因此id 应该与方法名一致 --&gt; id="selectPerson" &lt;!-- 2. parameterType （可选配置, 默认为mybatis自动选择处理） 将要传入语句的参数的完全限定类名或别名， 如果不配置，mybatis会通过ParameterHandler 根据参数类型默认选择合适的typeHandler进行处理 parameterType 主要指定参数类型，可以是int, short, long, string等类型，也可以是复杂类型（如对象） --&gt; parameterType="int" &lt;!-- 3. resultType (resultType 与 resultMap 二选一配置) resultType用以指定返回类型，指定的类型可以是基本类型，可以是java容器，也可以是javabean --&gt; resultType="hashmap" &lt;!-- 4. resultMap (resultType 与 resultMap 二选一配置) resultMap用于引用我们通过 resultMap标签定义的映射类型，这也是mybatis组件高级复杂映射的关键 --&gt; resultMap="personResultMap" &lt;!-- 5. flushCache (可选配置) 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false --&gt; flushCache="false" &lt;!-- 6. useCache (可选配置) 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true --&gt; useCache="true" &lt;!-- 7. timeout (可选配置) 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）--&gt; timeout="10000" &lt;!-- 8. fetchSize (可选配置) 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动)--&gt; fetchSize="256" &lt;!-- 9. statementType (可选配置) STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED--&gt; statementType="PREPARED" &lt;!-- 10. resultSetType (可选配置) FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）--&gt; resultSetType="FORWARD_ONLY"&gt; 配置看起来总是这么多，不过实际常用的配置也就那么几个， 根据自己的需要吧，上面都已注明是否必须配置。 下面还是上个demo及时练练手吧! 数据库：新增两张表（t_course, t_student）,以下为相关实体类。 Course.java123456789public class Course &#123; private int id; private String name; private int deleteFlag; //setter和getter方法省略...&#125; Student.java1234567891011public class Student &#123; private int id; private String idCard; private String name; private List&lt;Course&gt; courseList; private int deleteFlag; //setter和getter方法省略...&#125; CourseDao.java12345public interface CourseDao &#123; public Course findCourseById(int courseId); &#125; StudentDao.java12345public interface StudentDao &#123; public Student findStudentById(String idCard);&#125; courseDao.xml12345678910111213141516&lt;mapper namespace="com.dy.dao.CourseDao"&gt; &lt;!-- 1.此处直接将resultType 设置为course, 一看就知道我设置了别名吧，如果没有设置别名，那么resultType = com.dy.entity.Course。 2.可能细心的你会发现：Course.java中的属性名与数据库字段名不一致，下面，我就在sql语句中用了as, 使之匹配，当然方法不止一种， 在学习了resultMap之后，你能看到一种更直观优雅的方式去将javabean中的属性与数据库字段名保持一致 3.findCourseById 与CourseDao中findCourseById方法对应， 那么传入的参数名称以及类型也应该保持对应关系。 4.可以看到，在sql语句中，通过#&#123;&#125;表达式可以获取参数。 5.下面这条sql语句，实际上的形式是怎么样的？还记得之前说过，mybatis默认为preparedStatement吧，那么，用我们jdbc代码来看，它其实就是： select course_id as id, course_name as name, course_delete_flg as deleteFlag from t_course where course_id=? --&gt; &lt;select id="findCourseById" resultType="course" &gt; select course_id as id, course_name as name, course_delete_flg as deleteFlag from t_course where course_id=#&#123;courseId&#125; &lt;/select&gt; &lt;/mapper&gt; CourseDaoTest.java123456789101112131415161718192021222324public class CourseDaoTest &#123; @Test public void findCourseById() &#123; SqlSessionFactory sqlSessionFactory = getSessionFactory(); SqlSession sqlSession = sqlSessionFactory.openSession(); CourseDao courseDao = sqlSession.getMapper(CourseDao.class); Course course = courseDao.findCourseById(1); &#125; //Mybatis 通过SqlSessionFactory获取SqlSession, 然后才能通过SqlSession与数据库进行交互 private static SqlSessionFactory getSessionFactory() &#123; SqlSessionFactory sessionFactory = null; String resource = "mybatis-conf.xml"; try &#123; sessionFactory = new SqlSessionFactoryBuilder().build(Resources .getResourceAsReader(resource)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return sessionFactory; &#125; &#125; 上面的示例，我们针对course, 简单演示了 select的用法， 不过有个问题值得思考： 一个student可以对应多个course, 那么，在mybatis中如何处理这种一对多， 甚至于多对多，一对一的关系呢？ 这儿，就不得不提到 resultMap 这个东西， mybatis的resultMap功能可谓十分强大，能够处理复杂的关系映射， 那么resultMap 该怎么配置呢？ 别急，这就来了： resultMap配置1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- 1.type 对应类型，可以是javabean, 也可以是其它 2.id 必须唯一， 用于标示这个resultMap的唯一性，在使用resultMap的时候，就是通过id指定 --&gt; &lt;resultMap type="" id=""&gt; &lt;!-- id, 唯一性，注意啦，这个id用于标示这个javabean对象的唯一性， 不一定会是数据库的主键（不要把它理解为数据库对应表的主键） property属性对应javabean的属性名，column对应数据库表的列名 （这样，当javabean的属性与数据库对应表的列名不一致的时候，就能通过指定这个保持正常映射了） --&gt; &lt;id property="" column=""/&gt; &lt;!-- result与id相比， 对应普通属性 --&gt; &lt;result property="" column=""/&gt; &lt;!-- constructor对应javabean中的构造方法 --&gt; &lt;constructor&gt; &lt;!-- idArg 对应构造方法中的id参数 --&gt; &lt;idArg column=""/&gt; &lt;!-- arg 对应构造方法中的普通参数 --&gt; &lt;arg column=""/&gt; &lt;/constructor&gt; &lt;!-- collection，对应javabean中容器类型, 是实现一对多的关键 property 为javabean中容器对应字段名 column 为体现在数据库中列名 ofType 就是指定javabean中容器指定的类型 --&gt; &lt;collection property="" column="" ofType=""&gt;&lt;/collection&gt; &lt;!-- association 为关联关系，是实现N对一的关键。 property 为javabean中容器对应字段名 column 为体现在数据库中列名 javaType 指定关联的类型 --&gt; &lt;association property="" column="" javaType=""&gt;&lt;/association&gt; &lt;/resultMap&gt; 好啦，知道resutMap怎么配置后，咱们立即接着上面的demo来练习一下吧： 下面是用resultMap处理一对多关系的映射的示例 一个student对应多个course， 典型的一对多，咱们就来看看mybatis怎么配置这种映射吧： studentDao.xml123456789101112131415161718192021222324252627282930313233&lt;mapper namespace="com.dy.dao.StudentDao"&gt; &lt;!-- 这儿定义一个resultMap --&gt; &lt;resultMap type="student" id="studentMap"&gt; &lt;!-- 数据库中主键是id, 但是我这儿却是指定idCard为主键，为什么？ 刚刚讲了，id用来表示唯一性， 我们可以认为只要idCard一样，那么他就是同一个学生。 如果此处用数据库中id， 那么mybatis将会认为数据库中每条记录都是一个student, 这显然不符合逻辑 --&gt; &lt;id property="idCard" column="stu_id_card"/&gt; &lt;result property="id" column="stu_id"/&gt; &lt;result property="name" column="stu_name"/&gt; &lt;result property="deleteFlag" column="stu_delete_flg"/&gt; &lt;!-- 这儿就是实现一对多的关键。 在Student中，courseList为List&lt;Course&gt;, 因此，ofType也应该与之对应（当然，我用了别名，不然要蛋疼的写全名了）。 collection的子标签是在指定Course的映射关系（由于Course的javabean的属性名与数据库的列名不一致） --&gt; &lt;collection property="courseList" column="stu_course_id" ofType="Course"&gt; &lt;id property="id" column="course_id"/&gt; &lt;result property="name" column="course_name"/&gt; &lt;result property="deleteFlag" column="course_delete_flg"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 这儿将返回类型设置成了上面指定的studentMap --&gt; &lt;select id="findStudentById" resultMap="studentMap"&gt; SELECT s.*, c.* FROM t_student s LEFT JOIN t_course c ON s.stu_course_id=c.course_id WHERE s.stu_id_card=#&#123;idCard&#125; &lt;/select&gt; &lt;/mapper&gt; StudentDaoTest.java12345678910111213141516171819202122232425262728public class StudentDaoTest &#123; @Test public void findCourseById() &#123; SqlSessionFactory sqlSessionFactory = getSessionFactory(); SqlSession sqlSession = sqlSessionFactory.openSession(); StudentDao studentDao = sqlSession.getMapper(StudentDao.class); Student student = studentDao.findStudentById("20140101"); List&lt;Course&gt; courseList = student.getCourseList(); for (Course course: courseList) &#123; System.out.println(course.getId() + " " + course.getName()); &#125; &#125; //Mybatis 通过SqlSessionFactory获取SqlSession, 然后才能通过SqlSession与数据库进行交互 private static SqlSessionFactory getSessionFactory() &#123; SqlSessionFactory sessionFactory = null; String resource = "mybatis-conf.xml"; try &#123; sessionFactory = new SqlSessionFactoryBuilder().build(Resources .getResourceAsReader(resource)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return sessionFactory; &#125; &#125; 相信通过以上demo， 大家也能够使用mybatis的select 和 resultMap的用法了。上面demo只演示了一对多的映射，其实多对一、多对多也与它类似，所以我就没演示了，有兴趣的可以自己动手再做做。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列七-mapper映射文件配置之insert、update、delete]]></title>
    <url>%2F%2Fblog%2Fmybatis-7%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（六）—objectFactory、plugins、mappers简介与配置》简单地给mybatis的配置画上了一个句号。那么从本篇文章开始，将会介绍mapper映射文件的配置， 这是mybatis的核心之一，一定要学好。在mapper文件中，以mapper作为根节点，其下面可以配置的元素节点有： select, insert, update, delete, cache, cache-ref, resultMap, sql 。 本篇文章将简单介绍 insert, update, delete 的配置及使用，以后会对mybatis的源码进行深入讲解。 相信，看到insert, update, delete， 我们就知道其作用了，顾名思义嘛，myabtis 作为持久层框架，必须要对CRUD啊。 好啦，咱们就先来看看 insert, update, delete 怎么配置， 能配置哪些元素吧： 相关元素配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN" "http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd"&gt; &lt;!-- mapper 为根元素节点， 一个namespace对应一个dao --&gt;&lt;mapper namespace="com.dy.dao.UserDao"&gt; &lt;insert &lt;!-- 1. id （必须配置） id是命名空间中的唯一标识符，可被用来代表这条语句。 一个命名空间（namespace） 对应一个dao接口, 这个id也应该对应dao里面的某个方法（相当于方法的实现），因此id 应该与方法名一致 --&gt; id="insertUser" &lt;!-- 2. parameterType （可选配置, 默认为mybatis自动选择处理） 将要传入语句的参数的完全限定类名或别名， 如果不配置，mybatis会通过ParameterHandler 根据参数类型默认选择合适的typeHandler进行处理 parameterType 主要指定参数类型，可以是int, short, long, string等类型，也可以是复杂类型（如对象） --&gt; parameterType="com.demo.User" &lt;!-- 3. flushCache （可选配置，默认配置为true） 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句） --&gt; flushCache="true" &lt;!-- 4. statementType （可选配置，默认配置为PREPARED） STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 --&gt; statementType="PREPARED" &lt;!-- 5. keyProperty (可选配置， 默认为unset) （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 --&gt; keyProperty="" &lt;!-- 6. keyColumn (可选配置) （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 --&gt; keyColumn="" &lt;!-- 7. useGeneratedKeys (可选配置， 默认为false) （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。 --&gt; useGeneratedKeys="false" &lt;!-- 8. timeout (可选配置， 默认为unset, 依赖驱动) 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 --&gt; timeout="20"&gt; &lt;update id="updateUser" parameterType="com.demo.User" flushCache="true" statementType="PREPARED" timeout="20"&gt; &lt;delete id="deleteUser" parameterType="com.demo.User" flushCache="true" statementType="PREPARED" timeout="20"&gt;&lt;/mapper&gt; 以上就是一个模板配置， 哪些是必要配置，哪些是根据自己实际需求，看一眼就知道了。 下面， 还是用第一篇文章《深入浅出Mybatis系列（一）—Mybatis入门》里面的demo来示例吧： User类1234567891011public class User &#123; private int id; private String name; private String password; private int age; private int deleteFlag; //setter和getter方法省略...&#125; UserDao类12345public interface UserDao &#123; public void insertUser (User user); public void updateUser (User user); public void deleteUser (User user);&#125; userDao.xml123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN" "http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.dy.dao.UserDao"&gt; &lt;!-- 对应userDao中的insertUser方法， --&gt; &lt;insert id="insertUser" parameterType="com.dy.entity.User"&gt; insert into user(id, name, password, age, deleteFlag) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;deleteFlag&#125;) &lt;/insert&gt; &lt;!-- 对应userDao中的updateUser方法 --&gt; &lt;update id="updateUser" parameterType="com.dy.entity.User"&gt; update user set name = #&#123;name&#125;, password = #&#123;password&#125;, age = #&#123;age&#125;, deleteFlag = #&#123;deleteFlag&#125; where id = #&#123;id&#125;; &lt;/update&gt; &lt;!-- 对应userDao中的deleteUser 方法 --&gt; &lt;delete id="deleteUser" parameterType="com.dy.entity.User"&gt; delete from user where id = #&#123;id&#125;; &lt;/delete&gt;&lt;/mapper&gt; 这样，一个简单的映射关系就建立了。仔细观察上面parameterType, “com.dy.entity.User”，包名要是再长点呢，每次都这样写，写得蛋疼了。别忘了之前讲的 typeAliases（别名）， 那么这个地方，用上别名，岂不是技能跟蛋疼的长长的包名说拜拜了。好啦，咱们配上别名，在哪儿配？ 当然是在mybatis 的全局配置文件（我这儿名字是mybatis-conf.xml）， 不要认为是在mapper的配置文件里面配置哈。 mybatis-conf.xml123456789&lt;typeAliases&gt; &lt;!-- 通过package, 可以直接指定package的名字， mybatis会自动扫描你指定包下面的javabean, 并且默认设置一个别名，默认的名字为： javabean 的首字母小写的非限定类名来作为它的别名。 也可在javabean 加上注解@Alias 来自定义别名， 例如： @Alias(user) &lt;package name="com.dy.entity"/&gt; --&gt; &lt;typeAlias alias="user" type="com.dy.entity.User"/&gt; &lt;/typeAliases&gt; 这样，一个别名就取好了，咱们可以把上面的 com.dy.entity.User 都直接改为user 了。 这多方便呀！ 我这儿数据库用的是mysql, 我把user表的主键id 设置了自动增长， 以上代码运行正常， 那么问题来了（当然，我不是要问学挖掘机哪家强），我要是换成oracle数据库怎么办？ oracle 可是不支持id自增长啊？ 怎么办？请看下面：123456789101112&lt;!-- 对应userDao中的insertUser方法， --&gt; &lt;insert id="insertUser" parameterType="com.dy.entity.User"&gt; &lt;!-- oracle等不支持id自增长的，可根据其id生成策略，先获取id &lt;selectKey resultType="int" order="BEFORE" keyProperty="id"&gt; select seq_user_id.nextval as id from dual &lt;/selectKey&gt; --&gt; insert into user(id, name, password, age, deleteFlag) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;deleteFlag&#125;) &lt;/insert&gt; 同理，如果我们在使用mysql的时候，想在数据插入后返回插入的id, 我们也可以使用 selectKey 这个元素：123456789101112131415161718&lt;!-- 对应userDao中的insertUser方法， --&gt; &lt;insert id="insertUser" parameterType="com.dy.entity.User"&gt; &lt;!-- oracle等不支持id自增长的，可根据其id生成策略，先获取id &lt;selectKey resultType="int" order="BEFORE" keyProperty="id"&gt; select seq_user_id.nextval as id from dual &lt;/selectKey&gt; --&gt; &lt;!-- mysql插入数据后，获取id --&gt; &lt;selectKey keyProperty="id" resultType="int" order="AFTER" &gt; SELECT LAST_INSERT_ID() as id &lt;/selectKey&gt; insert into user(id, name, password, age, deleteFlag) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;deleteFlag&#125;) &lt;/insert&gt; 这儿，我们就简单提一下 这个元素节点吧:123456789&lt;selectKey &lt;!-- selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 --&gt; keyProperty="id" &lt;!-- 结果的类型。MyBatis 通常可以推算出来，但是为了更加确定写上也不会有什么问题。MyBatis 允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。 --&gt; resultType="int" &lt;!-- 这可以被设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它会首先选择主键，设置 keyProperty 然后执行插入语句。如果设置为 AFTER，那么先执行插入语句，然后是 selectKey 元素 - 这和像 Oracle 的数据库相似，在插入语句内部可能有嵌入索引调用。 --&gt; order="BEFORE" &lt;!-- 与前面相同，MyBatis 支持 STATEMENT，PREPARED 和 CALLABLE 语句的映射类型，分别代表 PreparedStatement 和 CallableStatement 类型。 --&gt; statementType="PREPARED"&gt; 好啦，本篇文章主要介绍了insert, update, delete的配置及用法。 下篇文章将介绍复杂的 select相关的配置及用法， 待这些都讲完后，会先根据源码分析一下mybatis的整个运行流程，然后再深入mybatis的用法。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列六-objectFactory、plugins、mappers简介与配置]]></title>
    <url>%2F%2Fblog%2Fmybatis-6%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（五）—TypeHandler简介及配置（mybatis源码篇）》简单看了一下TypeHandler， 本次将结束对于mybatis的配置文件的学习， 本次涉及到剩下没提及到的几个节点的配置：objectFactory、databaseIdProvider、plugins、mappers。 那么，接下来，就简单介绍一下这几个配置的作用吧： 1、objectFactory是干什么的？ 需要配置吗？ MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。默认情况下，我们不需要配置，mybatis会调用默认实现的objectFactory。 除非我们要自定义ObjectFactory的实现， 那么我们才需要去手动配置。 那么怎么自定义实现ObjectFactory？ 怎么配置呢？ 自定义ObjectFactory只需要去继承DefaultObjectFactory（是ObjectFactory接口的实现类），并重写其方法即可。具体的，本处不多说，后面再具体讲解。 写好了ObjectFactory, 仅需做如下配置：1234567&lt;configuration&gt; ...... &lt;objectFactory type="org.mybatis.example.ExampleObjectFactory"&gt; &lt;property name="someProperty" value="100"/&gt; &lt;/objectFactory&gt; ...... &lt;/configuration plugin有何作用？ 需要配置吗？ plugins 是一个可选配置。mybatis中的plugin其实就是个interceptor， 它可以拦截Executor 、ParameterHandler 、ResultSetHandler 、StatementHandler 的部分方法，处理我们自己的逻辑。Executor就是真正执行sql语句的东西， ParameterHandler 是处理我们传入参数的，还记得前面讲TypeHandler的时候提到过，mybatis默认帮我们实现了不少的typeHandler, 当我们不显示配置typeHandler的时候，mybatis会根据参数类型自动选择合适的typeHandler执行，其实就是ParameterHandler 在选择。ResultSetHandler 就是处理返回结果的。 怎么自定义plugin? 怎么配置？ 要自定义一个plugin, 需要去实现Interceptor接口， 这儿不细说， 后面实战部分会详细讲解。定义好之后，配置如下：123456789&lt;configuration&gt; ...... &lt;plugins&gt; &lt;plugin interceptor="org.mybatis.example.ExamplePlugin"&gt; &lt;property name="someProperty" value="100"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; ...... &lt;/configuration&gt; mappers, 这下引出mybatis的核心之一了，mappers作用 ? 需要配置吗？ mappers 节点下，配置我们的mapper映射文件， 所谓的mapper映射文件，就是让mybatis 用来建立数据表和javabean映射的一个桥梁。在我们实际开发中，通常一个mapper文件对应一个dao接口， 这个mapper可以看做是dao的实现。所以,mappers必须配置。 那么怎么配置呢？123456789101112131415161718192021&lt;configuration&gt; ...... &lt;mappers&gt; &lt;!-- 第一种方式：通过resource指定 --&gt; &lt;mapper resource="com/dy/dao/userDao.xml"/&gt; &lt;!-- 第二种方式， 通过class指定接口，进而将接口与对应的xml文件形成映射关系 不过，使用这种方式必须保证 接口与mapper文件同名(不区分大小写)， 我这儿接口是UserDao,那么意味着mapper文件为UserDao.xml &lt;mapper class="com.dy.dao.UserDao"/&gt; --&gt; &lt;!-- 第三种方式，直接指定包，自动扫描，与方法二同理 &lt;package name="com.dy.dao"/&gt; --&gt; &lt;!-- 第四种方式：通过url指定mapper文件位置 &lt;mapper url="file://........"/&gt; --&gt; &lt;/mappers&gt; ...... &lt;/configuration&gt; 本篇仅作简单介绍， 更高级的使用以及其实现原理，会在后面的实战部分进行详细讲解。 这几个节点的解析源码，与之前提到的那些节点的解析类似，源码需要的可以从这里看看。 相关节点源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * objectFactory 节点解析 */private void objectFactoryElement(XNode context) throws Exception &#123; if (context != null) &#123; //读取type属性的值， 接下来进行实例化ObjectFactory, 并set进 configuration //到此，简单讲一下configuration这个对象，其实它里面主要保存的都是mybatis的配置 String type = context.getStringAttribute("type"); //读取propertie的值， 根据需要可以配置， mybatis默认实现的objectFactory没有使用properties Properties properties = context.getChildrenAsProperties(); ObjectFactory factory = (ObjectFactory) resolveClass(type).newInstance(); factory.setProperties(properties); configuration.setObjectFactory(factory); &#125; &#125; /** * plugins 节点解析 */ private void pluginElement(XNode parent) throws Exception &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; String interceptor = child.getStringAttribute("interceptor"); Properties properties = child.getChildrenAsProperties(); //由此可见，我们在定义一个interceptor的时候，需要去实现Interceptor, 这儿先不具体讲，以后会详细讲解 Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance(); interceptorInstance.setProperties(properties); configuration.addInterceptor(interceptorInstance); &#125; &#125; &#125; /** * mappers 节点解析 * 这是mybatis的核心之一，这儿先简单介绍，在接下来的文章会对它进行分析 */ private void mapperElement(XNode parent) throws Exception &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; if ("package".equals(child.getName())) &#123; //如果mappers节点的子节点是package, 那么就扫描package下的文件, 注入进configuration String mapperPackage = child.getStringAttribute("name"); configuration.addMappers(mapperPackage); &#125; else &#123; String resource = child.getStringAttribute("resource"); String url = child.getStringAttribute("url"); String mapperClass = child.getStringAttribute("class"); //resource, url, class 三选一 if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) &#123; ErrorContext.instance().resource(resource); InputStream inputStream = Resources.getResourceAsStream(resource); //mapper映射文件都是通过XMLMapperBuilder解析 XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments()); mapperParser.parse(); &#125; else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) &#123; ErrorContext.instance().resource(url); InputStream inputStream = Resources.getUrlAsStream(url); XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments()); mapperParser.parse(); &#125; else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) &#123; Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass); configuration.addMapper(mapperInterface); &#125; else &#123; throw new BuilderException("A mapper element may only specify a url, resource or class, but not more than one."); &#125; &#125; &#125; &#125; &#125; 本次就简单的到此结束， 从下篇文章开始，将会开始接触到mybatis的核心部分，不过首先还是要讲mapper文件的配置及使用， 并通过源码进一步深入核心。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列五-TypeHandler简介及配置（mybatis源码篇）]]></title>
    <url>%2F%2Fblog%2Fmybatis-5%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（四）—配置详解之typeAliases别名（mybatis源码篇）》为大家介绍了mybatis中别名的使用，以及其源码。本篇将为大家介绍TypeHandler， 并简单分析其源码。 Mybatis中的TypeHandler是什么？ 无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时，都会用类型处理器将获取的值以合适的方式转换成 Java 类型。Mybatis默认为我们实现了许多TypeHandler, 当我们没有配置指定TypeHandler时，Mybatis会根据参数或者返回结果的不同，默认为我们选择合适的TypeHandler处理。 那么，Mybatis为我们实现了哪些TypeHandler呢? 我们怎么自定义实现一个TypeHandler ? 这些都会在接下来的mybatis的源码中看到。 在看源码之前，还是像之前一样，先看看怎么配置吧？ 配置TypeHandler123456789101112131415161718192021222324&lt;configuration&gt; &lt;typeHandlers&gt; &lt;!-- 当配置package的时候，mybatis会去配置的package扫描TypeHandler &lt;package name="com.dy.demo"/&gt; --&gt; &lt;!-- handler属性直接配置我们要指定的TypeHandler --&gt; &lt;typeHandler handler=""/&gt; &lt;!-- javaType 配置java类型，例如String, 如果配上javaType, 那么指定的typeHandler就只作用于指定的类型 --&gt; &lt;typeHandler javaType="" handler=""/&gt; &lt;!-- jdbcType 配置数据库基本数据类型，例如varchar, 如果配上jdbcType, 那么指定的typeHandler就只作用于指定的类型 --&gt; &lt;typeHandler jdbcType="" handler=""/&gt; &lt;!-- 也可两者都配置 --&gt; &lt;typeHandler javaType="" jdbcType="" handler=""/&gt; &lt;/typeHandlers&gt; ...... &lt;/configuration&gt; 上面简单介绍了一下TypeHandler, 下面就看看mybatis中TypeHandler的源码了。 老规矩，先从对xml的解析讲起： typeHandlers节点源码12345678910111213141516171819202122232425262728293031323334353637/** * 解析typeHandlers节点 */private void typeHandlerElement(XNode parent) throws Exception &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; //子节点为package时，获取其name属性的值，然后自动扫描package下的自定义typeHandler if ("package".equals(child.getName())) &#123; String typeHandlerPackage = child.getStringAttribute("name"); typeHandlerRegistry.register(typeHandlerPackage); &#125; else &#123; //子节点为typeHandler时， 可以指定javaType属性， 也可以指定jdbcType, 也可两者都指定 //javaType 是指定java类型 //jdbcType 是指定jdbc类型（数据库类型： 如varchar） String javaTypeName = child.getStringAttribute("javaType"); String jdbcTypeName = child.getStringAttribute("jdbcType"); //handler就是我们配置的typeHandler String handlerTypeName = child.getStringAttribute("handler"); //resolveClass方法就是我们上篇文章所讲的TypeAliasRegistry里面处理别名的方法 Class&lt;?&gt; javaTypeClass = resolveClass(javaTypeName); //JdbcType是一个枚举类型，resolveJdbcType方法是在获取枚举类型的值 JdbcType jdbcType = resolveJdbcType(jdbcTypeName); Class&lt;?&gt; typeHandlerClass = resolveClass(handlerTypeName); //注册typeHandler, typeHandler通过TypeHandlerRegistry这个类管理 if (javaTypeClass != null) &#123; if (jdbcType == null) &#123; typeHandlerRegistry.register(javaTypeClass, typeHandlerClass); &#125; else &#123; typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass); &#125; &#125; else &#123; typeHandlerRegistry.register(typeHandlerClass); &#125; &#125; &#125; &#125;&#125; 接下来看看TypeHandler的管理注册类： TypeHandlerRegistry源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347/** * typeHandler注册管理类 */public final class TypeHandlerRegistry &#123; //源码一上来，二话不说，几个大大的HashMap就出现，这不又跟上次讲的typeAliases的注册类似么 //基本数据类型与其包装类 private static final Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; reversePrimitiveMap = new HashMap&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;() &#123; private static final long serialVersionUID = 1L; &#123; put(Byte.class, byte.class); put(Short.class, short.class); put(Integer.class, int.class); put(Long.class, long.class); put(Float.class, float.class); put(Double.class, double.class); put(Boolean.class, boolean.class); put(Character.class, char.class); &#125; &#125;; //这几个MAP不用说就知道存的是什么东西吧，命名的好处 private final Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; JDBC_TYPE_HANDLER_MAP = new EnumMap&lt;JdbcType, TypeHandler&lt;?&gt;&gt;(JdbcType.class); private final Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; TYPE_HANDLER_MAP = new HashMap&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt;(); private final TypeHandler&lt;Object&gt; UNKNOWN_TYPE_HANDLER = new UnknownTypeHandler(this); private final Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; ALL_TYPE_HANDLERS_MAP = new HashMap&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt;(); //就像上篇文章讲的typeAliases一样，mybatis也默认给我们注册了不少的typeHandler //具体如下 public TypeHandlerRegistry() &#123; register(Boolean.class, new BooleanTypeHandler()); register(boolean.class, new BooleanTypeHandler()); register(JdbcType.BOOLEAN, new BooleanTypeHandler()); register(JdbcType.BIT, new BooleanTypeHandler()); register(Byte.class, new ByteTypeHandler()); register(byte.class, new ByteTypeHandler()); register(JdbcType.TINYINT, new ByteTypeHandler()); register(Short.class, new ShortTypeHandler()); register(short.class, new ShortTypeHandler()); register(JdbcType.SMALLINT, new ShortTypeHandler()); register(Integer.class, new IntegerTypeHandler()); register(int.class, new IntegerTypeHandler()); register(JdbcType.INTEGER, new IntegerTypeHandler()); register(Long.class, new LongTypeHandler()); register(long.class, new LongTypeHandler()); register(Float.class, new FloatTypeHandler()); register(float.class, new FloatTypeHandler()); register(JdbcType.FLOAT, new FloatTypeHandler()); register(Double.class, new DoubleTypeHandler()); register(double.class, new DoubleTypeHandler()); register(JdbcType.DOUBLE, new DoubleTypeHandler()); register(String.class, new StringTypeHandler()); register(String.class, JdbcType.CHAR, new StringTypeHandler()); register(String.class, JdbcType.CLOB, new ClobTypeHandler()); register(String.class, JdbcType.VARCHAR, new StringTypeHandler()); register(String.class, JdbcType.LONGVARCHAR, new ClobTypeHandler()); register(String.class, JdbcType.NVARCHAR, new NStringTypeHandler()); register(String.class, JdbcType.NCHAR, new NStringTypeHandler()); register(String.class, JdbcType.NCLOB, new NClobTypeHandler()); register(JdbcType.CHAR, new StringTypeHandler()); register(JdbcType.VARCHAR, new StringTypeHandler()); register(JdbcType.CLOB, new ClobTypeHandler()); register(JdbcType.LONGVARCHAR, new ClobTypeHandler()); register(JdbcType.NVARCHAR, new NStringTypeHandler()); register(JdbcType.NCHAR, new NStringTypeHandler()); register(JdbcType.NCLOB, new NClobTypeHandler()); register(Object.class, JdbcType.ARRAY, new ArrayTypeHandler()); register(JdbcType.ARRAY, new ArrayTypeHandler()); register(BigInteger.class, new BigIntegerTypeHandler()); register(JdbcType.BIGINT, new LongTypeHandler()); register(BigDecimal.class, new BigDecimalTypeHandler()); register(JdbcType.REAL, new BigDecimalTypeHandler()); register(JdbcType.DECIMAL, new BigDecimalTypeHandler()); register(JdbcType.NUMERIC, new BigDecimalTypeHandler()); register(Byte[].class, new ByteObjectArrayTypeHandler()); register(Byte[].class, JdbcType.BLOB, new BlobByteObjectArrayTypeHandler()); register(Byte[].class, JdbcType.LONGVARBINARY, new BlobByteObjectArrayTypeHandler()); register(byte[].class, new ByteArrayTypeHandler()); register(byte[].class, JdbcType.BLOB, new BlobTypeHandler()); register(byte[].class, JdbcType.LONGVARBINARY, new BlobTypeHandler()); register(JdbcType.LONGVARBINARY, new BlobTypeHandler()); register(JdbcType.BLOB, new BlobTypeHandler()); register(Object.class, UNKNOWN_TYPE_HANDLER); register(Object.class, JdbcType.OTHER, UNKNOWN_TYPE_HANDLER); register(JdbcType.OTHER, UNKNOWN_TYPE_HANDLER); register(Date.class, new DateTypeHandler()); register(Date.class, JdbcType.DATE, new DateOnlyTypeHandler()); register(Date.class, JdbcType.TIME, new TimeOnlyTypeHandler()); register(JdbcType.TIMESTAMP, new DateTypeHandler()); register(JdbcType.DATE, new DateOnlyTypeHandler()); register(JdbcType.TIME, new TimeOnlyTypeHandler()); register(java.sql.Date.class, new SqlDateTypeHandler()); register(java.sql.Time.class, new SqlTimeTypeHandler()); register(java.sql.Timestamp.class, new SqlTimestampTypeHandler()); // issue #273 register(Character.class, new CharacterTypeHandler()); register(char.class, new CharacterTypeHandler()); &#125; public boolean hasTypeHandler(Class&lt;?&gt; javaType) &#123; return hasTypeHandler(javaType, null); &#125; public boolean hasTypeHandler(TypeReference&lt;?&gt; javaTypeReference) &#123; return hasTypeHandler(javaTypeReference, null); &#125; public boolean hasTypeHandler(Class&lt;?&gt; javaType, JdbcType jdbcType) &#123; return javaType != null &amp;&amp; getTypeHandler((Type) javaType, jdbcType) != null; &#125; public boolean hasTypeHandler(TypeReference&lt;?&gt; javaTypeReference, JdbcType jdbcType) &#123; return javaTypeReference != null &amp;&amp; getTypeHandler(javaTypeReference, jdbcType) != null; &#125; public TypeHandler&lt;?&gt; getMappingTypeHandler(Class&lt;? extends TypeHandler&lt;?&gt;&gt; handlerType) &#123; return ALL_TYPE_HANDLERS_MAP.get(handlerType); &#125; public &lt;T&gt; TypeHandler&lt;T&gt; getTypeHandler(Class&lt;T&gt; type) &#123; return getTypeHandler((Type) type, null); &#125; public &lt;T&gt; TypeHandler&lt;T&gt; getTypeHandler(TypeReference&lt;T&gt; javaTypeReference) &#123; return getTypeHandler(javaTypeReference, null); &#125; public TypeHandler&lt;?&gt; getTypeHandler(JdbcType jdbcType) &#123; return JDBC_TYPE_HANDLER_MAP.get(jdbcType); &#125; public &lt;T&gt; TypeHandler&lt;T&gt; getTypeHandler(Class&lt;T&gt; type, JdbcType jdbcType) &#123; return getTypeHandler((Type) type, jdbcType); &#125; public &lt;T&gt; TypeHandler&lt;T&gt; getTypeHandler(TypeReference&lt;T&gt; javaTypeReference, JdbcType jdbcType) &#123; return getTypeHandler(javaTypeReference.getRawType(), jdbcType); &#125; private &lt;T&gt; TypeHandler&lt;T&gt; getTypeHandler(Type type, JdbcType jdbcType) &#123; Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; jdbcHandlerMap = TYPE_HANDLER_MAP.get(type); TypeHandler&lt;?&gt; handler = null; if (jdbcHandlerMap != null) &#123; handler = jdbcHandlerMap.get(jdbcType); if (handler == null) &#123; handler = jdbcHandlerMap.get(null); &#125; &#125; if (handler == null &amp;&amp; type != null &amp;&amp; type instanceof Class &amp;&amp; Enum.class.isAssignableFrom((Class&lt;?&gt;) type)) &#123; handler = new EnumTypeHandler((Class&lt;?&gt;) type); &#125; @SuppressWarnings("unchecked") // type drives generics here TypeHandler&lt;T&gt; returned = (TypeHandler&lt;T&gt;) handler; return returned; &#125; public TypeHandler&lt;Object&gt; getUnknownTypeHandler() &#123; return UNKNOWN_TYPE_HANDLER; &#125; public void register(JdbcType jdbcType, TypeHandler&lt;?&gt; handler) &#123; JDBC_TYPE_HANDLER_MAP.put(jdbcType, handler); &#125; // // REGISTER INSTANCE // /** * 只配置了typeHandler, 没有配置jdbcType 或者javaType */ @SuppressWarnings("unchecked") public &lt;T&gt; void register(TypeHandler&lt;T&gt; typeHandler) &#123; boolean mappedTypeFound = false; //在自定义typeHandler的时候，可以加上注解MappedTypes 去指定关联的javaType //因此，此处需要扫描MappedTypes注解 MappedTypes mappedTypes = typeHandler.getClass().getAnnotation(MappedTypes.class); if (mappedTypes != null) &#123; for (Class&lt;?&gt; handledType : mappedTypes.value()) &#123; register(handledType, typeHandler); mappedTypeFound = true; &#125; &#125; // @since 3.1.0 - try to auto-discover the mapped type if (!mappedTypeFound &amp;&amp; typeHandler instanceof TypeReference) &#123; try &#123; TypeReference&lt;T&gt; typeReference = (TypeReference&lt;T&gt;) typeHandler; register(typeReference.getRawType(), typeHandler); mappedTypeFound = true; &#125; catch (Throwable t) &#123; // maybe users define the TypeReference with a different type and are not assignable, so just ignore it &#125; &#125; if (!mappedTypeFound) &#123; register((Class&lt;T&gt;) null, typeHandler); &#125; &#125; /** * 配置了typeHandlerhe和javaType */ public &lt;T&gt; void register(Class&lt;T&gt; javaType, TypeHandler&lt;? extends T&gt; typeHandler) &#123; register((Type) javaType, typeHandler); &#125; private &lt;T&gt; void register(Type javaType, TypeHandler&lt;? extends T&gt; typeHandler) &#123; //扫描注解MappedJdbcTypes MappedJdbcTypes mappedJdbcTypes = typeHandler.getClass().getAnnotation(MappedJdbcTypes.class); if (mappedJdbcTypes != null) &#123; for (JdbcType handledJdbcType : mappedJdbcTypes.value()) &#123; register(javaType, handledJdbcType, typeHandler); &#125; if (mappedJdbcTypes.includeNullJdbcType()) &#123; register(javaType, null, typeHandler); &#125; &#125; else &#123; register(javaType, null, typeHandler); &#125; &#125; public &lt;T&gt; void register(TypeReference&lt;T&gt; javaTypeReference, TypeHandler&lt;? extends T&gt; handler) &#123; register(javaTypeReference.getRawType(), handler); &#125; /** * typeHandlerhe、javaType、jdbcType都配置了 */ public &lt;T&gt; void register(Class&lt;T&gt; type, JdbcType jdbcType, TypeHandler&lt;? extends T&gt; handler) &#123; register((Type) type, jdbcType, handler); &#125; /** * 注册typeHandler的核心方法 * 就是向Map新增数据而已 */ private void register(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler) &#123; if (javaType != null) &#123; Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = TYPE_HANDLER_MAP.get(javaType); if (map == null) &#123; map = new HashMap&lt;JdbcType, TypeHandler&lt;?&gt;&gt;(); TYPE_HANDLER_MAP.put(javaType, map); &#125; map.put(jdbcType, handler); if (reversePrimitiveMap.containsKey(javaType)) &#123; register(reversePrimitiveMap.get(javaType), jdbcType, handler); &#125; &#125; ALL_TYPE_HANDLERS_MAP.put(handler.getClass(), handler); &#125; // // REGISTER CLASS // // Only handler type public void register(Class&lt;?&gt; typeHandlerClass) &#123; boolean mappedTypeFound = false; MappedTypes mappedTypes = typeHandlerClass.getAnnotation(MappedTypes.class); if (mappedTypes != null) &#123; for (Class&lt;?&gt; javaTypeClass : mappedTypes.value()) &#123; register(javaTypeClass, typeHandlerClass); mappedTypeFound = true; &#125; &#125; if (!mappedTypeFound) &#123; register(getInstance(null, typeHandlerClass)); &#125; &#125; // java type + handler type public void register(Class&lt;?&gt; javaTypeClass, Class&lt;?&gt; typeHandlerClass) &#123; register(javaTypeClass, getInstance(javaTypeClass, typeHandlerClass)); &#125; // java type + jdbc type + handler type public void register(Class&lt;?&gt; javaTypeClass, JdbcType jdbcType, Class&lt;?&gt; typeHandlerClass) &#123; register(javaTypeClass, jdbcType, getInstance(javaTypeClass, typeHandlerClass)); &#125; // Construct a handler (used also from Builders) @SuppressWarnings("unchecked") public &lt;T&gt; TypeHandler&lt;T&gt; getInstance(Class&lt;?&gt; javaTypeClass, Class&lt;?&gt; typeHandlerClass) &#123; if (javaTypeClass != null) &#123; try &#123; Constructor&lt;?&gt; c = typeHandlerClass.getConstructor(Class.class); return (TypeHandler&lt;T&gt;) c.newInstance(javaTypeClass); &#125; catch (NoSuchMethodException ignored) &#123; // ignored &#125; catch (Exception e) &#123; throw new TypeException("Failed invoking constructor for handler " + typeHandlerClass, e); &#125; &#125; try &#123; Constructor&lt;?&gt; c = typeHandlerClass.getConstructor(); return (TypeHandler&lt;T&gt;) c.newInstance(); &#125; catch (Exception e) &#123; throw new TypeException("Unable to find a usable constructor for " + typeHandlerClass, e); &#125; &#125; /** * 根据指定的pacakge去扫描自定义的typeHander，然后注册 */ public void register(String packageName) &#123; ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;Class&lt;?&gt;&gt;(); resolverUtil.find(new ResolverUtil.IsA(TypeHandler.class), packageName); Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; handlerSet = resolverUtil.getClasses(); for (Class&lt;?&gt; type : handlerSet) &#123; //Ignore inner classes and interfaces (including package-info.java) and abstract classes if (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !Modifier.isAbstract(type.getModifiers())) &#123; register(type); &#125; &#125; &#125; // get information /** * 通过configuration对象可以获取已注册的所有typeHandler */ public Collection&lt;TypeHandler&lt;?&gt;&gt; getTypeHandlers() &#123; return Collections.unmodifiableCollection(ALL_TYPE_HANDLERS_MAP.values()); &#125; &#125; 由源码可以看到， mybatis为我们实现了那么多TypeHandler, 随便打开一个TypeHandler，看其源码，都可以看到，它继承自一个抽象类：BaseTypeHandler， 那么我们是不是也能通过继承BaseTypeHandler，从而实现自定义的TypeHandler ? 答案是肯定的， 那么现在下面就为大家演示一下自定义TypeHandler: 自定义TypeHandler123456789101112131415161718192021222324@MappedJdbcTypes(JdbcType.VARCHAR) //此处如果不用注解指定jdbcType, 那么，就可以在配置文件中通过"jdbcType"属性指定， 同理， javaType 也可通过 @MappedTypes指定public class ExampleTypeHandler extends BaseTypeHandler&lt;String&gt; &#123; @Override public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException &#123; ps.setString(i, parameter); &#125; @Override public String getNullableResult(ResultSet rs, String columnName) throws SQLException &#123; return rs.getString(columnName); &#125; @Override public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123; return rs.getString(columnIndex); &#125; @Override public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123; return cs.getString(columnIndex); &#125;&#125; 然后，就该配置我们的自定义TypeHandler了：123456789&lt;configuration&gt; &lt;typeHandlers&gt; &lt;!-- 由于自定义的TypeHandler在定义时已经通过注解指定了jdbcType, 所以此处不用再配置jdbcType --&gt; &lt;typeHandler handler="ExampleTypeHandler"/&gt; &lt;/typeHandlers&gt; ...... &lt;/configuration&gt; 也就是说，我们在自定义TypeHandler的时候，可以在TypeHandler通过@MappedJdbcTypes指定jdbcType, 通过 @MappedTypes 指定javaType, 如果没有使用注解指定，那么我们就需要在配置文件中配置。 好啦，本篇文章到此结束。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列四-配置详解之typeAliases别名（mybatis源码篇）]]></title>
    <url>%2F%2Fblog%2Fmybatis-4%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（三）—配置详解之properties与environments（mybatis源码篇）》 介绍了properties与environments， 本篇继续讲剩下的配置节点之一：typeAliases。 typeAliases节点主要用来设置别名，其实这是挺好用的一个功能， 通过配置别名，我们不用再指定完整的包名，并且还能取别名。 例如： 我们在使用 com.demo.entity. UserEntity 的时候，我们可以直接配置一个别名user, 这样以后在配置文件中要使用到com.demo.entity. UserEntity的时候，直接使用User即可。 就以上例为例，我们来实现一下，看看typeAliases的配置方法: typeAliases配置1234567891011121314&lt;configuration&gt; &lt;typeAliases&gt; &lt;!-- 通过package, 可以直接指定package的名字， mybatis会自动扫描你指定包下面的javabean, 并且默认设置一个别名，默认的名字为： javabean 的首字母小写的非限定类名来作为它的别名。 也可在javabean 加上注解@Alias 来自定义别名， 例如： @Alias(user) &lt;package name="com.dy.entity"/&gt; --&gt; &lt;typeAlias alias="UserEntity" type="com.dy.entity.User"/&gt; &lt;/typeAliases&gt; ...... &lt;/configuration&gt; 再写一段测试代码，看看有没生效：（我只写一段伪代码）12345Configuration con = sqlSessionFactory.getConfiguration();Map&lt;String, Class&lt;?&gt;&gt; typeMap = con.getTypeAliasRegistry().getTypeAliases();for(Entry&lt;String, Class&lt;?&gt;&gt; entry: typeMap.entrySet()) &#123; System.out.println(entry.getKey() + " ================&gt; " + entry.getValue().getSimpleName());&#125; 上面给大家简单介绍了typeAliases的用法， 接下来就看看Mybatis中的源码了。 老规矩，先从对xml的解析讲起： typeAliases源码1234567891011121314151617181920212223242526272829/** * 解析typeAliases节点 */private void typeAliasesElement(XNode parent) &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; //如果子节点是package, 那么就获取package节点的name属性， mybatis会扫描指定的package if ("package".equals(child.getName())) &#123; String typeAliasPackage = child.getStringAttribute("name"); //TypeAliasRegistry 负责管理别名， 这儿就是通过TypeAliasRegistry 进行别名注册， 下面就会看看TypeAliasRegistry源码 configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage); &#125; else &#123; //如果子节点是typeAlias节点，那么就获取alias属性和type的属性值 String alias = child.getStringAttribute("alias"); String type = child.getStringAttribute("type"); try &#123; Class&lt;?&gt; clazz = Resources.classForName(type); if (alias == null) &#123; typeAliasRegistry.registerAlias(clazz); &#125; else &#123; typeAliasRegistry.registerAlias(alias, clazz); &#125; &#125; catch (ClassNotFoundException e) &#123; throw new BuilderException("Error registering typeAlias for '" + alias + "'. Cause: " + e, e); &#125; &#125; &#125; &#125; &#125; 重要的源码在这儿! TypeAliasRegistry源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147public class TypeAliasRegistry &#123; //这就是核心所在啊， 原来别名就仅仅通过一个HashMap来实现， key为别名， value就是别名对应的类型（class对象） private final Map&lt;String, Class&lt;?&gt;&gt; TYPE_ALIASES = new HashMap&lt;String, Class&lt;?&gt;&gt;(); /** * 以下就是mybatis默认为我们注册的别名 */ public TypeAliasRegistry() &#123; registerAlias("string", String.class); registerAlias("byte", Byte.class); registerAlias("long", Long.class); registerAlias("short", Short.class); registerAlias("int", Integer.class); registerAlias("integer", Integer.class); registerAlias("double", Double.class); registerAlias("float", Float.class); registerAlias("boolean", Boolean.class); registerAlias("byte[]", Byte[].class); registerAlias("long[]", Long[].class); registerAlias("short[]", Short[].class); registerAlias("int[]", Integer[].class); registerAlias("integer[]", Integer[].class); registerAlias("double[]", Double[].class); registerAlias("float[]", Float[].class); registerAlias("boolean[]", Boolean[].class); registerAlias("_byte", byte.class); registerAlias("_long", long.class); registerAlias("_short", short.class); registerAlias("_int", int.class); registerAlias("_integer", int.class); registerAlias("_double", double.class); registerAlias("_float", float.class); registerAlias("_boolean", boolean.class); registerAlias("_byte[]", byte[].class); registerAlias("_long[]", long[].class); registerAlias("_short[]", short[].class); registerAlias("_int[]", int[].class); registerAlias("_integer[]", int[].class); registerAlias("_double[]", double[].class); registerAlias("_float[]", float[].class); registerAlias("_boolean[]", boolean[].class); registerAlias("date", Date.class); registerAlias("decimal", BigDecimal.class); registerAlias("bigdecimal", BigDecimal.class); registerAlias("biginteger", BigInteger.class); registerAlias("object", Object.class); registerAlias("date[]", Date[].class); registerAlias("decimal[]", BigDecimal[].class); registerAlias("bigdecimal[]", BigDecimal[].class); registerAlias("biginteger[]", BigInteger[].class); registerAlias("object[]", Object[].class); registerAlias("map", Map.class); registerAlias("hashmap", HashMap.class); registerAlias("list", List.class); registerAlias("arraylist", ArrayList.class); registerAlias("collection", Collection.class); registerAlias("iterator", Iterator.class); registerAlias("ResultSet", ResultSet.class); &#125; /** * 处理别名， 直接从保存有别名的hashMap中取出即可 */ @SuppressWarnings("unchecked") public &lt;T&gt; Class&lt;T&gt; resolveAlias(String string) &#123; try &#123; if (string == null) return null; String key = string.toLowerCase(Locale.ENGLISH); // issue #748 Class&lt;T&gt; value; if (TYPE_ALIASES.containsKey(key)) &#123; value = (Class&lt;T&gt;) TYPE_ALIASES.get(key); &#125; else &#123; value = (Class&lt;T&gt;) Resources.classForName(string); &#125; return value; &#125; catch (ClassNotFoundException e) &#123; throw new TypeException("Could not resolve type alias '" + string + "'. Cause: " + e, e); &#125; &#125; /** * 配置文件中配置为package的时候， 会调用此方法，根据配置的报名去扫描javabean ，然后自动注册别名 * 默认会使用 Bean 的首字母小写的非限定类名来作为它的别名 * 也可在javabean 加上注解@Alias 来自定义别名， 例如： @Alias(user) */ public void registerAliases(String packageName)&#123; registerAliases(packageName, Object.class); &#125; public void registerAliases(String packageName, Class&lt;?&gt; superType)&#123; ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;Class&lt;?&gt;&gt;(); resolverUtil.find(new ResolverUtil.IsA(superType), packageName); Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; typeSet = resolverUtil.getClasses(); for(Class&lt;?&gt; type : typeSet)&#123; // Ignore inner classes and interfaces (including package-info.java) // Skip also inner classes. See issue #6 if (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !type.isMemberClass()) &#123; registerAlias(type); &#125; &#125; &#125; public void registerAlias(Class&lt;?&gt; type) &#123; String alias = type.getSimpleName(); Alias aliasAnnotation = type.getAnnotation(Alias.class); if (aliasAnnotation != null) &#123; alias = aliasAnnotation.value(); &#125; registerAlias(alias, type); &#125; //这就是注册别名的本质方法， 其实就是向保存别名的hashMap新增值而已， 呵呵， 别名的实现太简单了，对吧 public void registerAlias(String alias, Class&lt;?&gt; value) &#123; if (alias == null) throw new TypeException("The parameter alias cannot be null"); String key = alias.toLowerCase(Locale.ENGLISH); // issue #748 if (TYPE_ALIASES.containsKey(key) &amp;&amp; TYPE_ALIASES.get(key) != null &amp;&amp; !TYPE_ALIASES.get(key).equals(value)) &#123; throw new TypeException("The alias '" + alias + "' is already mapped to the value '" + TYPE_ALIASES.get(key).getName() + "'."); &#125; TYPE_ALIASES.put(key, value); &#125; public void registerAlias(String alias, String value) &#123; try &#123; registerAlias(alias, Resources.classForName(value)); &#125; catch (ClassNotFoundException e) &#123; throw new TypeException("Error registering type alias "+alias+" for "+value+". Cause: " + e, e); &#125; &#125; /** * 获取保存别名的HashMap, Configuration对象持有对TypeAliasRegistry的引用，因此，如果需要，我们可以通过Configuration对象获取 */ public Map&lt;String, Class&lt;?&gt;&gt; getTypeAliases() &#123; return Collections.unmodifiableMap(TYPE_ALIASES); &#125;&#125; 由源码可见，设置别名的原理就这么简单，Mybatis默认给我们设置了不少别名，在上面代码中都可以见到。 好啦，本篇内容就是这么简单，到此为止。 下篇将继续讲解还没讲完的配置节点。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列三-配置详解之properties与environments（mybatis源码篇）]]></title>
    <url>%2F%2Fblog%2Fmybatis-3%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（二）—配置简介（mybatis源码篇）》我们通过对mybatis源码的简单分析，可看出，在mybatis配置文件中，在configuration根节点下面，可配置properties、typeAliases、plugins、objectFactory、objectWrapperFactory、settings、environments、databaseIdProvider、typeHandlers、mappers这些节点。那么本次，就会先介绍properties节点和environments节点。 为了让大家能够更好地阅读mybatis源码，我先简单的给大家示例一下properties的使用方法。 properties节点1234567891011&lt;configuration&gt;&lt;!-- 方法一： 从外部指定properties配置文件, 除了使用resource属性指定外，还可通过url属性指定url &lt;properties resource="dbConfig.properties"&gt;&lt;/properties&gt; --&gt; &lt;!-- 方法二： 直接配置为xml --&gt; &lt;properties&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test1"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/properties&gt; 那么，我要是 两种方法都同时用了，那么哪种方法优先？当以上两种方法都xml配置优先， 外部指定properties配置其次。至于为什么，接下来的源码分析会提到，请留意一下。 再看一下envirements元素节点的使用方法吧. envirements节点12345678910111213141516171819202122232425262728293031323334&lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 如果上面没有指定数据库配置的properties文件，那么此处可以这样直接配置 &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test1"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; --&gt; &lt;!-- 上面指定了数据库配置文件， 配置文件里面也是对应的这四个属性 --&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!-- 我再指定一个environment --&gt; &lt;environment id="test"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;!-- 与上面的url不一样 --&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/demo"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; environments元素节点可以配置多个environment子节点， 怎么理解呢？ 假如我们系统的开发环境和正式环境所用的数据库不一样（这是肯定的）， 那么可以设置两个environment, 两个id分别对应开发环境（dev）和正式环境（final），那么通过配置environments的default属性就能选择对应的environment了， 例如，我将environments的deault属性的值配置为dev, 那么就会选择dev的environment。 至于这个是怎么实现的， 下面源码就会讲。 好啦，上面简单给大家介绍了一下properties 和 environments 的配置， 接下来就正式开始看源码了： 上次我们说过mybatis 是通过XMLConfigBuilder这个类在解析mybatis配置文件的，那么本次就接着看看XMLConfigBuilder对于properties和environments的解析。 XMLConfigBuilder源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class XMLConfigBuilder extends BaseBuilder &#123; private boolean parsed; //xml解析器 private XPathParser parser; private String environment; //上次说到这个方法是在解析mybatis配置文件中能配置的元素节点 //今天首先要看的就是properties节点和environments节点 private void parseConfiguration(XNode root) &#123; try &#123; //解析properties元素 propertiesElement(root.evalNode("properties")); //issue #117 read properties first typeAliasesElement(root.evalNode("typeAliases")); pluginElement(root.evalNode("plugins")); objectFactoryElement(root.evalNode("objectFactory")); objectWrapperFactoryElement(root.evalNode("objectWrapperFactory")); settingsElement(root.evalNode("settings")); //解析environments元素 environmentsElement(root.evalNode("environments")); // read it after objectFactory and objectWrapperFactory issue #631 databaseIdProviderElement(root.evalNode("databaseIdProvider")); typeHandlerElement(root.evalNode("typeHandlers")); mapperElement(root.evalNode("mappers")); &#125; catch (Exception e) &#123; throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e); &#125; &#125; //下面就看看解析properties的具体方法 private void propertiesElement(XNode context) throws Exception &#123; if (context != null) &#123; //将子节点的 name 以及value属性set进properties对象 //这儿可以注意一下顺序，xml配置优先， 外部指定properties配置其次 Properties defaults = context.getChildrenAsProperties(); //获取properties节点上 resource属性的值 String resource = context.getStringAttribute("resource"); //获取properties节点上 url属性的值, resource和url不能同时配置 String url = context.getStringAttribute("url"); if (resource != null &amp;&amp; url != null) &#123; throw new BuilderException("The properties element cannot specify both a URL and a resource based property file reference. Please specify one or the other."); &#125; //把解析出的properties文件set进Properties对象 if (resource != null) &#123; defaults.putAll(Resources.getResourceAsProperties(resource)); &#125; else if (url != null) &#123; defaults.putAll(Resources.getUrlAsProperties(url)); &#125; //将configuration对象中已配置的Properties属性与刚刚解析的融合 //configuration这个对象会装载所解析mybatis配置文件的所有节点元素，以后也会频频提到这个对象 //既然configuration对象用有一系列的get/set方法， 那是否就标志着我们可以使用java代码直接配置？ //答案是肯定的， 不过使用配置文件进行配置，优势不言而喻 Properties vars = configuration.getVariables(); if (vars != null) &#123; defaults.putAll(vars); &#125; //把装有解析配置propertis对象set进解析器， 因为后面可能会用到 parser.setVariables(defaults); //set进configuration对象 configuration.setVariables(defaults); &#125; &#125; //下面再看看解析enviroments元素节点的方法 private void environmentsElement(XNode context) throws Exception &#123; if (context != null) &#123; if (environment == null) &#123; //解析environments节点的default属性的值 //例如: &lt;environments default="development"&gt; environment = context.getStringAttribute("default"); &#125; //递归解析environments子节点 for (XNode child : context.getChildren()) &#123; //&lt;environment id="development"&gt;, 只有enviroment节点有id属性，那么这个属性有何作用？ //environments 节点下可以拥有多个 environment子节点 //类似于这样： &lt;environments default="development"&gt;&lt;environment id="development"&gt;...&lt;/environment&gt;&lt;environment id="test"&gt;...&lt;/environments&gt; //意思就是我们可以对应多个环境，比如开发环境，测试环境等， 由environments的default属性去选择对应的enviroment String id = child.getStringAttribute("id"); //isSpecial就是根据由environments的default属性去选择对应的enviroment if (isSpecifiedEnvironment(id)) &#123; //事务， mybatis有两种：JDBC 和 MANAGED, 配置为JDBC则直接使用JDBC的事务，配置为MANAGED则是将事务托管给容器， TransactionFactory txFactory = transactionManagerElement(child.evalNode("transactionManager")); //enviroment节点下面就是dataSource节点了，解析dataSource节点（下面会贴出解析dataSource的具体方法） DataSourceFactory dsFactory = dataSourceElement(child.evalNode("dataSource")); DataSource dataSource = dsFactory.getDataSource(); Environment.Builder environmentBuilder = new Environment.Builder(id) .transactionFactory(txFactory) .dataSource(dataSource); //老规矩，会将dataSource设置进configuration对象 configuration.setEnvironment(environmentBuilder.build()); &#125; &#125; &#125; &#125; //下面看看dataSource的解析方法 private DataSourceFactory dataSourceElement(XNode context) throws Exception &#123; if (context != null) &#123; //dataSource的连接池 String type = context.getStringAttribute("type"); //子节点 name, value属性set进一个properties对象 Properties props = context.getChildrenAsProperties(); //创建dataSourceFactory DataSourceFactory factory = (DataSourceFactory) resolveClass(type).newInstance(); factory.setProperties(props); return factory; &#125; throw new BuilderException("Environment declaration requires a DataSourceFactory."); &#125; &#125; 通过以上对mybatis源码的解读，相信大家对mybatis的配置又有了一个深入的认识。 还有一个问题， 上面我们看到，在配置dataSource的时候使用了 ${driver} 这种表达式， 这种形式是怎么解析的？其实，是通过PropertyParser这个类解析： PropertyParser源码1234567891011121314151617181920212223242526/** * 这个类解析$&#123;&#125;这种形式的表达式 */public class PropertyParser &#123; public static String parse(String string, Properties variables) &#123; VariableTokenHandler handler = new VariableTokenHandler(variables); GenericTokenParser parser = new GenericTokenParser("$&#123;", "&#125;", handler); return parser.parse(string); &#125; private static class VariableTokenHandler implements TokenHandler &#123; private Properties variables; public VariableTokenHandler(Properties variables) &#123; this.variables = variables; &#125; public String handleToken(String content) &#123; if (variables != null &amp;&amp; variables.containsKey(content)) &#123; return variables.getProperty(content); &#125; return "$&#123;" + content + "&#125;"; &#125; &#125;&#125; 好啦，以上就是对于properties 和 environments元素节点的分析，比较重要的都在对于源码的注释中标出。本次文章到此结束，接下来的文章会继续分析其他节点的配置。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列二-配置简介（mybatis源码篇）]]></title>
    <url>%2F%2Fblog%2Fmybatis-2%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 上篇文章《深入浅出Mybatis系列（一）—Mybatis入门》， 写了一个Demo简单体现了一下Mybatis的流程。本次，将简单介绍一下Mybatis的配置文件： 上次例子中，我们以 SqlSessionFactoryBuilder 去创建 SqlSessionFactory, 那么，我们就先从SqlSessionFactoryBuilder入手， 咱们先看看源码是怎么实现的： SqlSessionFactoryBuilder源码1234567891011121314151617181920212223242526272829303132333435363738394041public class SqlSessionFactoryBuilder &#123; //Reader读取mybatis配置文件，传入构造方法 //除了Reader外，其实还有对应的inputStream作为参数的构造方法， //这也体现了mybatis配置的灵活性 public SqlSessionFactory build(Reader reader) &#123; return build(reader, null, null); &#125; public SqlSessionFactory build(Reader reader, String environment) &#123; return build(reader, environment, null); &#125; //mybatis配置文件 + properties, 此时mybatis配置文件中可以不配置properties，也能使用$&#123;&#125;形式 public SqlSessionFactory build(Reader reader, Properties properties) &#123; return build(reader, null, properties); &#125; //通过XMLConfigBuilder解析mybatis配置，然后创建SqlSessionFactory对象 public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123; try &#123; XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties); //下面看看这个方法的源码 return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException("Error building SqlSession.", e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; reader.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125; public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config); &#125;&#125; 通过源码，我们可以看到SqlSessionFactoryBuilder 通过XMLConfigBuilder 去解析我们传入的mybatis的配置文件， 下面就接着看看 XMLConfigBuilder 部分源码： XMLConfigBuilder源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * mybatis 配置文件解析 */public class XMLConfigBuilder extends BaseBuilder &#123; public XMLConfigBuilder(InputStream inputStream, String environment, Properties props) &#123; this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props); &#125; private XMLConfigBuilder(XPathParser parser, String environment, Properties props) &#123; super(new Configuration()); ErrorContext.instance().resource("SQL Mapper Configuration"); this.configuration.setVariables(props); this.parsed = false; this.environment = environment; this.parser = parser; &#125; //外部调用此方法对mybatis配置文件进行解析 public Configuration parse() &#123; if (parsed) &#123; throw new BuilderException("Each XMLConfigBuilder can only be used once."); &#125; parsed = true; //从根节点configuration parseConfiguration(parser.evalNode("/configuration")); return configuration; &#125; //此方法就是解析configuration节点下的子节点 //由此也可看出，我们在configuration下面能配置的节点为以下10个节点 private void parseConfiguration(XNode root) &#123; try &#123; propertiesElement(root.evalNode("properties")); //issue #117 read properties first typeAliasesElement(root.evalNode("typeAliases")); pluginElement(root.evalNode("plugins")); objectFactoryElement(root.evalNode("objectFactory")); objectWrapperFactoryElement(root.evalNode("objectWrapperFactory")); settingsElement(root.evalNode("settings")); environmentsElement(root.evalNode("environments")); // read it after objectFactory and objectWrapperFactory issue #631 databaseIdProviderElement(root.evalNode("databaseIdProvider")); typeHandlerElement(root.evalNode("typeHandlers")); mapperElement(root.evalNode("mappers")); &#125; catch (Exception e) &#123; throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e); &#125; &#125;&#125; 通过以上源码，我们就能看出，在mybatis的配置文件中： configuration节点为根节点。 在configuration节点之下，我们可以配置10个子节点， 分别为：properties、typeAliases、plugins、objectFactory、objectWrapperFactory、settings、environments、databaseIdProvider、typeHandlers、mappers。 本篇文章就先只介绍这些内容，接下来的文章将依次分析解析这个10个节点中比较重要的几个节点的源码，看看在解析这些节点的时候，到底做了些什么。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Mybatis系列一-Mybatis入门]]></title>
    <url>%2F%2Fblog%2Fmybatis-1%2F</url>
    <content type="text"><![CDATA[注：本文转载自南轲梦 最近两年 springmvc + mybatis 的在这种搭配还是蛮火的，楼主我呢，也从来没真正去接触过mybatis, 趁近日得闲， 就去学习一下mybatis吧。 本次拟根据自己的学习进度，做一次关于mybatis 的一系列教程， 记录自己的学习历程， 同时也给还没接触过mybatis的朋友探一次道。本系列教程拟 由浅（使用）入深（分析mybatis源码实现），故可能需要好长几天才能更新完。好啦，下面就开始本次的mybatis 学习之旅啦， 本次为第一篇教程， 就先简单地写个demo, 一起来认识一下mybatis吧。 为了方便，我使用了maven，至于maven怎么使用，我就不做介绍了。没用过maven的，也不影响阅读。 Mybatis环境搭建新建web项目， 添加依赖包：mybatis包、数据库驱动包(我使用的是mysql)、日志包(我使用的是log4j)， 由于我的是maven项目， 那么添加依赖包就简单了，直接在pom.xml添加依赖即可。 pom.xml 12345678910111213141516171819202122232425262728293031&lt;dependencies&gt; &lt;!-- 添加junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 添加log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置mybatis在classpath建立一个用于配置log4j的配置文件log4j.properties, 再建立一个用于配置Mybatis的配置文件configuration.xml（文件可随便命名）。log4j的配置，我就不多说，这儿主要说一下configuration.xml: configuration.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 指定properties配置文件， 我这里面配置的是数据库相关 --&gt; &lt;properties resource="dbConfig.properties"&gt;&lt;/properties&gt; &lt;!-- 指定Mybatis使用log4j --&gt; &lt;settings&gt; &lt;setting name="logImpl" value="LOG4J"/&gt; &lt;/settings&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 如果上面没有指定数据库配置的properties文件，那么此处可以这样直接配置 &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test1"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; --&gt; &lt;!-- 上面指定了数据库配置文件， 配置文件里面也是对应的这四个属性 --&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射文件，mybatis精髓， 后面才会细讲 --&gt; &lt;mappers&gt; &lt;mapper resource="com/dy/dao/userDao-mapping.xml"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 开始写Demo首先，在mysql数据库test1建立一张表user。 先编写一个实体类User: User类用于与User表相对应。 User12345678910public class User &#123; private int id; private String name; private String password; private int age; private int deleteFlag; //setter和getter方法省略...&#125; 再编写一个UserDao 接口： UserDao12345public interface UserDao &#123; public void insert(User user); public User findUserById (int userId); public List&lt;User&gt; findAllUsers();&#125; 再编写一个userDao-mapping.xml （可随便命名）: userDao-mapping.xml123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN" "http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.dy.dao.UserDao"&gt; &lt;select id="findUserById" resultType="com.dy.entity.User" &gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; userDao-mapping.xml相当于是UserDao的实现， 同时也将User实体类与数据表User成功关联起来。 测试代码DemoUserDaoTest12345678910111213141516171819202122public class UserDaoTest &#123; @Test public void findUserById() &#123; SqlSession sqlSession = getSessionFactory().openSession(); UserDao userMapper = sqlSession.getMapper(UserDao.class); User user = userMapper.findUserById(2); Assert.assertNotNull("没找到数据", user); &#125; //Mybatis 通过SqlSessionFactory获取SqlSession, 然后才能通过SqlSession与数据库进行交互 private static SqlSessionFactory getSessionFactory() &#123; SqlSessionFactory sessionFactory = null; String resource = "configuration.xml"; try &#123; sessionFactory = new SqlSessionFactoryBuilder().build(Resources .getResourceAsReader(resource)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return sessionFactory; &#125; &#125; 好啦，这样一个简单的mybatis 的demo就能成功运行啦。通过这个demo, 应该你就也能初步看出mybatis的运行机制，如果不清楚，也没关系。从下一篇文章开始，才开始正式讲解mybatis。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo一站式部署个人博客]]></title>
    <url>%2F%2Fblog%2Fhexo-blog%2F</url>
    <content type="text"><![CDATA[写在前面本文档是Github + Hexo 的搭建个人博客教程，其中Hexo基于Hexo v3.8.0版本，themes主题基于为NexT v7.0.0版本。 搭建博客前置条件可参考 如何搭建个人独立博客？ 注： 点开侧栏浏览目录可快速定位内容 安装主题在 Hexo 项目源码目录下，有两个重要的配置文件，其名称均为 _config.yml 。 其中，一份位于站点根目录下，主要包含 Hexo本身的配置；另一份位于主题目录下，主要用于主题相关的配置。为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。 下载NexT主题12cd hexogit clone https://github.com/theme-next/hexo-theme-next themes/next 启用NexT主题修改站点配置文件，查找关键词theme，并修改为主题名字next：1234# Extensions #(注意冒号间的空格)## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 主题设置设置Scheme在Hexo主题中，有四种不同的模式！进入主题配置文件，搜索关键词找到scheme属性，选择自己喜欢的模式：12345678# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes# scheme: Muse # 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白scheme: Mist # Muse 的紧凑版本，整洁有序的单栏外观# scheme: Pisces # 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白# scheme: Gemini # 类似 Pisces 设置语言编辑站点配置文件，搜索关键词language，并设置成你所需要的语言：1language: zh-CN 设置菜单进入主题配置文件，找到menu字段，菜单内容的设置格式是：item name: link || menu photo，其中item name 是一个名称，link时具体菜单分类，菜单的||后面是菜单的图标,具体菜单图标可参考Font Awesome网站。12345678# 菜单示例配置menu: home: / || home reading: /reading/ || book archives: /archives/ || archive categories: /categories/ || th #tags: /tags/ || tags about: /about/ || user 头像设置在主题配置文件，搜索字段avatar，值设置成头像的链接地址。1234567# 将头像放置主题目录下的 source/uploads/ （新建uploads目录若不存在） 配置为：avatar: /uploads/avatar.png# 放置在 source/images/ 目录下, 配置为：avatar: /images/avatar.png# 完整的互联网 URIavatar: url: http://example.com/avatar.png 设置侧边栏在主题配置文件，搜索sidebar关键词，设置为hide模式，如下图所示：12345sidebar: #display: post // 默认显示方式 #display: always // 一直显示 display: hide // 初始隐藏 #display: remove // 移除侧边栏 各位可根据个人喜好进行设置。 设置站点描述在站点配置文件中，搜索关键词Site，如下：123456# Sitetitle: Chloneda #你的站点标题subtitle: Less is moredescription: Less is more #你的站点描述keywords: chlonedaauthor: chloneda #站点作者 进阶设定添加标签页面hexo根目录下，执行以下命令，新建标签页面。1hexo new page tags 修改站点目录source/tags的 index.md 文件：123456---title: 添加标签页面测试tags: Test #添加标签categories: Test #添加分类comments: false--- 修改主题配置文件，搜索关键词menu，取消 #tags: /tags/ || tags注释，内容如下:12345678# 菜单示例配置menu: home: / || home reading: /reading/ || book archives: /archives/ || archive categories: /categories/ || th tags: /tags/ || tags about: /about/ || user 注：添加其他页面也类似。 首页显示预览首页显示文章列表，列表里的每一篇文章只显示预览，不显示全文。 进入主题配置文件，搜索关键词auto_excerpt，把enable对应的false改为true。12345# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 友情链接打开主题配置文件,搜索关键字 Blog rolls,添加自己需要的链接：123links: #连接 baidu: https://www.baidu.com/ google: https://www.google.com/ 本地搜索在Hexo的根目录下执行以下命令。1$ npm install hexo-generator-searchdb --save 打开主题配置文件,搜索关键字local_search,将enable的值设置为 true：1234# Local search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search: enable: true 打开站点配置文件，搜索关键词search，修改为如下内容：123456# 本地搜索search: path: search.xml field: post format: html limit: 10000 添加RSS在Hexo根目录执行安装指令，安装 hexo-generator-feed 插件：1npm install hexo-generator-feed --save 打开站点配置文件，追加feed信息:1234567# 设置RSSfeed: type: rss2 path: rss2.html limit: 5 hub: content: 'true' 打开主题配置文件，找到rss，设置为:1rss: /atom.xml 添加社交链接在主题配置文件中，找到social属性，添加社交链接，步骤如下：12345social: E-Mail: mailto:yourname@gmail.com || envelope Google: https://plus.google.com/yourname || google Twitter: https://twitter.com/yourname || twitter Facebook: https://www.facebook.com/yourname || facebook 格式为： 社交平台名称：链接 设置代码高亮首先需要改动的地方有： 站点配置文件_config.yml。 主题配置文件_config.yml。 在站点配置文件中，搜索highlight关键词:12345highlight: enable: true line_number: true auto_detect: true tab_replace: 文字自动检测默认不启动，改成true使其起作用。 再到主题配置文件，搜索highlight_theme关键词，修改代码主题样式：1234# Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night 添加复制按钮在主题配置文件中，搜索关键词codeblock，将copy_button的enable值修改为true。1234567codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1 border_radius: # Add copy button on codeblock copy_button: enable: true 添加阅读次数统计主题配置文件中，搜索关键词busuanzi_count，设置文章阅读次数统计及网站访客量:12345678910# Show Views/Visitors of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzibusuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye 添加 README.md每个项目README.md文件可以简单说明这个项目的用途。在Hexo目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件，将 skip_render 参数的值设置为：1skip_render: README.md 再次使用hexo d命令部署博客的时候就不会在渲染 README.md 这个文件。 自定义网站头像自定义头像可以使用 比特虫 网站制作！ 在主题配置文件中，按以下修改：1234567favicon: small: /images/favicon-16x16-next.png #你的头像名称 medium: /images/favicon-32x32-next.png #你的头像名称 apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 添加自定义页面[友链]设置菜单项的显示中文文本打开themes/next/languages/zh-CN.yml文件,搜索 menu 关键字，修改对应中文或者新增。123456789101112menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 # schedule: 日程表 # sitemap: 站点地图 # commonweal: 公益404 # 新增menu links: 友链 # 新增该选项表示新增“友链”菜单 在主题配置文件，搜索menu，新增links: /links/ || link：123456789# 菜单示例配置menu: home: / || home reading: /reading/ || book archives: /archives/ || archive categories: /categories/ || th #tags: /tags/ || tags about: /about/ || user links: /links/ || link hexo根目录下，执行以下命令，新建友链页面。1hexo new page links 修改站点目录下source/links的 index.md 文件：123456---title: 友链tags: linkscategories: linkscomments: false--- 注：其它自定义菜单也是类似步骤 添加打赏功能如今已进入知识付费时代，打赏是读者对笔者创造的最大支持，更是对劳动者的尊重。打赏功能具体步骤为：获取二维码 微信二维码的获取（可百度）。 获取支付宝收款二维码（可百度）。 添加二维码图片资源得到二维码图片资源后，读者们可将二维码图片放到NexT根目录/source/images/文件夹下。 开启打赏功能打开主题配置文件，搜索reward关键词，添加打赏的配置信息。12345678# Reward# If true, reward would be displayed in every article by default.# And you can show or hide one article specially through add page variable `reward: true/false`.reward: enable: true //默认是false，改为true comment: 您的支持是对我最大的鼓励 wechatpay: /images/wechatpay.jpg #图片链接或图片相对路径 alipay: /images/alipay.jpg #图片链接或图片相对路径 开启版权声明打开主题配置文件,搜索关键字 creative_commons , post 改为 true：1234creative_commons: license: by-nc-sa sidebar: false post: true 优化及设置优化urlseo搜索引擎优化认为，网站的最佳结构是三层，但是默认hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，url不利于搜索引擎搜索。 因此，我们可以将url直接改成sitename/blog/title的形式，同时title最好是用英文，在站点配置文件搜索permalink关键词，并修改如下。1234url: https://chloneda.github.io/root: /permalink: /blog/:title.htmlpermalink_defaults: Hexo博客备份利用github分支功能进行博客备份，思路说明: master分支：存放博客的静态网页(默认分支)。 hexoCode分支：存放Hexo生成的静态网站原始文件。 master分支部署进入站点配置文件编辑，搜索deploy关键词：1234deploy: type: git repo: https://github.com/你的github用户名/你的github用户名.github.io.git branch: master 修改更新博客内容并保存。 执行hexo clean清除本地旧代码。 执行hexo g -d生成静态网站并部署到GitHub上。 hexoCode分支配置 创建hexoCode，该分支为博客源码分支。 使用git clone -b hexoCode 你的github仓库路径， 拷贝源码仓库。 修改hexo主配置_config.xml的deploy部分配置，设置静态页面的发布分支为master。 添加.gitignore文件，将静态网页的目录及其他无需提交的源文件及目录排除掉。 博客源码更新在本地对博客进行修改后，提交hexo源代码：1234git checkout hexoCodegit add .git commit -m 'Code update'git push origin hexoCode 发布hexo静态文件hexo根目录依次执行以下命令：123hexo cleanhexo generate 或者 hexo ghexo deploy 或者 hexo d 本地资料丢失或其他主机搭建博客步骤： 拷贝hexoCode分支源码到本地：git clone -b hexoCode github项目地址.git。 安装hexo及各类插件。 本地安装调试。 Hexo部署脚本Hexo修改后利用deploy.sh脚本一键部署，提高部署效率。123456789101112131415161718192021#!/bin/bashDIR=`dirname $0`# Generate bloghexo cleanhexo generatesleep 5# Deployhexo deploysleep 5# Push hexo codegit add .current_date=`date "+%Y-%m-%d %H:%M:%S"`git commit -m "Blog updated: $current_date"sleep 2git push origin hexoCodeecho "=====&gt;Finish!&lt;=====" 把该脚本存放至 hexo根目录中，并附加脚本执行权限:1chmod 775 deploy.sh 在hexo目录根执行脚本:1./deploy.sh 可一键部署博客及备份博客源码至github的分支hexoCode上。 提升你的博客更多提升NexT主题的方法请参考以下网页。 Hexo高阶教程：打造定制化博客 让你的hexo博客在搜索引擎中排第一 结束小语本文采用Github + Hexo搭建的个人博客，在搭建过程优化总结，及时记录，希望对各位有所帮助！本文如有错误，欢迎在 Github 的issue中提出，非常感谢！！！ 更多详情请参考： Hexo官网 NexT主题 Hexo插件 Markdown]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Chloneda]]></title>
    <url>%2F%2Fblog%2Fhello-chloneda%2F</url>
    <content type="text"><![CDATA[Welcome to chloneda‘s blog!This is my very first post.You can check the Hexo official website and the Markdown website for related commands and syntax. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartOther reference website NexT 比特虫 Font Awesome Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
</search>
