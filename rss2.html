<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Chloneda</title>
    <link>https://chloneda.github.io/</link>
    <atom:link href="/rss2.html" rel="self" type="application/rss+xml"/>
    
    <description>Less is more</description>
    <pubDate>Sun, 30 Jun 2019 11:23:47 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Docker容器Centos不能使用systemctl命令问题</title>
      <link>https://chloneda.github.io//blog/bug-dock-os/</link>
      <guid>https://chloneda.github.io//blog/bug-dock-os/</guid>
      <pubDate>Sun, 30 Jun 2019 03:34:06 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：本文出自博主：&lt;a href=&quot;https://chloneda.github.io/&quot;&gt;chloneda&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近使用Docker搭建Centos容器时遇到这样的问题：Centos系统的不能使用systemctl命令
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>注</strong>：本文出自博主：<a href="https://chloneda.github.io/">chloneda</a></p><p>最近使用Docker搭建Centos容器时遇到这样的问题：Centos系统的不能使用systemctl命令!</p><p><strong>具体场景</strong><br>使用 systemctl 或 service 命令重启服务时。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">systemctl</span> <span class="selector-tag">restart</span> <span class="selector-tag">snmpd</span><span class="selector-class">.service</span></span><br></pre></td></tr></table></figure></p><p>会报无权限的错误：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed <span class="keyword">to</span> <span class="builtin-name">get</span> D-Bus connection: Operation <span class="keyword">not</span> permitted；</span><br></pre></td></tr></table></figure></p><p>这是docker中centos7的bug，官网上也提到了这个问题，并给出了 <a href="https://github.com/docker-library/docs/tree/master/centos#dockerfile-for-systemd-base-image" target="_blank" rel="noopener">解决办法</a>，但有点复杂。我们可以通过以下方法解决！</p><p><strong>首先</strong>，使用docker构建centos容器加上 <strong>privileged</strong> 参数，即在docker run命令是要加上 –privileged=true，该参数在docker容器运行时，让系统拥有真正的root权限。</p><p><strong>其次</strong>，在启动容器时，在docker run 命令最后，加上/usr/sbin/init，最终命令为：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -v /tmp/:/tmp --privileged --cap-<span class="builtin-name">add</span> SYS_ADMIN -e <span class="attribute">container</span>=docker -it <span class="attribute">--name</span>=centos -d <span class="attribute">--restart</span>=always centos /usr/sbin/init</span><br></pre></td></tr></table></figure></p><p>参数说明：</p><ul><li>-v /tmp/:/tmp：挂载宿主机的一个目录，冒号”:”前面的目录是宿主机目录，后面的目录是容器内目录。</li><li><p>–privileged： 指定容器是否是特权容器。</p></li><li><p>–cap-add SYS_ADMIN： 添加系统的权限，不然系统很多功能都用不了的。</p></li><li><p>-e container=docker：设置容器的类型。</p></li><li><p>-it： 启动互动模式。</p></li><li><p>/usr/sbin/init：初始容器里的CENTOS，用于启动dbus-daemon。</p></li></ul><p><strong>最后</strong>，如果想查看Docker更多内容，请查看<a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker</a>官网文档。</p>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>那些优秀的软件工具！</title>
      <link>https://chloneda.github.io//blog/tools/</link>
      <guid>https://chloneda.github.io//blog/tools/</guid>
      <pubDate>Thu, 27 Jun 2019 16:59:36 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：本文出自博主：&lt;a href=&quot;https://chloneda.github.io/&quot;&gt;chloneda&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本博客用于收录那些优秀的软件工具，并且长期更新！&lt;/p&gt;
&lt;h1 id=&quot;Windows&quot;&gt;&lt;a href
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>注</strong>：本文出自博主：<a href="https://chloneda.github.io/">chloneda</a></p><p>本博客用于收录那些优秀的软件工具，并且长期更新！</p><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="everything"><a href="#everything" class="headerlink" title="everything"></a>everything</h2><p><a href="https://everything.en.softonic.com/" target="_blank" rel="noopener">everything</a>：是速度最快的文件名搜索软件。其速度之快令人震惊，百G硬盘几十万个文件，可以在几秒钟之内完成索引；文件名搜索瞬间呈现结果。它小巧免费，支持中文，支持正则表达式，可以通过HTTP或FTP分享搜索结果。如果不满意Windows自带的搜索工具，那就用它吧！</p><h1 id="MacOs"><a href="#MacOs" class="headerlink" title="MacOs"></a>MacOs</h1><h2 id="eZip"><a href="#eZip" class="headerlink" title="eZip"></a>eZip</h2><p><a href="https://ezip.awehunt.com/" target="_blank" rel="noopener">eZip</a>：是一款 Mac 上完全免费的压缩与解压缩工具软件，主要是提供了文件预览以及加密压缩和解压缩功能，功能足够实用，基本可以替代市面上大部分的 macOS 商业收费压缩工具，个人认为值得力荐。</p><h2 id="OmniGraffle"><a href="#OmniGraffle" class="headerlink" title="OmniGraffle"></a>OmniGraffle</h2><p><a href="https://www.omnigroup.com/omnigraffle" target="_blank" rel="noopener">OmniGraffle</a>：Windows下使用Visio画框图、流程图非常方便，切换到MAC后，我们可以使用OmniGraffle。</p><h2 id="CheatSheet"><a href="#CheatSheet" class="headerlink" title="CheatSheet"></a>CheatSheet</h2><p>[CheatSheet]（<a href="https://cheatsheet-mac.en.softonic.com/mac）：Mac上的快捷键神器" target="_blank" rel="noopener">https://cheatsheet-mac.en.softonic.com/mac）：Mac上的快捷键神器</a></p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Remmina"><a href="#Remmina" class="headerlink" title="Remmina"></a>Remmina</h2><p><a href="https://remmina.org/" target="_blank" rel="noopener">Remmina</a>:是一款在 Linux 和其他类 Unix 系统下的自由开源、功能丰富、强大的远程桌面客户端，它用 GTK+ 3 编写而成。它适用于那些需要远程访问及使用许多计算机的系统管理员和在外出行人员。</p>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>git同步代码至github和gitee(码云)</title>
      <link>https://chloneda.github.io//blog/git-to-github-gitee/</link>
      <guid>https://chloneda.github.io//blog/git-to-github-gitee/</guid>
      <pubDate>Thu, 20 Jun 2019 13:31:06 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：本文出自博主：&lt;a href=&quot;https://chloneda.github.io/&quot;&gt;chloneda&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们有时候开发代码需要把代码同步到多个远程库中，如何操作才能做到呢？&lt;/p&gt;
&lt;p&gt;我们知道，git是分布
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>注</strong>：本文出自博主：<a href="https://chloneda.github.io/">chloneda</a></p><p>我们有时候开发代码需要把代码同步到多个远程库中，如何操作才能做到呢？</p><p>我们知道，git是分布式版本控制系统，同步到多个远程库时，需要用不同的名称来标识不同的远程库，而git给远程库起的默认名称是origin。所以我们需要修改、配置名称，以关联不同远程库。有两种方式！</p><p>为了方便举例，我以GitHub和Gitee(码云)作为示例！</p><h1 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h1><h2 id="命令方式同步"><a href="#命令方式同步" class="headerlink" title="命令方式同步"></a>命令方式同步</h2><p>先删除已关联的名为origin的远程库：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git remote rm origin</span></span><br></pre></td></tr></table></figure></p><p>然后，再关联GitHub的远程库：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> github git@github.com:chloneda/demo.git</span></span><br></pre></td></tr></table></figure></p><p>接着，再关联码云的远程库：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> gitee git@gitee.com:chloneda/demo.git</span></span><br></pre></td></tr></table></figure></p><h2 id="配置方式同步"><a href="#配置方式同步" class="headerlink" title="配置方式同步"></a>配置方式同步</h2><p>修改.git文件夹内的config文件：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">repositoryformatversion = <span class="number">0</span></span><br><span class="line">filemode = <span class="keyword">true</span></span><br><span class="line">bare = <span class="keyword">false</span></span><br><span class="line">logallrefupdates = <span class="keyword">true</span></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">url = git<span class="variable">@github</span>.<span class="symbol">com:</span>chloneda/demo.git</span><br><span class="line">fetch = +refs/heads/*<span class="symbol">:refs/remotes/github/*</span></span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">remote = origin</span><br><span class="line">merge = refs/heads/master</span><br></pre></td></tr></table></figure></p><p>将上述文件内容[remote “origin”]内容复制，修改origin名称，内容如下：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">repositoryformatversion = <span class="number">0</span></span><br><span class="line">filemode = <span class="keyword">true</span></span><br><span class="line">bare = <span class="keyword">false</span></span><br><span class="line">logallrefupdates = <span class="keyword">true</span></span><br><span class="line">[remote <span class="string">"github"</span>]</span><br><span class="line">url = git<span class="variable">@github</span>.<span class="symbol">com:</span>chloneda/demo.git</span><br><span class="line">fetch = +refs/heads/*<span class="symbol">:refs/remotes/github/*</span></span><br><span class="line">[remote <span class="string">"gitee"</span>]</span><br><span class="line">url = git<span class="variable">@gitee</span>.<span class="symbol">com:</span>chloneda/demo.git</span><br><span class="line">fetch = +refs/heads/*<span class="symbol">:refs/remotes/gitee/*</span></span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">remote = origin</span><br><span class="line">merge = refs/heads/master</span><br></pre></td></tr></table></figure></p><h1 id="查看远程库"><a href="#查看远程库" class="headerlink" title="查看远程库"></a>查看远程库</h1><p>通过以上两种方式的任一种方式配置完成后，我们用git remote -v查看远程库信息：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gitee   git@gitee<span class="selector-class">.com</span>:chloneda/demo<span class="selector-class">.git</span> (fetch)</span><br><span class="line">gitee   git@gitee<span class="selector-class">.com</span>:chloneda/demo<span class="selector-class">.git</span> (push)</span><br><span class="line">github  git@github<span class="selector-class">.com</span>:chloneda/demo<span class="selector-class">.git</span> (fetch)</span><br><span class="line">github  git@github<span class="selector-class">.com</span>:chloneda/demo<span class="selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure></p><p>可以看到两个远程库，说明配置生效了。</p><h1 id="上传代码"><a href="#上传代码" class="headerlink" title="上传代码"></a>上传代码</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> .</span></span><br><span class="line">git commit -m <span class="string">"update"</span></span><br></pre></td></tr></table></figure><h1 id="提交到github"><a href="#提交到github" class="headerlink" title="提交到github"></a>提交到github</h1><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">push </span>github master</span><br></pre></td></tr></table></figure><h1 id="提交到码云"><a href="#提交到码云" class="headerlink" title="提交到码云"></a>提交到码云</h1><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">push </span>gitee master</span><br></pre></td></tr></table></figure><h1 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h1><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 从github拉取更新</span></span><br><span class="line">git pull github</span><br><span class="line"></span><br><span class="line"><span class="meta"># 从gitee拉取更新</span></span><br><span class="line">git pull gitee</span><br></pre></td></tr></table></figure><h1 id="踩到的坑"><a href="#踩到的坑" class="headerlink" title="踩到的坑"></a>踩到的坑</h1><p>上述过程中，更新或提交代码时可能会遇到<strong>fatal:refusing to merge unrelated histories</strong> (拒绝合并无关的历史) 错误，解决办法：</p><p>首先将远程仓库和本地仓库关联起来。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="keyword">set</span>-upstream-<span class="keyword">to</span>=origin/remote_branch  your_branch</span><br></pre></td></tr></table></figure><p>其中，origin/remote_branch是你本地分支对应的远程分支，your_branch是你当前的本地分支。</p><p>然后使用git pull整合远程仓库和本地仓库。<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment">--allow-unrelated-histories    (忽略版本不同造成的影响)</span></span><br></pre></td></tr></table></figure></p><p>重新更新、提交即可。</p><p>注： 如遇到 <strong>Git没有共同祖先的两个分支合并</strong> 的情形请自行查询！</p><hr>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>聊聊SNMP协议</title>
      <link>https://chloneda.github.io//blog/snmp-protocol/</link>
      <guid>https://chloneda.github.io//blog/snmp-protocol/</guid>
      <pubDate>Fri, 14 Jun 2019 15:32:09 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：本文出自博主：&lt;a href=&quot;https://chloneda.github.io/&quot;&gt;chloneda&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;SNMP概述&quot;&gt;&lt;a href=&quot;#SNMP概述&quot; class=&quot;headerlink&quot; tit
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>注</strong>：本文出自博主：<a href="https://chloneda.github.io/">chloneda</a></p><h1 id="SNMP概述"><a href="#SNMP概述" class="headerlink" title="SNMP概述"></a>SNMP概述</h1><p>SNMP(Simple Network Management Protocol):简单网络管理协议,是基于TCP/IP五层协议中的应用层协议。由于其简单可靠，提供了一种监控和管理网络设备的系统方法，因此受到了众多厂商的欢迎，成为了目前最为广泛的网管协议。</p><p>SNMP的基本思想：为不同种类、厂家、型号的设备，定义一个统一的接口和协议，使得管理员可以是使用统一的外观面对这些需要管理的网络设备。通过网络，管理员可以管理位于不同物理空间的设备，从而大大提高网络管理的效率，简化网络管理员的工作。</p><h1 id="Snmp版本"><a href="#Snmp版本" class="headerlink" title="Snmp版本"></a>Snmp版本</h1><p>SNMP目前共有v1，v2，v3这三个版本，三个版本的联系与区别。</p><ul><li>SNMP v1：是SNMP协议的最初版本，存在较多安全缺陷，现在这个版本是使用的比较少了。 </li><li>SNMP v2：也采用团体名认证,在兼容SNMPv1的同时又扩充了SNMPv1的功能，具体是扩展了数据类型、支持分布式网络管理、可以实现大量数据的传输，提高了效率和性能、丰富了故障处理能力及增加了集合处理功能。</li><li>SNMP v3：是最新版本的SNMP。它相对于V2版本，在安全性上得到了重要提升，增加了对认证和密文传输的支持。</li></ul><h1 id="SNMP核心概念"><a href="#SNMP核心概念" class="headerlink" title="SNMP核心概念"></a>SNMP核心概念</h1><h2 id="SNMP管理架构"><a href="#SNMP管理架构" class="headerlink" title="SNMP管理架构"></a>SNMP管理架构</h2><p>SNMP管理架构应包含四个部分进行网络管理：<strong>SNMP管理站</strong>、<strong>SNMP代理</strong>、<strong>MIB(管理信息库)</strong>和<strong>SNMP管理协议</strong>。</p><p><strong>SNMP管理站</strong>（management station）：通常被称作为网络管理工作站（NMS），负责收集维护各个SNMP元素的信息，通过UDP协议向SNMP代理发送各种命令，当SNMP代理收到命令后，对收集的信息进行处理，并返回SNMP管理站需要的参数。而此时被管理对象中一定要有代理进程，这样才能响应管理站发来的请求。</p><p><strong>SNMP代理</strong>(Agent)：运行在各个被管理的网络节点之上，负责统计该节点的各项信息，并且负责与SNMP管理站交互，接收并执行管理站的命令，上传各种本地的网络信息。</p><p><img src="/uploads/snmp_Structure.png" alt="snmp_structure"></p><p><strong>注</strong>：协议栈中带有阴影的部分是原主机或路由器所具有的，而没有阴影的部分是为实现网络管理而增加的。<br>　　<br><strong>MIB(管理信息库)</strong>：是对象的集合，它代表网络中可以管理的资源和设备。每个对象基本上是一个数据变量，它代表被管理的对象的一方面的信息。</p><p><strong>SNMP管理协议</strong>：用于管理站与SNMP代理之间的通信规则，其SNMP报文格式请查看底下章节。</p><p>管理站和代理之间利用 SNMP 报文进行通信，而 SNMP 报文又使用 UDP协议来传送，由于采用UDP协议，不需要在代理和管理站之间保持连接。　</p><h2 id="SNMP报文格式"><a href="#SNMP报文格式" class="headerlink" title="SNMP报文格式"></a>SNMP报文格式</h2><p>管理站（NMS）和代理（Agent）之间交换的管理信息构成了SNMP报文，报文的基本格式如下图：</p><p><img src="/uploads/snmp_MessageFormat.png" alt="snmp_MessageFormat.png"></p><p><strong>下面将对该SNMP报文格式逐个进行说明！</strong></p><p>SNMP消息报文包含两个部分：SNMP报头和PDU(协议数据单元)。</p><p><strong>SNMP报头</strong></p><ul><li>版本：版本号字段，规则为版本号减 1，如SNMP V1则应写入 0。如果SNMP代理使用不相同的协议，会直接抛弃与自己协议版本不同的数据报。</li><li>共同体(community)：即团体名，作为管理进程和代理进程之间的明文口令，相当于密码，默认为public，该字段可读可写，用来限制NMS对Agent的访问。如果团体名没有得到NMS/Agent的认可，该报文将被丢弃。</li><li>PDU 类型：填入 0～4 中的一个数字，其对应关系如图。</li></ul><p><img src="/uploads/snmp_PDUType.png" alt="snmp_PDUType.png"></p><p>PDU类型请参考<strong>PDU(协议数据单元)</strong>章节！</p><p><strong>Get/Set 首部</strong></p><ul><li>请求标识符(request ID)，这是由管理进程设置的一个整数值。代理进程在发送 get-response 报文时也要返回此请求标识符。管理进程可同时向许多代理发出 get 报文，这些报文都使用 UDP 传送，先发送的有可能后到达。设置了请求标识符可使管理进程能够识别返回的响应报文对于哪一个请求。</li><li>差错状态（error status）：由代理进程回答时填入 0～5 中的一个数字，见表 3 的描述。</li></ul><p><img src="/uploads/snmp_ErrorStatus.png" alt="snmp_ErrorStatus.png"></p><ul><li>差错索引(error index)：当出现 noSuchName、badValue 或 readOnly 的差错时，由代理进程在回答时设置的一个整数，它指明有差错的变量在变量列表中的偏移。</li></ul><p><strong>Trap 首部</strong></p><ul><li>企业（enterprise）：填入 trap 报文的网络设备的对象标识符。此对象标识符肯定是在图 3 的对象命名树上的 enterprise 结点{1.3.6.1.4.1}下面的一棵子树上。</li><li>Trap 类型：此字段正式的名称是 generic-trap，共分为表 4 中的 7 种。</li></ul><p><img src="/uploads/snmp_TrapType.png" alt="snmp_TrapType.png"> </p><p>当使用上述类型 2、3、5 时，在报文后面变量部分的第一个变量应标识响应的接口。</p><ul><li>特定代码(specific-code)：指明代理自定义的时间（若 trap 类型为 6），否则为 0。</li><li>时间戳(timestamp)：指明自代理进程初始化到 trap 报告的事件发生所经历的时间，单位为 10ms。例如时间戳为 1908 表明在代理初始化后 1908ms 发生了该时间。</li><li>变量绑定(variable-bindings)：指明一个或多个变量的名和对应的值。在 get 或 get-next 报文中，变量的值应忽略。</li></ul><h2 id="PDU-协议数据单元"><a href="#PDU-协议数据单元" class="headerlink" title="PDU(协议数据单元)"></a>PDU(协议数据单元)</h2><p>SNMP v1 版本规定了 5 种核心 PDU(协议数据单元)，用来在管理进程和代理之间信息的交换。</p><ul><li>get-request 操作：从代理进程处提取一个OID值。</li><li>get-next-request 操作：从代理进程(MIB中)处提取紧跟当前参数值的下一个OID值，常被用于检索表数据，也被用于不能指定名称的变量,可以浏览MIB树。</li><li>set-request 操作：设置代理进程的一个或多个参数值。</li><li>get-response 操作：返回的一个或多个参数值。这个操作是由代理进程发出的，它是前面三种操作的响应操作。</li><li>trap 操作：代理进程主动发出的报文，通知管理进程有某些事情发生。</li></ul><p>前面的 3 种操作是由管理进程向代理进程发出的，后面的 2 个操作是代理进程发给管理进程的，其中代理进程端是用 161 端口接收 get 或 set 报文，而在管理进程端是用 162 端口来接收 trap 报文。</p><p><img src="/uploads/snmp_fivePDU.png" alt="snmp_fivePDU.png"> </p><p>另外，在SNMP v2版本又增加了 3 种PDU(协议数据单元)，它们分别是：</p><ul><li>inform-request 操作：允许路由器向SNMP管理器发送通知请求。</li><li>getBulk-request 操作：从代理进程处提取多个参数值,该操作会根据最大重试值执行一连串的GetNext操作，减少管理站与代理之间的交互,提高效率。</li><li>report 操作：</li></ul><h3 id="SNMP的操作类型"><a href="#SNMP的操作类型" class="headerlink" title="SNMP的操作类型"></a>SNMP的操作类型</h3><p>其实上述 8 种PDU(协议数据单元)按照功能不同，可以归结为三类操作。</p><ul><li>查询、设置SNMP变量,如get-request、get-next-request、set-request、getBulk-request、inform-request。</li><li>应答请求,如 get-response。</li><li>事件报告，如trap。</li></ul><p>实际上，在SNMP中，SNMP管理站对被管理设备的SNMP变量的操作只能有 <strong>读</strong> 与 <strong>写</strong> 两种基本动作。</p><h2 id="ASN-1-抽象语法标记"><a href="#ASN-1-抽象语法标记" class="headerlink" title="ASN.1(抽象语法标记)"></a>ASN.1(抽象语法标记)</h2><p>ASN.1：高级的数据描述语言。描述数据的类型、结构、组织、及编码方法。包括符号和语法两部分。SNMP使用ASN.1描述PDU和MIB(管理信息库)。</p><p>关于ASN.1详细信息请查看这篇博文：<a href="http://blog.chinaunix.net/uid-23069658-id-3251526.html" target="_blank" rel="noopener">SNMP从入门到开发：进阶篇</a></p><h2 id="BER-基本编码规则"><a href="#BER-基本编码规则" class="headerlink" title="BER(基本编码规则)"></a>BER(基本编码规则)</h2><p><strong>BER(Basic Encoding Rule)</strong>，中文名称：基本编码规则。描述具体的ASN.1对象如何编码为比特流在网络上传输。SNMP使用BER(Basic Encoding Rule)作为编码方案，数据首先先经过BER编码，再经由传输层协议(一边是UDP)发往接收方。接收方在SNMP端口上收到PDU后，经过BER解码后，得到具体的SNMP操作数据。</p><p>BER的数据都由三个域构成:标识域(tag)+长度域(length)+值域(value)。</p><h2 id="SMI-管理信息结构"><a href="#SMI-管理信息结构" class="headerlink" title="SMI(管理信息结构)"></a>SMI(管理信息结构)</h2><p><strong>SMI(Structure of Managerment Intormation)</strong>，中文名称：管理信息结构，是SNMP的描述方法。规定了使用ASN.1子类型、符号。ASN.1功能强大，但SNMP只用到了其中很小一部分，对于这一部分内容的描述，限定了范围，即为SMI。SMI规定了使用到的ASN.1类型、宏、符号等。SMI是ASN.1的一个子集和超集。</p><h2 id="MIB-管理信息库"><a href="#MIB-管理信息库" class="headerlink" title="MIB(管理信息库)"></a>MIB(管理信息库)</h2><p><strong>MIB(Management Information Base)</strong>，中文名称：管理信息库，由网络管理协议访问的管理对象数据库。MIB是对象的集合，它代表网络中可以管理的资源和设备。每个对象基本上是一个数据变量，它代表被管理的对象的一方面的信息。</p><p>管理信息库 MIB 指明了网络元素所维持的变量（即能够被管理进程查询和设置的信息）。MIB 给出了一个网络中所有可能的被管理对象的集合的数据结构。SNMP 的管理信息库采用和域名系统 DNS 相似的树型结构，它的根在最上面，根没有名字。底下的图 画的是管理信息库的一部分，它又称为对象命名（object naming tree）。</p><p>MIB采用分层树形结构，对象命名树的顶级对象有三个，即 ISO、ITU-T 和这两个组织的联合体。在 ISO 的下面有 4 个结点，其中的饿一个（标号 3）是被标识的组织。在其下面有一个美国国防部（Department of Defense）的子树（标号是 6），再下面就是 Internet（标号是 1）。在只讨论 Internet 中的对象时，可只画出 Internet 以下的子树（图中带阴影的虚线方框），并在 Internet 结点旁边标注上{1.3.6.1}即可。</p><p>在 Internet 结点下面的第二个结点是 mgmt（管理），标号是 2。再下面是管理信息库，原先的结点名是 mib。1991 年定义了新的版本 MIB-II，故结点名现改为 mib-2，其标识为{1.3.6.1.2.1}，或{Internet(1) .2.1}。这种标识为对象标识符。</p><p><img src="/uploads/snmp_Mib.png" alt="snmp_Mib.png"></p><p>最初的结点 mib 将其所管理的信息分为 8 个类别，如图，现在的 mib-2 所包含的信息类别已超过 40 个。</p><p><img src="/uploads/snmp_MibInfoType.png" alt="snmp_MibInfoType.png"></p><p>应当指出，MIB 的定义与具体的网络管理协议无关，这对于厂商和用户都有利。厂商可以在产品（如路由器）中包含 SNMP 代理软件，并保证在定义新的 MIB 项目后该软件仍遵守标准。用户可以使用同一网络管理客户软件来管理具有不同版本的 MIB 的多个路由器。当然，一个没有新的 MIB 项目的路由器不能提供这些项目的信息。这里要提一下MIB中的对象{1.3.6.1.4.1}，即enterprises（企业），其所属结点数已超过 3000。例如IBM为{1.3.6.1.4.1.2}，Cisco为{1.3.6.1.4.1.9}，Novell为{1.3.6.1.4.1.23}等。世界上任何一个公司、学校只要用电子邮件发往<a href="mailto:iana-mib@isi.edu" target="_blank" rel="noopener">iana-mib@isi.edu</a>进行申请即可获得一个结点名。这样各厂家就可以定义自己的产品的被管理对象名，使它能用SNMP进行管理。</p><h2 id="ASN-1、BER、SMI、MIB、PDU的关系"><a href="#ASN-1、BER、SMI、MIB、PDU的关系" class="headerlink" title="ASN.1、BER、SMI、MIB、PDU的关系"></a>ASN.1、BER、SMI、MIB、PDU的关系</h2><p>关于ASN.1、BER、SMI、MIB、PDU的关系如下图所示。<br><img src="/uploads/snmp_SMI_MIB.png" alt="snmp_SMI_MIB.png"></p><h2 id="OID-对象标识符"><a href="#OID-对象标识符" class="headerlink" title="OID(对象标识符)"></a>OID(对象标识符)</h2><p><strong>OID(Object Identifier)</strong>，中文名称：对象标识符，被管理设备的每个管理资源和对象都有自己的OID(Object Identifier)，管理对象通过树状结构进行组织，OID由树上的一系列整数组成，整数之间用点( . )分隔开，树的叶子节点才是真正能够被管理的对象。</p><h3 id="常用OID"><a href="#常用OID" class="headerlink" title="常用OID"></a>常用OID</h3><p>这里总结了一些常用的OID，当需要时可以及时查询。<br><a href="http://oid-info.com/cgi-bin/display?tree=1.3.6" target="_blank" rel="noopener">SNMP监控常用OID查询</a><br><a href="https://blog.csdn.net/a9254778/article/details/51200502" target="_blank" rel="noopener">SNMP监控一些常用OID的总结</a><br><a href="http://www.oidview.com/mibs/2021/UCD-SNMP-MIB.html" target="_blank" rel="noopener">下载不同厂商的MIB包</a><br><a href="https://www.alvestrand.no/objectid/1.3.6.1.4.1.html" target="_blank" rel="noopener">查看不同厂商的OID代号</a></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>SNMP支持Window、Linux、MacOS系统的安装，关于SNMP的安装步骤请自行查询。</p><hr>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>深入浅出Mybatis系列六-objectFactory、plugins、mappers简介与配置</title>
      <link>https://chloneda.github.io//blog/mybatis-6/</link>
      <guid>https://chloneda.github.io//blog/mybatis-6/</guid>
      <pubDate>Sun, 19 May 2019 14:53:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;注：本文转载自&lt;a href=&quot;https://www.cnblogs.com/dongying/p/4046488.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;南轲梦&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上篇文章《深入浅出Mybatis系列（五）—Type
        
      
      </description>
      
      <content:encoded><![CDATA[<p>注：本文转载自<a href="https://www.cnblogs.com/dongying/p/4046488.html" target="_blank" rel="noopener">南轲梦</a></p><p>上篇文章《深入浅出Mybatis系列（五）—TypeHandler简介及配置（mybatis源码篇）》简单看了一下TypeHandler， 本次将结束对于mybatis的配置文件的学习， 本次涉及到剩下没提及到的几个节点的配置：objectFactory、databaseIdProvider、plugins、mappers。</p><p>那么，接下来，就简单介绍一下这几个配置的作用吧：</p><p>1、objectFactory是干什么的？ 需要配置吗？</p><p>MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。默认情况下，我们不需要配置，mybatis会调用默认实现的objectFactory。 除非我们要自定义ObjectFactory的实现， 那么我们才需要去手动配置。</p><p>那么怎么自定义实现ObjectFactory？ 怎么配置呢？</p><p>自定义ObjectFactory只需要去继承DefaultObjectFactory（是ObjectFactory接口的实现类），并重写其方法即可。具体的，本处不多说，后面再具体讲解。</p><p>写好了ObjectFactory, 仅需做如下配置：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    <span class="params">...</span><span class="params">...</span></span><br><span class="line">    &lt;objectFactory <span class="keyword">type</span>=<span class="string">"org.mybatis.example.ExampleObjectFactory"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"someProperty"</span> value=<span class="string">"100"</span>/&gt;</span><br><span class="line">    &lt;/objectFactory&gt;</span><br><span class="line">    <span class="params">...</span><span class="params">...</span></span><br><span class="line">  &lt;/configuration</span><br></pre></td></tr></table></figure></p><p>plugin有何作用？ 需要配置吗？</p><p>plugins 是一个可选配置。mybatis中的plugin其实就是个interceptor， 它可以拦截Executor 、ParameterHandler 、ResultSetHandler 、StatementHandler 的部分方法，处理我们自己的逻辑。Executor就是真正执行sql语句的东西， ParameterHandler 是处理我们传入参数的，还记得前面讲TypeHandler的时候提到过，mybatis默认帮我们实现了不少的typeHandler, 当我们不显示配置typeHandler的时候，mybatis会根据参数类型自动选择合适的typeHandler执行，其实就是ParameterHandler 在选择。ResultSetHandler 就是处理返回结果的。</p><p>怎么自定义plugin? 怎么配置？</p><p>要自定义一个plugin, 需要去实现Interceptor接口， 这儿不细说， 后面实战部分会详细讲解。定义好之后，配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"org.mybatis.example.ExamplePlugin"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someProperty"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>mappers, 这下引出mybatis的核心之一了，mappers作用 ? 需要配置吗？</p><p>mappers 节点下，配置我们的mapper映射文件， 所谓的mapper映射文件，就是让mybatis 用来建立数据表和javabean映射的一个桥梁。在我们实际开发中，通常一个mapper文件对应一个dao接口， 这个mapper可以看做是dao的实现。所以,mappers必须配置。</p><p>那么怎么配置呢？<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 第一种方式：通过resource指定 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/dy/dao/userDao.xml"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">第二种方式， 通过class指定接口，进而将接口与对应的xml文件形成映射关系</span></span><br><span class="line"><span class="comment">不过，使用这种方式必须保证 接口与mapper文件同名(不区分大小写)， </span></span><br><span class="line"><span class="comment">我这儿接口是UserDao,那么意味着mapper文件为UserDao.xml </span></span><br><span class="line"><span class="comment">&lt;mapper class="com.dy.dao.UserDao"/&gt;</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">      </span><br><span class="line">     <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">第三种方式，直接指定包，自动扫描，与方法二同理 </span></span><br><span class="line"><span class="comment">&lt;package name="com.dy.dao"/&gt;</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">第四种方式：通过url指定mapper文件位置</span></span><br><span class="line"><span class="comment">&lt;mapper url="file://........"/&gt;</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>本篇仅作简单介绍， 更高级的使用以及其实现原理，会在后面的实战部分进行详细讲解。</p><p>这几个节点的解析源码，与之前提到的那些节点的解析类似，源码需要的可以从这里看看。</p><h1 id="相关节点源码"><a href="#相关节点源码" class="headerlink" title="相关节点源码"></a>相关节点源码</h1><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * objectFactory 节点解析</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="literal">void</span> objectFactoryElement(XNode context) throws Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="built_in">null</span>) &#123;</span><br><span class="line">      <span class="comment">//读取type属性的值， 接下来进行实例化ObjectFactory, 并set进 configuration</span></span><br><span class="line">      <span class="comment">//到此，简单讲一下configuration这个对象，其实它里面主要保存的都是mybatis的配置</span></span><br><span class="line">      <span class="built_in">String</span> <span class="keyword">type</span> = context.getStringAttribute(<span class="string">"type"</span>);</span><br><span class="line">      <span class="comment">//读取propertie的值， 根据需要可以配置， mybatis默认实现的objectFactory没有使用properties</span></span><br><span class="line">      Properties properties = context.getChildrenAsProperties();</span><br><span class="line">      </span><br><span class="line">      ObjectFactory factory = (ObjectFactory) resolveClass(<span class="keyword">type</span>).newInstance();</span><br><span class="line">      factory.setProperties(properties);</span><br><span class="line">      configuration.setObjectFactory(factory);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * plugins 节点解析</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="literal">void</span> pluginElement(XNode <span class="keyword">parent</span>) throws Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">parent</span> != <span class="built_in">null</span>) &#123;</span><br><span class="line">      for (XNode child : <span class="keyword">parent</span>.getChildren()) &#123;</span><br><span class="line">        <span class="built_in">String</span> interceptor = child.getStringAttribute(<span class="string">"interceptor"</span>);</span><br><span class="line">        Properties properties = child.getChildrenAsProperties();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 由此可见，我们在定义一个interceptor的时候，需要去实现Interceptor, </span></span><br><span class="line"><span class="comment">        * 这儿先不具体讲，以后会详细讲解</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Interceptor interceptorInstance </span><br><span class="line">= (Interceptor) resolveClass(interceptor).newInstance();</span><br><span class="line">        interceptorInstance.setProperties(properties);</span><br><span class="line">        configuration.addInterceptor(interceptorInstance);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * mappers 节点解析</span></span><br><span class="line"><span class="comment">   * 这是mybatis的核心之一，这儿先简单介绍，在接下来的文章会对它进行分析</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="literal">void</span> mapperElement(XNode <span class="keyword">parent</span>) throws Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">parent</span> != <span class="built_in">null</span>) &#123;</span><br><span class="line">      for (XNode child : <span class="keyword">parent</span>.getChildren()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"package"</span>.<span class="keyword">equals</span>(child.getName())) &#123;</span><br><span class="line">          <span class="comment">//如果mappers节点的子节点是package, 那么就扫描package下的文件, 注入进configuration</span></span><br><span class="line">          <span class="built_in">String</span> mapperPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">          configuration.addMappers(mapperPackage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">String</span> resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">          <span class="built_in">String</span> url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">          <span class="built_in">String</span> mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line">          <span class="comment">//resource, url, class 三选一</span></span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (resource != <span class="built_in">null</span> &amp;&amp; url == <span class="built_in">null</span> &amp;&amp; mapperClass == <span class="built_in">null</span>) &#123;</span><br><span class="line">            ErrorContext.instance().resource(resource);</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            <span class="comment">//mapper映射文件都是通过XMLMapperBuilder解析</span></span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="literal">new</span> XMLMapperBuilder(inputStream</span><br><span class="line">, configuration</span><br><span class="line">, resource</span><br><span class="line">, configuration.getSqlFragments());</span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="built_in">null</span> &amp;&amp; url != <span class="built_in">null</span> &amp;&amp; mapperClass == <span class="built_in">null</span>) &#123;</span><br><span class="line">            ErrorContext.instance().resource(url);</span><br><span class="line">            InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="literal">new</span> XMLMapperBuilder(inputStream</span><br><span class="line">, configuration</span><br><span class="line">, url</span><br><span class="line">, configuration.getSqlFragments());</span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="built_in">null</span> &amp;&amp; url == <span class="built_in">null</span> &amp;&amp; mapperClass != <span class="built_in">null</span>) &#123;</span><br><span class="line">            Class&lt;<span class="meta">?&gt;</span> mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">            configuration.addMapper(mapperInterface);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            throw new BuilderException("A mapper element may only specify a url</span><br><span class="line">, resource or class, but not more than one.");</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>本次就简单的到此结束， 从下篇文章开始，将会开始接触到mybatis的核心部分，不过首先还是要讲mapper文件的配置及使用， 并通过源码进一步深入核心。</p><hr>]]></content:encoded>
      
      
    </item>
    
  </channel>
</rss>
