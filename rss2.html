<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Chloneda</title>
    <link>https://chloneda.github.io/</link>
    <atom:link href="/rss2.html" rel="self" type="application/rss+xml"/>
    
    <description>Less is more</description>
    <pubDate>Sat, 23 Nov 2019 04:09:49 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>pom.xml配置文件详解(Maven)！</title>
      <link>https://chloneda.github.io//blog/maven-pom/</link>
      <guid>https://chloneda.github.io//blog/maven-pom/</guid>
      <pubDate>Thu, 31 Oct 2019 15:34:49 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：本文转载自：&lt;a href=&quot;https://blog.csdn.net/u012152619/article/details/51485297&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>注</strong>：本文转载自：<a href="https://blog.csdn.net/u012152619/article/details/51485297" target="_blank" rel="noopener">https://blog.csdn.net/u012152619/article/details/51485297</a></p><p><strong>注：博主 Chloneda</strong>：<a href="https://chloneda.github.io/">个人博客</a> | <a href="https://www.cnblogs.com/chloneda" target="_blank" rel="noopener">博客园</a> | <a href="https://github.com/chloneda" target="_blank" rel="noopener">Github</a> | <a href="https://gitee.com/chloneda" target="_blank" rel="noopener">Gitee</a> | <a href="https://www.zhihu.com/people/chl_vip/" target="_blank" rel="noopener">知乎</a></p><p>最近打算对Maven的pom.xml文件进行一下深入研究，做一下总结，惊喜的是网上已经有比较详细的资料，为避免重复造轮子，所以转载了这篇文章。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>setting.xml主要用于配置maven的运行环境等一系列通用的属性，是全局级别的配置文件；而pom.xml主要描述了项目的maven坐标，依赖关系，开发者需要遵循的规则，缺陷管理系统，组织和licenses，以及其他所有的项目相关因素，是项目级别的配置文件。</p><h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><p>一个典型的pom.xml文件配置如下：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></span><br><span class="line"><span class="xml">xsi:schemaLocation="http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 模型版本。maven2.0必须是这样写，现在是maven2唯一支持的版本 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.winner.trade，maven会将该项目打成的jar包放本地路径：/com/winner/trade --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.winner.trade<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 本项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>trade-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 本项目目前所处的版本号 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 打包的机制，如pom,jar, maven-plugin, ejb, war, ear, rar, par，默认为jar --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 帮助定义构件输出的一些附属构件,附属构件与主构件对应，有时候需要加上classifier才能唯一的确定该构件 不能直接定义项目的classifer,因为附属构件不是项目直接默认生成的，而是由附加的插件帮助生成的 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">classifier</span>&gt;</span>...<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 定义本项目的依赖关系 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 每个dependency都对应这一个jar包 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--一般情况下，maven是通过groupId、artifactId、version这三个元素值（俗称坐标）来检索该构件， 然后引入你的工程。如果别人想引用你现在开发的这个项目（前提是已开发完毕并发布到了远程仓库），--&gt;</span> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--就需要在他的pom文件中新建一个dependency节点，将本项目的groupId、artifactId、version写入， maven就会把你上传的jar包下载到他的本地 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.winner.trade<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>trade-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- maven认为，程序对外部的依赖会随着程序的所处阶段和应用场景而变化，所以maven中的依赖关系有作用域(scope)的限制。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--scope包含如下的取值：compile（编译范围）、provided（已提供范围）、runtime（运行时范围）、test（测试范围）、system（系统范围） --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact </span></span></span><br><span class="line"><span class="xml">        ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        ......</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 设置指依赖是否可选，默认为false,即子项目默认都继承:为true,则子项目必需显示的引入，与dependencyManagement里定义的依赖类似  --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>false<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 屏蔽依赖关系。 比如项目中使用的libA依赖某个库的1.0版，libB依赖某个库的2.0版，现在想统一使用2.0版，就应该屏蔽掉对1.0版的依赖 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 为pom定义一些常量，在pom中的其它地方可以直接引用 使用方式 如下 ：$</span></span><span class="template-variable">&#123;file.encoding&#125;</span><span class="xml"><span class="comment"> --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">file.encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">file.encoding</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">java.source.version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">java.source.version</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">java.target.version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">java.target.version</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>一般来说，上面的几个配置项对任何项目都是必不可少的，定义了项目的基本属性。</p><p>这里有必要对一个不太常用的属性classifier做一下解释，因为有时候引用某个jar包，classifier不写的话会报错。</p><p>classifier元素用来帮助定义构件输出的一些附属构件。附属构件与主构件对应，比如主构件是 kimi-app-2.0.0.jar，该项目可能还会通过使用一些插件生成 如kimi-app-2.0.0-javadoc.jar （Java文档）、 kimi-app-2.0.0-sources.jar（Java源代码） 这样两个附属构件。这时候，javadoc、sources就是这两个附属构件的classifier，这样附属构件也就拥有了自己唯一的坐标。</p><p><strong>classifier的用途</strong></p><ul><li>maven download  javadoc / sources jar包的时候，需要借助classifier指明要下载那个附属构件</li><li>引入依赖的时候，有时候仅凭groupId、artifactId、version无法唯一的确定某个构件，需要借助classifier来进一步明确目标。比如JSON-lib，有时候会同一个版本会提供多个jar包，在JDK1.5环境下是一套，在JDK1.3环境下是一套：</li></ul><p>引用它的时候就要注明JDK版本，否则maven不知道你到底需要哪一套jar包：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.sf.json-<span class="class"><span class="keyword">lib</span>&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    &lt;artifactId&gt;json-<span class="class"><span class="keyword">lib</span>&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    &lt;version&gt;<span class="number">2.4</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">    &lt;classifier&gt;jdk15&lt;/classifier</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/dependency&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h1><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 产生的构件的文件名，默认值是$</span></span><span class="template-variable">&#123;artifactId&#125;</span><span class="xml"><span class="comment">-$</span></span><span class="template-variable">&#123;version&#125;</span><span class="xml"><span class="comment">。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">finalName</span>&gt;</span>myPorjectName<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 构建产生的所有文件存放的目录,默认为$</span></span><span class="template-variable">&#123;basedir&#125;</span><span class="xml"><span class="comment">/target，即项目根目录下的target --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">directory</span>&gt;</span>$</span><span class="template-variable">&#123;basedir&#125;</span><span class="xml">/target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--当项目没有规定目标（Maven2叫做阶段（phase））时的默认值， --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--必须跟命令行上的参数相同例如jar:jar，或者与某个阶段（phase）相同例如install、compile等 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">defaultGoal</span>&gt;</span>install<span class="tag">&lt;/<span class="name">defaultGoal</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--当filtering开关打开时，使用到的过滤器属性文件列表。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--项目配置信息中诸如$</span></span><span class="template-variable">&#123;spring.version&#125;</span><span class="xml"><span class="comment">之类的占位符会被属性文件中的实际值替换掉 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">filters</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">filter</span>&gt;</span>../filter.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--项目相关的所有资源路径列表，例如和项目相关的配置文件、属性文件，这些资源被包含在最终的打包文件里。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--描述了资源的目标路径。该路径相对target/classes目录（例如$</span></span><span class="template-variable">&#123;project.build.outputDirectory&#125;</span><span class="xml"><span class="comment">）。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven/messages。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>resources<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--包含的模式列表 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">includes</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--排除的模式列表 如果&lt;include&gt;与&lt;exclude&gt;划定的范围存在冲突，以&lt;exclude&gt;为准 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>jdbc.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--单元测试相关的所有资源路径，配制方法与resources类似 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;basedir&#125;</span><span class="xml">\src\main\java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--项目脚本源码目录，该目录和源码目录不同， &lt;!-- 绝大多数情况下，该目录下的内容会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">scriptSourceDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;basedir&#125;</span><span class="xml">\src\main\scripts</span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;/<span class="name">scriptSourceDirectory</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;basedir&#125;</span><span class="xml">\src\test\java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--被编译过的应用程序class文件存放的目录。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;basedir&#125;</span><span class="xml">\target\classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--被编译过的测试class文件存放的目录。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span></span></span><br><span class="line"><span class="xml">          $</span><span class="template-variable">&#123;basedir&#125;</span><span class="xml">\target\test-classes</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--项目的一系列构建扩展,它们是一系列build过程中要使用的产品，会包含在running bulid‘s classpath里面。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--他们可以开启extensions，也可以通过提供条件来激活plugins。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--简单来讲，extensions是在build过程被激活的产品 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--例如，通常情况下，程序开发完成后部署到线上Linux服务器，可能需要经历打包、 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--将包文件传到服务器、SSH连上服务器、敲命令启动程序等一系列繁琐的步骤。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--实际上这些步骤都可以通过Maven的一个插件 wagon-maven-plugin 来自动完成 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--下面的扩展插件wagon-ssh用于通过SSH的方式连接远程服务器， --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--类似的还有支持ftp方式的wagon-ftp插件 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">extension</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.wagon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wagon-ssh<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--使用的插件列表 。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">execution</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">id</span>&gt;</span>assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--配置的执行目标 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">goals</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--配置是否被传播到子POM --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">inherited</span>&gt;</span>false<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--作为DOM对象的配置,配置项因插件而异 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$</span><span class="template-variable">&#123;finalName&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">descriptor</span>&gt;</span>assembly.xml<span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器）， --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--由于性能原因，只有在真需要下载时，该元素才被设置成true。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">extensions</span>&gt;</span>false<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--项目引入插件所需要的额外依赖 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--主要定义插件的共同元素、扩展元素集合，类似于dependencyManagement， --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--所有继承于此项目的子项目都能使用。该插件配置项直到被引用时才会被解析或绑定到生命周期。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span>...<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>pom里面的仓库与setting.xml里的仓库功能是一样的。主要的区别在于，pom里的仓库是个性化的。比如一家大公司里的setting文件是公用的，所有项目都用一个setting文件，但各个子项目却会引用不同的第三方库，所以就需要在pom里设置自己需要的仓库地址。</p><h1 id="分发配置"><a href="#分发配置" class="headerlink" title="分发配置"></a>分发配置</h1><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号），还是每次都使用相同的版本号 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--参见repositories/repository元素 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">uniqueVersion</span>&gt;</span>true<span class="tag">&lt;/<span class="name">uniqueVersion</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">id</span>&gt;</span> repo-id <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">name</span>&gt;</span> repo-name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">url</span>&gt;</span>file://$</span><span class="template-variable">&#123;basedir&#125;</span><span class="xml">/target/deploy <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--构件的快照部署到哪里,如果没有配置该元素，默认部署到repository元素配置的仓库 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">id</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">name</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">url</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--部署项目的网站需要的信息 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">site</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">id</span>&gt;</span> site-id <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--部署位置的名称 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">name</span>&gt;</span> site-name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">url</span>&gt;</span>scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">site</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">downloadUrl</span> /&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--如果构件有了新的groupID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--构件新的group ID --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--构件新的artifact ID --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--构件新的版本号 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">version</span> /&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">message</span> /&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--有效的值有：none（默认），converted（仓库管理员从Maven 1 POM转换过来）， --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">status</span> /&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="仓库配置"><a href="#仓库配置" class="headerlink" title="仓库配置"></a>仓库配置</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里的选项是：always（一直），daily（默认，每日）， --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做： --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置， --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--例如，可能有人会决定只为开发目的开启对快照版本下载的支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span> repo-id <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--远程仓库名称 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span> repo-name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.169:9999/repository/ <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Maven 2为其仓库提供了一个默认的布局； --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--然而，Maven1.x有一种不同的布局。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span>&gt;</span> default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepository</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="profile配置"><a href="#profile配置" class="headerlink" title="profile配置"></a>profile配置</h1><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">activation</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--profile默认是否激活的标识 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>false<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--activation有一个内建的java版本检测，如果检测到jdk版本与期待的一样，profile被激活。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">os</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--激活profile的操作系统的名字 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--激活profile的操作系统所属家族(如 'windows') --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--激活profile的操作系统体系结构 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--激活profile的操作系统版本 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">os</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$</span></span><span class="template-variable">&#123;名称&#125;</span><span class="xml"><span class="comment">引用），其拥有对应的名称和值，Profile就会被激活。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--激活profile的属性的名称 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--激活profile的属性的值 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">file</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">exists</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/<span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--如果指定的文件不存在，则激活profile。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">missing</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/<span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">file</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">id</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">build</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">modules</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">repositories</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">pluginRepositories</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">dependencies</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">reporting</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">dependencyManagement</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">distributionManagement</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>profile配置项在setting.xml中也有，是pom.xml中profile元素的裁剪版本，包含了id，activation, repositories, pluginRepositories和 properties元素。这里的profile元素只包含这五个子元素是因为setting.xml只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。如果一个settings中的profile被激活，它的值会覆盖任何其它定义在POM中或者profile.xml中的带有相同id的profile。</p><p>pom.xml中的profile可以看做pom.xml的副本，拥有与pom.xml相同的子元素与配置方法。它包含可选的activation（profile的触发器）和一系列的changes。例如test过程可能会指向不同的数据库（相对最终的deployment）或者不同的dependencies或者不同的repositories，并且是根据不同的JDK来改变的。只需要其中一个成立就可以激活profile，如果第一个条件满足了，那么后面就不会在进行匹配。</p><h1 id="报表配置"><a href="#报表配置" class="headerlink" title="报表配置"></a>报表配置</h1><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!--描述使用报表插件产生报表的规范,特定的maven 插件能输出相应的定制和配置报表. --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--当用户执行“mvn site”，这些报表就会运行,在页面导航栏能看到所有报表的链接。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--true，则网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">excludeDefaults</span> /&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--所有产生的报表存放到哪里。默认值是$</span></span><span class="template-variable">&#123;project.build.directory&#125;</span><span class="xml"><span class="comment">/site。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--使用的报表插件和他们的配置。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">version</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">links</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">link</span>&gt;</span>http://java.sun.com/j2se/1.5.0/docs/api/<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">links</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--一组报表的多重规范，每个规范可能有不同的配置。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">reportSets</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">reportSet</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--报表集合的唯一标识符，POM继承时用到 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">id</span>&gt;</span>sunlink<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--产生报表集合时，被使用的报表的配置 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--配置是否被继承到子POMs --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--这个集合里使用到哪些报表 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">reports</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">report</span>&gt;</span>javadoc<span class="tag">&lt;/<span class="name">report</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">reports</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">reportSet</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">reportSets</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--问题管理系统（例如jira）的名字， --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">system</span>&gt;</span> jira <span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--该项目使用的问题管理系统的URL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span> http://jira.clf.com/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--项目持续集成信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--持续集成系统的名字，例如continuum --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">system</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">notifiers</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">notifier</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--传送通知的途径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--发生错误时是否通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sendOnError</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--构建失败时是否通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sendOnFailure</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--构建成功时是否通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sendOnSuccess</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--发生警告时是否通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sendOnWarning</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--不赞成使用。通知发送到哪里 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">address</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--扩展配置项 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">notifier</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">notifiers</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="项目信息配置"><a href="#项目信息配置" class="headerlink" title="项目信息配置"></a>项目信息配置</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--项目的名称, Maven产生的文档用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-maven <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--项目主页的URL, Maven产生的文档用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.clf.com/ <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标签），不鼓励使用纯文本描述。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>A maven project to study maven. <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--描述了这个项目构建环境中的前提条件。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">inceptionYear</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--项目相关邮件列表信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mailingList</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--邮件的名称 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span> Demo <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">post</span>&gt;</span> clf@126.com<span class="tag">&lt;/<span class="name">post</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">subscribe</span>&gt;</span> clf@126.com<span class="tag">&lt;/<span class="name">subscribe</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">unsubscribe</span>&gt;</span> clf@126.com<span class="tag">&lt;/<span class="name">unsubscribe</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--你可以浏览邮件信息的URL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">archive</span>&gt;</span> http:/hi.clf.com/<span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mailingList</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--项目开发者列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--某个项目开发者的信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--SCM里项目开发者的唯一标识符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span> HELLO WORLD <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--项目开发者的全名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span> banseon <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--项目开发者的email --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">email</span>&gt;</span> banseon@126.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--项目开发者的主页的URL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">roles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span>&gt;</span> Project Manager<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span>&gt;</span>Architect <span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">roles</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--项目开发者所属组织 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">organization</span>&gt;</span> demo<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--项目开发者所属组织的URL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span>http://hi.clf.com/ <span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--项目开发者属性，如即时消息如何处理等 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dept</span>&gt;</span> No <span class="tag">&lt;/<span class="name">dept</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">timezone</span>&gt;</span> -5<span class="tag">&lt;/<span class="name">timezone</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--项目的其他贡献者列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contributors</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--项目的其他贡献者。参见developers/developer元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contributor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">email</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">organization</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">organizationUrl</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">roles</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">timezone</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contributor</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">contributors</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--该元素描述了项目所有License列表。应该只列出该项目的license列表，不要列出依赖项目的license列表。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--license用于法律上的名称 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span> Apache 2 <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--官方的license正文页面的URL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.clf.com/LICENSE-2.0.txt <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">distribution</span>&gt;</span> repo<span class="tag">&lt;/<span class="name">distribution</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--关于license的补充信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comments</span>&gt;</span> Abusiness-friendly OSS license <span class="tag">&lt;/<span class="name">comments</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">connection</span>&gt;</span>scm:svn:http://svn.baidu.com/banseon/maven/<span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span>scm:svn:http://svn.baidu.com/banseon/maven/</span><br><span class="line"><span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tag</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span> http://svn.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">organization</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--组织的全名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span> demo <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--组织主页的URL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span> http://www.clf.com/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/maven/maven-pom.html" target="_blank" rel="noopener">Maven POM</a></p><hr>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>Java:如何优雅地使用close()?</title>
      <link>https://chloneda.github.io//blog/java-close/</link>
      <guid>https://chloneda.github.io//blog/java-close/</guid>
      <pubDate>Thu, 31 Oct 2019 15:14:52 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;注：本文出自博主 Chloneda&lt;/strong&gt;：&lt;a href=&quot;https://chloneda.github.io/&quot;&gt;个人博客&lt;/a&gt; | &lt;a href=&quot;https://www.cnblogs.com/chloneda&quot; target=&quot;_b
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>注：本文出自博主 Chloneda</strong>：<a href="https://chloneda.github.io/">个人博客</a> | <a href="https://www.cnblogs.com/chloneda" target="_blank" rel="noopener">博客园</a> | <a href="https://github.com/chloneda" target="_blank" rel="noopener">Github</a> | <a href="https://gitee.com/chloneda" target="_blank" rel="noopener">Gitee</a> | <a href="https://www.zhihu.com/people/chl_vip/" target="_blank" rel="noopener">知乎</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文尽量采用通俗易懂、循序渐进的方式，让大家真正优雅地使用close()方法！</p><h1 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h1><p>平时我们使用资源后一般都会关闭资源，即close()方法，但这个步骤重复性很高，还面临上述执行顺序不明的风险，而且很多人还是不能正确合理地关闭资源。</p><p>我们来看看close()是怎么错误地关闭资源的？</p><h1 id="错误的close"><a href="#错误的close" class="headerlink" title="错误的close()"></a>错误的close()</h1><p>先来看看如下的错误关闭资源方式：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chloneda.jutils.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author chloneda</span></span><br><span class="line"><span class="comment"> * @description: close()方法测试</span></span><br><span class="line"><span class="comment"> * 错误的close()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> CloseTest &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement st = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载驱动程序</span></span><br><span class="line">            <span class="keyword">Class</span>.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">            <span class="comment">//2.获得数据库链接</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/common"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br><span class="line">            <span class="comment">//3.通过数据库的连接操作数据库，实现增删改查</span></span><br><span class="line">            st = conn.createStatement();</span><br><span class="line">            rs = st.executeQuery(<span class="string">"select * from new_table"</span>);</span><br><span class="line">            <span class="comment">//4.处理数据库的返回结果</span></span><br><span class="line">            <span class="keyword">while</span> (rs.<span class="keyword">next</span>()) &#123;</span><br><span class="line">                System.out.<span class="keyword">println</span>(rs.getString(<span class="string">"id"</span>) + <span class="string">" "</span> + rs.getString(<span class="string">"name"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5.关闭资源</span></span><br><span class="line">            rs.close();</span><br><span class="line">            st.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的资源关闭写在了try代码块中，一旦close方法调用之前(比如<strong>3步骤</strong>)就抛出异常，那么关闭资源的代码就永远不会得到执行。</p><p>如果我们把关闭资源的代码放在finally中行不行呢？<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">try</span> &#123;</span><br><span class="line">    <span class="comment">//1.加载驱动程序</span></span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">    <span class="comment">//2.获得数据库链接</span></span><br><span class="line">    conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/common"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br><span class="line">    <span class="comment">//3.通过数据库的连接操作数据库，实现增删改查</span></span><br><span class="line">    st = conn.createStatement();</span><br><span class="line">    rs = st.executeQuery(<span class="string">"select * from new_table"</span>);</span><br><span class="line">    <span class="comment">//4.处理数据库的返回结果</span></span><br><span class="line">    <span class="built_in">while</span> (rs.next()) &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(rs.getString(<span class="string">"id"</span>) + <span class="string">" "</span> + rs.getString(<span class="string">"name"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="built_in">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    <span class="comment">//5.关闭资源</span></span><br><span class="line">    <span class="built_in">try</span> &#123;</span><br><span class="line">        rs.<span class="built_in">close</span>();</span><br><span class="line">        st.<span class="built_in">close</span>();</span><br><span class="line">        conn.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>答案是不行！如果在 <strong>2步骤</strong> 的try中conn获得数据库链接抛出异常，那么conn仍然为null，此时进入finally代码块中，执行close()就报空指针异常了，关闭资源没有意义！因此，我们需要在close()之前判断一下conn等是否为空，只有不为空的时候才需要close。</p><h1 id="常见的close"><a href="#常见的close" class="headerlink" title="常见的close()"></a>常见的close()</h1><p>针对上述场景，得到常见的使用close()方式如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author chloneda</span></span><br><span class="line"><span class="comment"> * @description: close()方法测试</span></span><br><span class="line"><span class="comment"> * 常见的close()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CloseTest</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        Connection conn = <span class="literal">null</span>;</span><br><span class="line">        Statement st = <span class="literal">null</span>;</span><br><span class="line">        ResultSet rs = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载驱动程序</span></span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">            <span class="comment">//2.获得数据库链接</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/common"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br><span class="line">            <span class="comment">//3.通过数据库的连接操作数据库，实现增删改查</span></span><br><span class="line">            st = conn.createStatement();</span><br><span class="line">            rs = st.executeQuery(<span class="string">"select * from new_table"</span>);</span><br><span class="line">            <span class="comment">//4.处理数据库的返回结果</span></span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(rs.getString(<span class="string">"id"</span>) + <span class="string">" "</span> + rs.getString(<span class="string">"name"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//5.关闭资源</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != rs) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    rs.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != st) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    st.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != conn) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是常见的close()！但是finally代码块的代码重复性太高了，这还只是三个资源的关闭，如果有很多个资源需要在finally中关闭，那不是需要编写很多不优雅的代码？其实，关闭资源是没啥逻辑的代码，我们需要精简代码，减少代码重复性，优雅地编程！</p><h1 id="使用AutoCloseable接口"><a href="#使用AutoCloseable接口" class="headerlink" title="使用AutoCloseable接口"></a>使用AutoCloseable接口</h1><p>自从Java7以后，我们可以使用 <strong>AutoCloseable接口</strong> (Closeable接口也可以)来优雅的关闭资源了 看看修改例子：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author chloneda</span></span><br><span class="line"><span class="comment"> * @description: close()方法测试</span></span><br><span class="line"><span class="comment"> * 使用AutoCloseable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CloseTest</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        Connection conn = <span class="literal">null</span>;</span><br><span class="line">        Statement st = <span class="literal">null</span>;</span><br><span class="line">        ResultSet rs = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载驱动程序</span></span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">            <span class="comment">//2.获得数据库链接</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/common"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br><span class="line">            <span class="comment">//3.通过数据库的连接操作数据库，实现增删改查</span></span><br><span class="line">            st = conn.createStatement();</span><br><span class="line">            rs = st.executeQuery(<span class="string">"select * from new_table"</span>);</span><br><span class="line">            <span class="comment">//4.处理数据库的返回结果</span></span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(rs.getString(<span class="string">"id"</span>) + <span class="string">" "</span> + rs.getString(<span class="string">"name"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//5.关闭资源，调用自定义的close()方法</span></span><br><span class="line">            close(rs);</span><br><span class="line">            close(st);</span><br><span class="line">            close(conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span>(<span class="params">AutoCloseable closeable</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (closeable != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                closeable.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的finally代码块的代码量是不是减少了许多，就单纯地调用的静态的 <strong>close(AutoCloseable closeable)</strong> 方法。为什么可以这样呢？</p><p>其实Connection、Statement、ResultSet三个接口都继承了<strong>AutoCloseable接口</strong>。所以只要涉及到资源的关闭，继承了AutoCloseable接口，实现了close()方法，我们都可以调用 <strong>close(AutoCloseable closeable)</strong> 方法进行资源关闭。</p><p>此外，java IO流的很多类都实现了 <strong>Closeable接口</strong>，而<strong>Closeable接口</strong>又继承自 <strong>AutoCloseable接口</strong>，也可以调用上面的 <strong>close(AutoCloseable closeable)</strong> 方法进行资源关闭。是不是一语惊醒梦中人啊？</p><h1 id="使用try-with-resources"><a href="#使用try-with-resources" class="headerlink" title="使用try-with-resources"></a>使用try-with-resources</h1><p>其实Java7以后，还有一种关闭资源的方式，也就是 <strong>try-with-resources</strong>，这种方式也是我们推荐的！很优雅！</p><p>我们来看看它是怎么优雅地关闭资源的！<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author chloneda</span></span><br><span class="line"><span class="comment"> * @description: close()方法测试</span></span><br><span class="line"><span class="comment"> * 使用try-with-resources</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> CloseTest &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//1.加载驱动程序</span></span><br><span class="line">        <span class="keyword">Class</span>.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="comment">//2.获得数据库链接</span></span><br><span class="line">             Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/common"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br><span class="line">             <span class="comment">//3.通过数据库的连接操作数据库，实现增删改查</span></span><br><span class="line">             Statement st = conn.createStatement();</span><br><span class="line">             ResultSet rs = st.executeQuery(<span class="string">"select * from new_table"</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">//4.处理数据库的返回结果</span></span><br><span class="line">            <span class="keyword">while</span> (rs.<span class="keyword">next</span>()) &#123;</span><br><span class="line">                System.out.<span class="keyword">println</span>(rs.getString(<span class="string">"id"</span>) + <span class="string">" "</span> + rs.getString(<span class="string">"name"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方式就省略了finally，不必重复编写关闭资源的代码了！而且资源也得到了关闭！怎么验证这个问题？可以查看底下的 <strong>实际应用</strong> 章节！</p><p>其实<strong>try-with-resources</strong>关闭资源的操作，本质上是继承了<strong>java.lang.AutoCloseable接口</strong>，实现了close方法，所以使用<strong>try-with-resources</strong>能关闭资源。很神奇吧！</p><h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p>这个章节就是验证使用<strong>try-with-resources</strong>可以关闭资源的问题的！</p><p>上面我们说了使用<strong>try-with-resources</strong>关闭资源，只要是继承了<strong>java.lang.AutoCloseable接口</strong> 实现close()方法就可以使用！</p><p>我们自定义一个资源类，来看看实际应用吧！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chloneda.jutils.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chloneda</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 资源类, 实现AutoCloseable接口.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"useResource:&#123;&#125; 正在使用资源!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"close:&#123;&#125; 自动关闭资源!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用try-with-resources自动关闭资源测试.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoClosableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 使用try-with-resource，自动关闭资源 */</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                Resources resource = <span class="keyword">new</span> Resources()</span><br><span class="line">        ) &#123;</span><br><span class="line">            resource.useResource();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.getMessage();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Finally!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果输出。<br><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useResource:&#123;&#125; 正在使用资源!</span><br><span class="line">close:&#123;&#125; 自动关闭资源!</span><br><span class="line">Finally!</span><br></pre></td></tr></table></figure></p><p>看到运行结果了吗？Resources类实现AutoCloseable接口，实现了close()方法，<strong>try-with-resources</strong> 就会自动关闭资源！</p><p>一旦<strong>Resources</strong>类没有继承<strong>java.lang.AutoCloseable接口</strong>，没有实现close()方法，AutoClosableTest类的try模块就在编译期报错，提示信息如下。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Incompatible types.</span><br><span class="line">Required: java<span class="selector-class">.lang</span><span class="selector-class">.AutoCloseable</span></span><br><span class="line">Found: com<span class="selector-class">.chloneda</span><span class="selector-class">.jutils</span><span class="selector-class">.test</span><span class="selector-class">.Resources</span></span><br></pre></td></tr></table></figure></p><p>最后，需要说明的是<strong>try-with-resources</strong>就是一个<strong>JVM语法糖</strong>！关于JVM语法糖可以查查相关资料，看看Java中有哪些有趣的语法糖！</p><h1 id="尾语"><a href="#尾语" class="headerlink" title="尾语"></a>尾语</h1><p>《Effective Java》在第三版中也推荐使用try-with-resources语句替代try-finally语句。</p><p>所以在处理必须关闭的资源时，使用try-with-resources语句替代try-finally语句。生成的代码更简洁，更清晰，并且生成的异常更有用。 try-with-resources语句在编写必须关闭资源的代码时会更容易，也不会出错，而使用try-finally语句实际上是不可能的。</p><p>如此，推荐大家使用<strong>try-with-resources</strong>优雅地关闭资源！</p><hr>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>深入浅出设计模式系列--单例模式</title>
      <link>https://chloneda.github.io//blog/pattern-singleton/</link>
      <guid>https://chloneda.github.io//blog/pattern-singleton/</guid>
      <pubDate>Wed, 30 Oct 2019 15:13:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;注：本文出自博主 Chloneda&lt;/strong&gt;：&lt;a href=&quot;https://chloneda.github.io/&quot;&gt;个人博客&lt;/a&gt; | &lt;a href=&quot;https://www.cnblogs.com/chloneda&quot; target=&quot;_b
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>注：本文出自博主 Chloneda</strong>：<a href="https://chloneda.github.io/">个人博客</a> | <a href="https://www.cnblogs.com/chloneda" target="_blank" rel="noopener">博客园</a> | <a href="https://github.com/chloneda" target="_blank" rel="noopener">Github</a> | <a href="https://gitee.com/chloneda" target="_blank" rel="noopener">Gitee</a> | <a href="https://www.zhihu.com/people/chl_vip/" target="_blank" rel="noopener">知乎</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>深入浅出设计模式系列，尽量采用通俗易懂、循序渐进的方式，让大家真正理解设计模式的精髓！</strong></p><p>先了解一下单例模式定义：确保一个类只有一个自行实例化的实例，并提供一个全局访问点，向整个系统提供这个实例。</p><p>单例模式的本质：控制实例的数目。</p><h1 id="单例模式的主要问题"><a href="#单例模式的主要问题" class="headerlink" title="单例模式的主要问题"></a>单例模式的主要问题</h1><p>我们经常使用的单例模式主要涉及的问题有：</p><ul><li>如何保证一个类只有一个实例？</li><li>如何保证单例模式在多线程环境下的线程安全？</li><li>如何防止反射对单例模式的破坏？</li><li>如何保证单例模式在序列化与反序列化过程中实例的唯一性？</li></ul><p>下面针对以上的问题进行深入研究！</p><h1 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h1><p>单例模式常见的有饿汉式、懒汉式、双重检验锁、静态内部类方式、枚举方式，这里主要讨论多线程环境下的单例模式。</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>这种饿汉式单例是比较常见的，我们看看它是怎么实现的！</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.chloneda.jutils.test;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Created by chloneda</span><br><span class="line"> * @Description: 饿汉式单例模式</span><br><span class="line"> */</span><br><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> Singleton<span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton();</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> private</span> Singleton ()&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton getInstance() &#123;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式单例本身是线程安全的，但它采用空间换取时间的方式，当类加载时马上就实例化Singleton对象，不管使用者用不用，后续每次调用 <strong>getInstance()</strong> 方法的时候，就不需要判断它是否实例化，从而节约了时间。但有些情况下需要懒加载实例化对象，针对这种情形，于是有了懒汉式的单例模式。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>我们看一下懒汉式单例模式的实现。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.chloneda.jutils.test;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Created by chloneda</span><br><span class="line"> * @Description: 懒汉式单例模式</span><br><span class="line"> */</span><br><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> private</span> Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton getInstance() &#123;</span><br><span class="line">       <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">           <span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是我们常见的懒汉式单例模式！大家发现没？这种懒汉式单例模式在多线程环境下，存在线程安全的问题！那它是怎么引发多线程安全的问题的呢？</p><p>为便于大家理解单例模式在多线程环境下容易出现的问题，下面直接采用图片的方式，请看图片：<br><img src="/uploads/pattern-singleton-thread.png" alt="pattern-singleton-thread.png"></p><p>从上图可知多线程环境下懒汉式单例模式的问题了吧！</p><p>针对上面单例模式存在多线程安全的缺陷，有人说这还不容易解决，直接在 <strong>getInstance</strong> 方法上加上Java关键词 <strong>synchronized</strong>， 即。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="function">Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可是你可别忘了，在Java中每个语句都是执行都需要时间的，加上 <strong>synchronized</strong> 关键词需要底层执行更多的语句，并且每次都需要通过 <strong>getInstance()</strong> 方法获取实例，效率非常底，更别说在多线程高并发下的执行情况了，因此必须对此加以改进。</p><h2 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h2><p>针对上面懒汉式单例的性能问题，我通过修改得到双重检验锁单例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chloneda.jutils.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by chloneda</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 双重检验锁单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检测机制</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检测机制</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面双重检验锁单例的写法，是不是比懒汉式单例效率高，因为每次需要通过 <strong>getInstance</strong> 方法获取实例时，只在第一次实例化 <strong>instance</strong> 加同步锁，后续多线程进入该方法后，直接进入外层 <strong>if (instance == null)</strong> 判断语句，得知instance实例不为空，就直接返回instance实例了。</p><p>虽然上面的双重校验锁机制的单例增加了一定的安全性，提高了效率，但是这个双重检验锁单例也有缺陷，因为它没有考虑到 JVM 编译器的指令重排。</p><p><strong>1、什么是指令重排</strong><br>比如 java 中简单的一句 instance = new Singleton()，会被编译器编译成如下 JVM 指令。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();    //1：分配对象的内存空间 </span><br><span class="line">ctorInstance(memory);  //2：初始化对象 </span><br><span class="line">instance = memory;     //3：设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure></p><p>但是这些指令顺序并非一成不变，有可能会经过 JVM 和 CPU 的优化，指令重排成下面的顺序。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();    //1：分配对象的内存空间 </span><br><span class="line">instance = memory;      //3：设置instance指向刚分配的内存地址 </span><br><span class="line">ctorInstance(memory);  //2：初始化对象</span><br></pre></td></tr></table></figure></p><p><strong>2、影响</strong></p><p>高并发情况下，线程 A 执行 <strong>instance = new Singleton();</strong> 完上面的1、3步骤时，准备走2，即 instance 对象还未完成初始化，但此时 <strong>instance</strong> 已经不再指向 null 。</p><p>此时线程 B 抢占到CPU资源，执行 if(instance == null) 时，返回的结果会是 false，</p><p>从而返回一个没有初始化完成的instance对象。</p><p><strong>3、解决方法</strong><br>如何去解决这个问题呢？很简单，可以利用关键字 volatile 来修饰 instance 对象，如下优化：</p><p><strong>双重检验锁改进</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chloneda.jutils.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by chloneda</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 单例模式使用双重检验锁方式实现，优点：延迟初始化、性能优化、线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile 修饰符在此处的作用就是阻止变量访问前后的指令重排，从而保证了指令的执行顺序。</p><p>即指令的执行顺序是严格按照上文的 1、2、3 步骤来执行，从而保证对象不会出现中间态。</p><p>但是上面的双重检验锁改进版单例模式也有问题，因为它无法解决反射对单例模式的破坏性。我将在静态内部类单例模式中加以阐述。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>在了解静态内部类单例模式之前，让我们先了解一下静态内部类的两个知识。</p><ul><li>静态内部类加载一个类时，其内部类不会同时被加载。</li><li>一个类被加载，当且仅当其某个静态成员如静态域、构造器、静态方法等被调用时才会被加载。 </li></ul><p>我们先看一个静态内部类的测试，以验证上面这两个观点。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.chloneda.jutils.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Created by chloneda</span></span><br><span class="line"><span class="comment"> * @Description: 静态内部类测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OuterClassTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OuterClassTest</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"1、我是外部类静态模块..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">class</span> <span class="title">StaticInnerTest</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> OuterClassTest oct = <span class="keyword">new</span> OuterClassTest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"2、我是静态内部类的静态模块... "</span> + oct);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticInnerMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"3、静态内部类方法模块... "</span> + oct);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        OuterClassTest oct = <span class="keyword">new</span> OuterClassTest(); <span class="comment">// 此刻内部类不会被加载</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"===========分割线==========="</span>);</span><br><span class="line">        OuterClassTest.StaticInnerTest.staticInnerMethod(); <span class="comment">// 调用内部类的静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出如下。<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、我是外部类静态模块<span class="string">...</span></span><br><span class="line">=========分割线=========</span><br><span class="line">2、我是静态内部类的静态模块<span class="string">...</span> com.chloneda.jutils.test.OuterClassTest@b1bc7ed</span><br><span class="line">3、静态内部类的方法模块<span class="string">...</span> com.chloneda.jutils.test.OuterClassTest@b1bc7ed</span><br></pre></td></tr></table></figure></p><p>从运行结果来看，验证是正确的！</p><p>由于静态内部类的特性，只有在其被第一次引用的时候才会被加载，所以可以保证其线程安全性。</p><p>由此可得出静态内部类单例模式的写法。</p><p><strong>静态内部类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chloneda.jutils.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by chloneda</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> *  单例模式使用静态内部类方式实现，优点：实现代码简洁、延迟初始化、线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种写法的单例，外部无法访问静态内部类 SingletonHolder，只有当调用 Singleton.getInstance() 方法的时候，才能得到单例对象 INSTANCE。</p><p>而且静态内部类单例的 <strong>getInstance()</strong> 方法中没有使用 <strong>synchronized</strong> 关键字，提高了执行效率，同时兼顾了懒汉模式的内存优化（使用时才初始化，节约空间，达到懒加载的目的）以及饿汉模式的安全性。</p><p>但这种单例也有问题！这种方式需要两个类去做到这一点，也就是说，虽然懒加载静态内部类的对象，但其 外部类及内部静态类的 Class 对象还是会被创建，同时也无法防止反射对单例的破坏性（<strong>很多单例的写法都有这个通病</strong>），从而无法保证对象的唯一性。</p><p>我们通过以下测试类测试反射对静态内部类的破坏性。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Created by chloneda</span></span><br><span class="line"><span class="comment"> * @Description: 反射破坏静态内部类单例模式的测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingletonReflectTest</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//创建第一个实例</span></span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射创建第二个实例</span></span><br><span class="line">        Singleton instance2 = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;Singleton&gt; clazz = Singleton.class;</span><br><span class="line">            Constructor&lt;Singleton&gt; cons = clazz.getDeclaredConstructor();</span><br><span class="line">            cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            instance2 = cons.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查两个实例的hash值</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Instance1 hashCode: "</span> + instance1.hashCode());</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Instance2 hashCode: "</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下。<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Instance1 hashCode: <span class="number">186370029</span></span><br><span class="line">Instance2 hashCode: <span class="number">2094548358</span></span><br></pre></td></tr></table></figure></p><p>从输出结果可以看出，通过反射获取构造函数，并调用 <strong>setAccessible(true)</strong> 就可以调用私有的构造函数，从而得到Instance1和Instance2两个不同的对象。</p><p><strong>静态内部类改进</strong></p><p>如何防止这种反射对单例的破坏呢？我们可以通过修改构造器，让它在被要求创建第二个实例的时候抛出异常。</p><p>静态内部类修改如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chloneda.jutils.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by chloneda</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 防止反射破坏静态内部类单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (initialized == <span class="keyword">false</span>) &#123;</span><br><span class="line">                initialized = !initialized;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例模式禁止二次创建，防止反射！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们还用一个 <strong>SingletonReflectTest</strong> 测试类测试一下，输出结果如下。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.InvocationTargetException</span></span><br><span class="line">at sun<span class="selector-class">.reflect</span><span class="selector-class">.NativeConstructorAccessorImpl</span><span class="selector-class">.newInstance0</span>(Native Method)</span><br><span class="line">at sun<span class="selector-class">.reflect</span><span class="selector-class">.NativeConstructorAccessorImpl</span><span class="selector-class">.newInstance</span>(NativeConstructorAccessorImpl<span class="selector-class">.java</span>:<span class="number">62</span>)</span><br><span class="line">at sun<span class="selector-class">.reflect</span><span class="selector-class">.DelegatingConstructorAccessorImpl</span><span class="selector-class">.newInstance</span>(DelegatingConstructorAccessorImpl<span class="selector-class">.java</span>:<span class="number">45</span>)</span><br><span class="line">at java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Constructor</span><span class="selector-class">.newInstance</span>(Constructor<span class="selector-class">.java</span>:<span class="number">423</span>)</span><br><span class="line">at com<span class="selector-class">.chloneda</span><span class="selector-class">.jutils</span><span class="selector-class">.test</span><span class="selector-class">.SingletonReflectTest</span><span class="selector-class">.main</span>(Singleton<span class="selector-class">.java</span>:<span class="number">46</span>)</span><br><span class="line">Caused by: java<span class="selector-class">.lang</span><span class="selector-class">.RuntimeException</span>: 单例模式禁止二次创建，防止反射！</span><br><span class="line">at com<span class="selector-class">.chloneda</span><span class="selector-class">.jutils</span><span class="selector-class">.test</span><span class="selector-class">.Singleton</span>.&lt;init&gt;(Singleton<span class="selector-class">.java</span>:<span class="number">24</span>)</span><br><span class="line">... <span class="number">5</span> more</span><br><span class="line">Instance1 hashCode: <span class="number">1053782781</span></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="selector-class">.lang</span><span class="selector-class">.NullPointerException</span></span><br><span class="line">at com<span class="selector-class">.chloneda</span><span class="selector-class">.jutils</span><span class="selector-class">.test</span><span class="selector-class">.SingletonReflectTest</span><span class="selector-class">.main</span>(Singleton<span class="selector-class">.java</span>:<span class="number">53</span>)</span><br></pre></td></tr></table></figure></p><p>所以我们通过修改构造器防止反射对单例的破坏性。</p><p>但是这种方式的单例也存在问题！什么问题呢？即序列化和反序列化之后无法继续保持单例（<strong>很多单例的写法也有这个通病</strong>）。</p><p>我们让上面防止反射破坏静态内部类的单例实现 <strong>Serializable</strong> 接口。<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></p><p>并通过以下测试类进行序列化和反序列化测试。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Created by chloneda</span></span><br><span class="line"><span class="comment"> * @Description: 序列化破坏静态内部类单例模式的测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pubic <span class="keyword">class</span> <span class="title">SingletonSerializableTest</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Singleton instance1 = Singleton.getInstance();</span><br><span class="line">            ObjectOutput <span class="keyword">out</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">out</span> = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"Singleton.ser"</span>));</span><br><span class="line">            <span class="keyword">out</span>.writeObject(instance1);</span><br><span class="line">            <span class="keyword">out</span>.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从文件中反序列化一个Singleton对象</span></span><br><span class="line">            ObjectInput <span class="keyword">in</span> = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Singleton.ser"</span>));</span><br><span class="line">            Singleton instance2 = (Singleton) <span class="keyword">in</span>.readObject();</span><br><span class="line">            <span class="keyword">in</span>.close();</span><br><span class="line"></span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"instance1 hashCode: "</span> + instance1.hashCode());</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"instance2 hashCode: "</span> + instance2.hashCode());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果如下。<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instance1 hashCode: <span class="number">240650537</span></span><br><span class="line">instance2 hashCode: <span class="number">1566502717</span></span><br></pre></td></tr></table></figure></p><p>从结果可以看出，很明显不是同一个单例对象！</p><p>那如何解决这个问题呢？</p><p><strong>静态内部类再改进</strong></p><p>我们可以实现 readResolve() 方法，它代替了从流中读取对象，确保了在序列化和反序列化的过程中没人可以创建新的实例。</p><p>可以得到改进版的静态内部类单例，可以有效防止序列化及反射的破坏！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chloneda.jutils.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by chloneda</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 可以防止序列化及反射破坏的静态内部类单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (initialized == <span class="keyword">false</span>) &#123;</span><br><span class="line">                initialized = !initialized;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例模式禁止二次创建，防止反射！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们再用上面的 <strong>SingletonSerializableTest</strong> 测试类测试一下结果。</p><p>输出结果如下。<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instance1 hashCode: <span class="number">240650537</span></span><br><span class="line">instance2 hashCode: <span class="number">240650537</span></span><br></pre></td></tr></table></figure></p><p>此时就说明，单例在序列化和反序列化时的对象是一致的了。</p><p>其实上面饿汉式、懒汉式、双重校验锁及静态内部类单例所出现的问题，都可以通过枚举型单例进行解决，这也是《Effective Java》中推荐的写法。</p><h2 id="枚举型"><a href="#枚举型" class="headerlink" title="枚举型"></a>枚举型</h2><p>我们知道java中的枚举类是在JDK5中才有的，因此枚举型单例对大部分人来说是比较陌生的，先举一个例子吧！</p><p>枚举型单例实现很简单。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就三行，很简单吧。那么为了大家更方便理解，我再用以下例子来剖析一下枚举型单例吧！</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.chloneda.jutils.test;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Created by chloneda</span><br><span class="line"> * @<span class="symbol">Description:</span> 单例类</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">public class Singleton&#123;&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 枚举型单例</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">public enum SingletonEnum &#123;</span></span><br><span class="line"><span class="regexp">    INSTANCE;</span></span><br><span class="line"><span class="regexp">    private Singleton singleton = null;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    private SingletonEnum() &#123;</span></span><br><span class="line"><span class="regexp">        singleton = new Singleton();</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    public Singleton getInstance() &#123;</span></span><br><span class="line"><span class="regexp">        return singleton;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>上面这个枚举型单例，通过反编译你就会得到以下代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonEnum</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">SingletonEnum</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonEnum INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonEnum[] values();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonEnum <span class="title">valueOf</span><span class="params">(String)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码经过处理（只是去掉包名，便于阅读）！</p><p>可以发现枚举型单例相关属性都被 <strong>static</strong> 关键词修饰，仔细一看还是 <strong>final</strong> 修饰的一个普通类，只不过继承自 <strong>java.lang.Enum</strong> 枚举类而已。也就是说这个枚举型单例是经过编译器处理的，这是JDK5提供的语法糖（Syntactic Sugar），所谓语法糖是指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，只是在编译器上做了手脚，可以更方便我们程序员使用。</p><p>枚举型单例天生就是线程安全的，这是因为 <strong>JVM类加载机制</strong> 的缘故，这里就不展开论述了，可以参考一下相关资料！</p><h3 id="枚举型单例反射问题"><a href="#枚举型单例反射问题" class="headerlink" title="枚举型单例反射问题"></a>枚举型单例反射问题</h3><p>我们先了解一下枚举型单例为什么可以防止反射的问题？</p><p>其实在JDK5中，Java虚拟机对枚举类做了特殊处理，即 <strong>JVM</strong> 会阻止反射获取枚举类的私有构造方法。</p><p>我们用这个枚举型单例作为例子。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续使用上文的反射代码 <strong>SingletonReflectTest</strong> 来进行测试，先把SingletonReflectTest类的创建第一个实例的语句改成这样。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建第一个实例</span></span><br><span class="line">Singleton instance1 = Singleton.INSTANCE;</span><br></pre></td></tr></table></figure><p>运行后输出结果如下。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java<span class="selector-class">.lang</span><span class="selector-class">.NoSuchMethodException</span>: com<span class="selector-class">.chloneda</span><span class="selector-class">.jutils</span><span class="selector-class">.test</span><span class="selector-class">.Singleton</span>.&lt;init&gt;()</span><br><span class="line">at java<span class="selector-class">.lang</span><span class="selector-class">.Class</span><span class="selector-class">.getConstructor0</span>(Class<span class="selector-class">.java</span>:<span class="number">3082</span>)</span><br><span class="line">at java<span class="selector-class">.lang</span><span class="selector-class">.Class</span><span class="selector-class">.getDeclaredConstructor</span>(Class<span class="selector-class">.java</span>:<span class="number">2178</span>)</span><br><span class="line">at com<span class="selector-class">.chloneda</span><span class="selector-class">.jutils</span><span class="selector-class">.test</span><span class="selector-class">.SingletonReflectTest</span><span class="selector-class">.main</span>(SingletonReflectTest<span class="selector-class">.java</span>:<span class="number">18</span>)</span><br><span class="line">Instance1 hashCode: <span class="number">1929600551</span></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="selector-class">.lang</span><span class="selector-class">.NullPointerException</span></span><br><span class="line">at com<span class="selector-class">.chloneda</span><span class="selector-class">.jutils</span><span class="selector-class">.test</span><span class="selector-class">.SingletonReflectTest</span><span class="selector-class">.main</span>(SingletonReflectTest<span class="selector-class">.java</span>:<span class="number">27</span>)</span><br></pre></td></tr></table></figure></p><p>直接报异常，也就是说枚举型单例可以完美解决反射的问题。</p><h3 id="枚举型单例反序列化问题"><a href="#枚举型单例反序列化问题" class="headerlink" title="枚举型单例反序列化问题"></a>枚举型单例反序列化问题</h3><p>下面再深入了解一下为什么枚举会满足反序列化的问题</p><p>Java规范中规定，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，因此在枚举类型的序列化和反序列化上，Java做了特殊的规定。</p><p>在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过 java.lang.Enum 的 valueOf() 方法来根据名字查找枚举对象。</p><p>以上面的<strong>public enum SingletonEnum</strong> 枚举为例，序列化的时候只将 INSTANCE 这个名称输出，反序列化的时候再通过这个名称，查找对于的枚举类型，因此反序列化后的实例也会和之前被序列化的对象实例相同。</p><p>我们通过测试类测试一下，我们首先让枚举型单例 <strong>SingletonEnum</strong> 实现 <strong>Serializable</strong> 接口。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span> <span class="title">implements</span> <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></p><p>再使用序列化测试类 <strong>SingletonSerializableTest</strong> 进行测试，输出结果如下。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instance1 hashCode: <span class="number">1674896058</span></span><br><span class="line">instance2 hashCode: <span class="number">1674896058</span></span><br></pre></td></tr></table></figure><p>也就是说枚举型单例可以解决反序列化带来的问题。</p><p>综上所述，枚举型单例可以有效解决线程安全、反射、反序列化带来的问题！</p><p>然而你别得意，枚举型单例也有问题，就是它无法进行懒加载，因为枚举型单例的实例对象是在<strong>静态代码块</strong>即static块进行初始化的，是不是一语惊醒梦中人啊！</p><h2 id="中场休息"><a href="#中场休息" class="headerlink" title="中场休息"></a>中场休息</h2><p>说了这么多单例模式，知道了各个单例模式利弊，所以当我们使用时，我们要根据实际情况做出取舍，因为我们不可能实现一个单例可以满足所有情况。</p><p>下面让我们来看看单例模式的实际应用场景吧！</p><h1 id="单例模式的实际应用"><a href="#单例模式的实际应用" class="headerlink" title="单例模式的实际应用"></a>单例模式的实际应用</h1><h2 id="生活中的单例"><a href="#生活中的单例" class="headerlink" title="生活中的单例"></a>生活中的单例</h2><p>我们计算机上有很多场景应用到单例模式，可能经常看到，但我们并没有认识到，比如以下例子。</p><ul><li><p>Windows的任务管理器（Task Manager）就是很典型的单例模式。你试过能打开两个windows的任务管理器吗？</p></li><li><p>windows的回收站也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。 </p></li><li><p>网站的计数器，一般也是采用单例模式实现，否则难以同步。 </p></li><li><p>应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</p></li><li><p>Web应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。 </p></li><li><p>多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。</p></li></ul><p>当然还有很多单例模式的应用，希望大家可以发现哦！</p><h2 id="JDK中的单例"><a href="#JDK中的单例" class="headerlink" title="JDK中的单例"></a>JDK中的单例</h2><h3 id="java-lang-Runtime"><a href="#java-lang-Runtime" class="headerlink" title="java.lang.Runtime"></a>java.lang.Runtime</h3><p>Runtime类封装了Java运行时的环境。每一个java程序实际上都是启动了一个JVM进程，那么每个JVM进程都是对应这一个Runtime实例，此实例是由JVM为其实例化的。每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。</p><p>由于Java是单进程的，所以，在一个JVM中，Runtime的实例应该只有一个，所以应该使用单例来实现。</p><p>我们来看看 <strong>java.lang.Runtime</strong> 的单例模式实现。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="keyword">Runtime</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">Runtime</span> currentRuntime = <span class="keyword">new</span> <span class="keyword">Runtime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">Runtime</span> getRuntime() &#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Runtime</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看见没，这里使用的单例模式是饿汉式单例模式，也就是说，当类第一次被classloader加载的时候，实例就被创建出来了，当调用者每次调用的时候，就不需要再判断这个实例是否已经初始化，典型的空间换时间方案。</p><p>这里使用的是饿汉式单例模式，无疑是非常合适的！</p><h3 id="java-awt-Toolkit"><a href="#java-awt-Toolkit" class="headerlink" title="java.awt.Toolkit"></a>java.awt.Toolkit</h3><p>Toolkit是GUI中的类，与RunTime不同的是Toolkit采用的是懒汉式单例模式，因为它们并不需要事先创建好，只要在第一次真正用到的时候再创建就可以了。</p><p>我们来看看Toolkit类的代码。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">abstract</span> <span class="title">class</span> <span class="title">Toolkit</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Toolkit toolkit;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> synchronized Toolkit getDefaultToolkit() &#123;</span><br><span class="line">        <span class="keyword">if</span> (toolkit == <span class="literal">null</span>) &#123;</span><br><span class="line">            java.security.AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> <span class="type">java</span>.security.PrivilegedAction&lt;<span class="keyword">Void</span>&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">Void</span> run() &#123;</span><br><span class="line">                    Class&lt;?&gt; cls = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">String</span> nm = System.getProperty(<span class="string">"awt.toolkit"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        cls = Class.forName(nm);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                        ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">                        <span class="keyword">if</span> (cl != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                cls = cl.loadClass(nm);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (final ClassNotFoundException ignored) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AWTError</span>(<span class="string">"Toolkit not found: "</span> + nm);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cls != <span class="literal">null</span>) &#123;</span><br><span class="line">                            toolkit = (Toolkit)cls.<span class="keyword">new</span><span class="type">Instance</span>();</span><br><span class="line">                            <span class="keyword">if</span> (GraphicsEnvironment.isHeadless()) &#123;</span><br><span class="line">                                toolkit = <span class="keyword">new</span> <span class="type">HeadlessToolkit</span>(toolkit);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (final InstantiationException ignored) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AWTError</span>(<span class="string">"Could not instantiate Toolkit: "</span> + nm);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (final IllegalAccessException ignored) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AWTError</span>(<span class="string">"Could not access Toolkit: "</span> + nm);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            loadAssistiveTechnologies();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toolkit;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>观察上面的代码你会发现Toolkit是一个抽象类，本身就无法实例化，而是通过反射机制加载类并创建新的实例。</p><p>懒汉式单例模式，并不会第一时间创建实例，提高了JVM的启动速度，典型的时间换空间方案，同时也体现了延迟加载的思想。</p><p>此外，需要注意的是懒汉式单例模式的线程安全问题，关于网上也有很多版本，都各有优势，大家适当取舍吧！</p><h2 id="框架中的单例"><a href="#框架中的单例" class="headerlink" title="框架中的单例"></a>框架中的单例</h2><ul><li>Mybatis中的单例模式：如ErrorContext和LogFactory。</li><li>Spring框架中的单例模式：采用单例注册表的方式进行实现中的单例模式，如AbstractBeanFactory抽象类的getBeans()方法。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这篇文章有点长，不过总算把单例模式说清楚了，哎，我的脑细胞！</p>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>git rm与git rm -cached的区别</title>
      <link>https://chloneda.github.io//blog/git-rm/</link>
      <guid>https://chloneda.github.io//blog/git-rm/</guid>
      <pubDate>Mon, 14 Oct 2019 14:45:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;git rm与git rm –cached的区别&lt;/p&gt;
&lt;p&gt;当我们需要删除暂存区或分支上的文件, 同时工作区也不需要这个文件了, 可以使用。&lt;br&gt;&lt;figure class=&quot;highlight gauss&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>git rm与git rm –cached的区别</p><p>当我们需要删除暂存区或分支上的文件, 同时工作区也不需要这个文件了, 可以使用。<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm file_path</span><br><span class="line">git commit -m '<span class="keyword">delete</span> somefile'</span><br><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure></p><p>当我们需要删除暂存区或分支上的文件, 但本地又需要使用, 只是不希望这个文件被版本控制, 可以使用。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm <span class="comment">--cached file_path</span></span><br><span class="line">git <span class="keyword">commit</span> -m <span class="string">'delete remote somefile'</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure></p><hr>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>SSH自动断开后重连的解决方案</title>
      <link>https://chloneda.github.io//blog/ssh-connect/</link>
      <guid>https://chloneda.github.io//blog/ssh-connect/</guid>
      <pubDate>Mon, 23 Sep 2019 06:38:47 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;注：本文出自博主 Chloneda&lt;/strong&gt;：&lt;a href=&quot;https://chloneda.github.io/&quot;&gt;个人博客&lt;/a&gt; | &lt;a href=&quot;https://www.cnblogs.com/chloneda&quot; target=&quot;_b
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>注：本文出自博主 Chloneda</strong>：<a href="https://chloneda.github.io/">个人博客</a> | <a href="https://www.cnblogs.com/chloneda" target="_blank" rel="noopener">博客园</a> | <a href="https://github.com/chloneda" target="_blank" rel="noopener">Github</a> | <a href="https://gitee.com/chloneda" target="_blank" rel="noopener">Gitee</a> | <a href="https://www.zhihu.com/people/chl_vip/" target="_blank" rel="noopener">知乎</a></p><h1 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h1><p>终端连接远程 SSH 服务，经常会出现长时间无操作后就自动断开，或者无响应，无法再通过键盘输入，只能强行断开重连。</p><p>那么有没有办法保持 SSH 连接不断开，或者断开连接后自动重连呢？有的！</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p><strong>方案一：客户端发送心跳</strong></p><p>Linux / Unix 下，编辑 ssh 配置文件：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="regexp">/etc/</span>ssh<span class="regexp">/ssh_config</span></span><br></pre></td></tr></table></figure></p><p>在文件中添加以下内容：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerAliveInterval <span class="number">20</span></span><br><span class="line">ServerAliveCountMax <span class="number">999</span></span><br></pre></td></tr></table></figure></p><ul><li>ServerAliveInterval：表示每隔多少秒，从客户端向服务器端发送一次心跳（alive 检测）。</li><li>ServerAliveCountMax：表示服务端多少次心跳无响应之后，客户端才会认为与服务器的 SSH 连接已经断开，然后断开连接。</li></ul><p>上述配置则表示：每隔20秒，向服务器发出一次心跳。若超过999次请求都没有发送成功，则会主动断开与服务器端的连接。</p><p><strong>方案二：服务器端发送心跳</strong></p><p>在服务器端中，编辑 ssh 配置文件：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/</span>ssh<span class="regexp">/sshd_config</span></span><br></pre></td></tr></table></figure></p><p>在文件中添加以下内容：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClientAliveInterval <span class="number">60</span></span><br><span class="line">ClientAliveCountMax <span class="number">3</span></span><br></pre></td></tr></table></figure></p><ul><li>ClientAliveInterval：表示每隔多少秒，从服务器端向客户端发送一次心跳。</li><li>ClientAliveInterval：表示客户端多少次心跳无响应之后，服务端才会认为客户端已经断开连接，然后断开连接。</li></ul><p>上述配置则表示：每隔60秒，服务器向客户端发出一次心跳。若客户端超过3次请求未响应，则会从服务器端断开与客户端的连接。</p><p>所以，总共允许无响应的时间是 60 * 3 = 180 秒以内。</p><p>其实，依赖 ssh 客户端定时发送心跳，putty、SecureCRT、XShell 工具也有这个功能。</p><p>完！</p>]]></content:encoded>
      
      
    </item>
    
  </channel>
</rss>
