<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Chloneda</title>
    <link>https://chloneda.github.io/</link>
    <atom:link href="/rss2.html" rel="self" type="application/rss+xml"/>
    
    <description>Less is more</description>
    <pubDate>Wed, 21 Aug 2019 16:59:17 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>解决Mac无法写入U盘问题</title>
      <link>https://chloneda.github.io//blog/upan-for-mac/</link>
      <guid>https://chloneda.github.io//blog/upan-for-mac/</guid>
      <pubDate>Wed, 21 Aug 2019 15:18:51 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;​   新手使用MacBook Pro时，会发现Mac系统下只能读取U盘，但不能写入。其实这个问题是因为，Mac OS系统硬盘格式为HFS，
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​   新手使用MacBook Pro时，会发现Mac系统下只能读取U盘，但不能写入。其实这个问题是因为，Mac OS系统硬盘格式为HFS， Windows 的硬盘格式为 NTFS，二者互不兼容。那么有没有解决的办法呢？</p><p>网上的资料一般都安装第三方软件，如 <strong>NTFS for MAC</strong> 等，但一般都是收费的。或者，格式化U盘，将U盘磁盘格式设定为 <strong>FAT</strong> 或 <strong>exFAT</strong>，但个人不提倡。</p><p>现在提供一种方法进行开启 Mac OS 读写 NTFS格式 U盘的功能。经过测试！</p><h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><p><strong>1</strong>、打开 终端，输入：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskutil <span class="built_in">list</span></span><br></pre></td></tr></table></figure></p><p>该命令用于列出系统下的各个磁盘信息，找到你要处理的U盘名称，如名称为：<strong>Chloneda</strong>。</p><p><strong>2</strong>、在终端中，输入：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/</span>fstab</span><br></pre></td></tr></table></figure></p><p>然后输入电脑密码（没有密码的不用输），输入电脑密码后，加入以下内容，进行配置：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash">=U盘名称 none ntfs rw,auto,nobrowse</span></span><br></pre></td></tr></table></figure></p><p>如下图：<br><img src="/uploads/vim_fstab.png" alt="vim_fstab"></p><p>注意：如果你的U盘只有一个，只需添加一个即可，不能有空行！其次，如果你的U盘含有空格，如 <strong>Chloneda X</strong>，U盘名称中的空格用\040代替，即命令应该写成：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash">=Chloneda\040X none ntfs rw,auto,nobrowse</span></span><br></pre></td></tr></table></figure></p><p>参数说明：</p><ul><li>U盘名称：建议不要有中文。</li><li>ntfs rw： 表示把这个分区挂载为可读写的 ntfs格式。</li><li>nobrowse：这个代表了在 finder 里不显示这个分区，这个选项非常重要，如果不打开的话挂载会失败。<br>完成后，按 <strong>esc</strong> 键退出编辑模式，并按  <strong>:wq!</strong> 命令，然后回车进行保存。</li></ul><p><strong>3</strong>、创建快捷方式<br>终端中输入以下内容，创建桌面快捷方式。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s <span class="regexp">/Volumes/</span>U盘名称 ~<span class="regexp">/Desktop/</span>U盘名称</span><br></pre></td></tr></table></figure></p><p>因为刚刚创建的分区是不会在 Finder 里不显示的,创建桌面快捷方式，方便以后再次访问U盘（可将 <strong>快捷方式</strong> 拖拽至 Finder 的侧边栏喔）。</p><p><strong>4</strong>、拔掉U盘，重新插入，可见正常显示，正常读写。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>1、如果不可以写入U盘，请重启一下电脑。<br>2、如果要恢复之前样子，请输入命令  <strong>sudo vim /etc/fstab</strong> 重新编辑，把写入的 <strong>LABEL</strong> 一行删除，重新保存即可。</p><hr>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>Docker容器Centos不能使用systemctl命令问题</title>
      <link>https://chloneda.github.io//blog/bug-dock-os/</link>
      <guid>https://chloneda.github.io//blog/bug-dock-os/</guid>
      <pubDate>Sun, 30 Jun 2019 03:34:06 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：本文出自博主：&lt;a href=&quot;https://chloneda.github.io/&quot;&gt;chloneda&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近使用Docker搭建Centos容器时遇到这样的问题：Centos系统的不能使用systemctl命令
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>注</strong>：本文出自博主：<a href="https://chloneda.github.io/">chloneda</a></p><p>最近使用Docker搭建Centos容器时遇到这样的问题：Centos系统的不能使用systemctl命令!</p><p><strong>具体场景</strong><br>使用 systemctl 或 service 命令重启服务时。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">systemctl</span> <span class="selector-tag">restart</span> <span class="selector-tag">snmpd</span><span class="selector-class">.service</span></span><br></pre></td></tr></table></figure></p><p>会报无权限的错误：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed <span class="keyword">to</span> <span class="builtin-name">get</span> D-Bus connection: Operation <span class="keyword">not</span> permitted；</span><br></pre></td></tr></table></figure></p><p>这是docker中centos7的bug，官网上也提到了这个问题，并给出了 <a href="https://github.com/docker-library/docs/tree/master/centos#dockerfile-for-systemd-base-image" target="_blank" rel="noopener">解决办法</a>，但有点复杂。我们可以通过以下方法解决！</p><p><strong>首先</strong>，使用docker构建centos容器加上 <strong>privileged</strong> 参数，即在docker run命令是要加上 –privileged=true，该参数在docker容器运行时，让系统拥有真正的root权限。</p><p><strong>其次</strong>，在启动容器时，在docker run 命令最后，加上/usr/sbin/init，最终命令为：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -v /tmp/:/tmp --privileged --cap-<span class="builtin-name">add</span> SYS_ADMIN -e <span class="attribute">container</span>=docker -it <span class="attribute">--name</span>=centos -d <span class="attribute">--restart</span>=always centos /usr/sbin/init</span><br></pre></td></tr></table></figure></p><p>参数说明：</p><ul><li>-v /tmp/:/tmp：挂载宿主机的一个目录，冒号”:”前面的目录是宿主机目录，后面的目录是容器内目录。</li><li><p>–privileged： 指定容器是否是特权容器。</p></li><li><p>–cap-add SYS_ADMIN： 添加系统的权限，不然系统很多功能都用不了的。</p></li><li><p>-e container=docker：设置容器的类型。</p></li><li><p>-it： 启动互动模式。</p></li><li><p>/usr/sbin/init：初始容器里的CENTOS，用于启动dbus-daemon。</p></li></ul><p><strong>最后</strong>，如果想查看Docker更多内容，请查看<a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker</a>官网文档。</p>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>那些优秀的软件工具！</title>
      <link>https://chloneda.github.io//blog/tools/</link>
      <guid>https://chloneda.github.io//blog/tools/</guid>
      <pubDate>Thu, 27 Jun 2019 16:59:36 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：本文出自博主：&lt;a href=&quot;https://chloneda.github.io/&quot;&gt;chloneda&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本博客用于收录那些优秀的软件工具，并且长期更新！&lt;/p&gt;
&lt;h1 id=&quot;Windows&quot;&gt;&lt;a href
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>注</strong>：本文出自博主：<a href="https://chloneda.github.io/">chloneda</a></p><p>本博客用于收录那些优秀的软件工具，并且长期更新！</p><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="everything"><a href="#everything" class="headerlink" title="everything"></a>everything</h2><p><a href="https://everything.en.softonic.com/" target="_blank" rel="noopener">everything</a>：是速度最快的文件名搜索软件。其速度之快令人震惊，百G硬盘几十万个文件，可以在几秒钟之内完成索引；文件名搜索瞬间呈现结果。它小巧免费，支持中文，支持正则表达式，可以通过HTTP或FTP分享搜索结果。如果不满意Windows自带的搜索工具，那就用它吧！</p><h1 id="MacOs"><a href="#MacOs" class="headerlink" title="MacOs"></a>MacOs</h1><h2 id="eZip"><a href="#eZip" class="headerlink" title="eZip"></a>eZip</h2><p><a href="https://ezip.awehunt.com/" target="_blank" rel="noopener">eZip</a>：是一款 Mac 上完全免费的压缩与解压缩工具软件，主要是提供了文件预览以及加密压缩和解压缩功能，功能足够实用，基本可以替代市面上大部分的 macOS 商业收费压缩工具，个人认为值得力荐。</p><h2 id="OmniGraffle"><a href="#OmniGraffle" class="headerlink" title="OmniGraffle"></a>OmniGraffle</h2><p><a href="https://www.omnigroup.com/omnigraffle" target="_blank" rel="noopener">OmniGraffle</a>：Windows下使用Visio画框图、流程图非常方便，切换到MAC后，我们可以使用OmniGraffle。</p><h2 id="CheatSheet"><a href="#CheatSheet" class="headerlink" title="CheatSheet"></a>CheatSheet</h2><p><a href="https://cheatsheet-mac.en.softonic.com/mac" target="_blank" rel="noopener">CheatSheet</a>：Mac上的快捷键神器</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Remmina"><a href="#Remmina" class="headerlink" title="Remmina"></a>Remmina</h2><p><a href="https://remmina.org/" target="_blank" rel="noopener">Remmina</a>：是一款在 Linux 和其他类 Unix 系统下的自由开源、功能丰富、强大的远程桌面客户端，它用 GTK+ 3 编写而成。它适用于那些需要远程访问及使用许多计算机的系统管理员和在外出行人员。</p>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>git同步代码至github和gitee(码云)</title>
      <link>https://chloneda.github.io//blog/git-to-github-gitee/</link>
      <guid>https://chloneda.github.io//blog/git-to-github-gitee/</guid>
      <pubDate>Thu, 20 Jun 2019 13:31:06 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：本文出自博主：&lt;a href=&quot;https://chloneda.github.io/&quot;&gt;chloneda&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们有时候开发代码需要把代码同步到多个远程库中，如何操作才能做到呢？&lt;/p&gt;
&lt;p&gt;我们知道，git是分布
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>注</strong>：本文出自博主：<a href="https://chloneda.github.io/">chloneda</a></p><p>我们有时候开发代码需要把代码同步到多个远程库中，如何操作才能做到呢？</p><p>我们知道，git是分布式版本控制系统，同步到多个远程库时，需要用不同的名称来标识不同的远程库，而git给远程库起的默认名称是origin。所以我们需要修改、配置名称，以关联不同远程库。有两种方式！</p><p>为了方便举例，我以GitHub和Gitee(码云)作为示例！</p><h1 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h1><h2 id="命令方式同步"><a href="#命令方式同步" class="headerlink" title="命令方式同步"></a>命令方式同步</h2><p>先删除已关联的名为origin的远程库：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git remote rm origin</span></span><br></pre></td></tr></table></figure></p><p>然后，再关联GitHub的远程库：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> github git@github.com:chloneda/demo.git</span></span><br></pre></td></tr></table></figure></p><p>接着，再关联码云的远程库：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> gitee git@gitee.com:chloneda/demo.git</span></span><br></pre></td></tr></table></figure></p><h2 id="配置方式同步"><a href="#配置方式同步" class="headerlink" title="配置方式同步"></a>配置方式同步</h2><p>修改.git文件夹内的config文件：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">repositoryformatversion = <span class="number">0</span></span><br><span class="line">filemode = <span class="keyword">true</span></span><br><span class="line">bare = <span class="keyword">false</span></span><br><span class="line">logallrefupdates = <span class="keyword">true</span></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">url = git<span class="variable">@github</span>.<span class="symbol">com:</span>chloneda/demo.git</span><br><span class="line">fetch = +refs/heads/*<span class="symbol">:refs/remotes/github/*</span></span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">remote = origin</span><br><span class="line">merge = refs/heads/master</span><br></pre></td></tr></table></figure></p><p>将上述文件内容[remote “origin”]内容复制，修改origin名称，内容如下：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">repositoryformatversion = <span class="number">0</span></span><br><span class="line">filemode = <span class="keyword">true</span></span><br><span class="line">bare = <span class="keyword">false</span></span><br><span class="line">logallrefupdates = <span class="keyword">true</span></span><br><span class="line">[remote <span class="string">"github"</span>]</span><br><span class="line">url = git<span class="variable">@github</span>.<span class="symbol">com:</span>chloneda/demo.git</span><br><span class="line">fetch = +refs/heads/*<span class="symbol">:refs/remotes/github/*</span></span><br><span class="line">[remote <span class="string">"gitee"</span>]</span><br><span class="line">url = git<span class="variable">@gitee</span>.<span class="symbol">com:</span>chloneda/demo.git</span><br><span class="line">fetch = +refs/heads/*<span class="symbol">:refs/remotes/gitee/*</span></span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">remote = origin</span><br><span class="line">merge = refs/heads/master</span><br></pre></td></tr></table></figure></p><h1 id="查看远程库"><a href="#查看远程库" class="headerlink" title="查看远程库"></a>查看远程库</h1><p>通过以上两种方式的任一种方式配置完成后，我们用git remote -v查看远程库信息：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gitee   git@gitee<span class="selector-class">.com</span>:chloneda/demo<span class="selector-class">.git</span> (fetch)</span><br><span class="line">gitee   git@gitee<span class="selector-class">.com</span>:chloneda/demo<span class="selector-class">.git</span> (push)</span><br><span class="line">github  git@github<span class="selector-class">.com</span>:chloneda/demo<span class="selector-class">.git</span> (fetch)</span><br><span class="line">github  git@github<span class="selector-class">.com</span>:chloneda/demo<span class="selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure></p><p>可以看到两个远程库，说明配置生效了。</p><h1 id="上传代码"><a href="#上传代码" class="headerlink" title="上传代码"></a>上传代码</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> .</span></span><br><span class="line">git commit -m <span class="string">"update"</span></span><br></pre></td></tr></table></figure><h1 id="提交到github"><a href="#提交到github" class="headerlink" title="提交到github"></a>提交到github</h1><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">push </span>github master</span><br></pre></td></tr></table></figure><h1 id="提交到码云"><a href="#提交到码云" class="headerlink" title="提交到码云"></a>提交到码云</h1><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">push </span>gitee master</span><br></pre></td></tr></table></figure><h1 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h1><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 从github拉取更新</span></span><br><span class="line">git pull github</span><br><span class="line"></span><br><span class="line"><span class="meta"># 从gitee拉取更新</span></span><br><span class="line">git pull gitee</span><br></pre></td></tr></table></figure><h1 id="踩到的坑"><a href="#踩到的坑" class="headerlink" title="踩到的坑"></a>踩到的坑</h1><p>上述过程中，更新或提交代码时可能会遇到<strong>fatal:refusing to merge unrelated histories</strong> (拒绝合并无关的历史) 错误，解决办法：</p><p>首先将远程仓库和本地仓库关联起来。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="keyword">set</span>-upstream-<span class="keyword">to</span>=origin/remote_branch  your_branch</span><br></pre></td></tr></table></figure><p>其中，origin/remote_branch是你本地分支对应的远程分支，your_branch是你当前的本地分支。</p><p>然后使用git pull整合远程仓库和本地仓库。<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment">--allow-unrelated-histories    (忽略版本不同造成的影响)</span></span><br></pre></td></tr></table></figure></p><p>重新更新、提交即可。</p><p>注： 如遇到 <strong>Git没有共同祖先的两个分支合并</strong> 的情形请自行查询！</p><hr>]]></content:encoded>
      
      
    </item>
    
    <item>
      <title>聊聊SNMP协议</title>
      <link>https://chloneda.github.io//blog/snmp-protocol/</link>
      <guid>https://chloneda.github.io//blog/snmp-protocol/</guid>
      <pubDate>Fri, 14 Jun 2019 15:32:09 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：本文出自博主：&lt;a href=&quot;https://chloneda.github.io/&quot;&gt;chloneda&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;SNMP概述&quot;&gt;&lt;a href=&quot;#SNMP概述&quot; class=&quot;headerlink&quot; tit
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>注</strong>：本文出自博主：<a href="https://chloneda.github.io/">chloneda</a></p><h1 id="SNMP概述"><a href="#SNMP概述" class="headerlink" title="SNMP概述"></a>SNMP概述</h1><p>SNMP(Simple Network Management Protocol):简单网络管理协议,是基于TCP/IP五层协议中的应用层协议。由于其简单可靠，提供了一种监控和管理网络设备的系统方法，因此受到了众多厂商的欢迎，成为了目前最为广泛的网管协议。</p><p>SNMP的基本思想：为不同种类、厂家、型号的设备，定义一个统一的接口和协议，使得管理员可以是使用统一的外观面对这些需要管理的网络设备。通过网络，管理员可以管理位于不同物理空间的设备，从而大大提高网络管理的效率，简化网络管理员的工作。</p><h1 id="Snmp版本"><a href="#Snmp版本" class="headerlink" title="Snmp版本"></a>Snmp版本</h1><p>SNMP目前共有v1，v2，v3这三个版本，三个版本的联系与区别。</p><ul><li>SNMP v1：是SNMP协议的最初版本，存在较多安全缺陷，现在这个版本是使用的比较少了。 </li><li>SNMP v2：也采用团体名认证,在兼容SNMPv1的同时又扩充了SNMPv1的功能，具体是扩展了数据类型、支持分布式网络管理、可以实现大量数据的传输，提高了效率和性能、丰富了故障处理能力及增加了集合处理功能。</li><li>SNMP v3：是最新版本的SNMP。它相对于V2版本，在安全性上得到了重要提升，增加了对认证和密文传输的支持。</li></ul><h1 id="SNMP核心概念"><a href="#SNMP核心概念" class="headerlink" title="SNMP核心概念"></a>SNMP核心概念</h1><h2 id="SNMP管理架构"><a href="#SNMP管理架构" class="headerlink" title="SNMP管理架构"></a>SNMP管理架构</h2><p>SNMP管理架构应包含四个部分进行网络管理：<strong>SNMP管理站</strong>、<strong>SNMP代理</strong>、<strong>MIB(管理信息库)</strong>和<strong>SNMP管理协议</strong>。</p><p><strong>SNMP管理站</strong>（management station）：通常被称作为网络管理工作站（NMS），负责收集维护各个SNMP元素的信息，通过UDP协议向SNMP代理发送各种命令，当SNMP代理收到命令后，对收集的信息进行处理，并返回SNMP管理站需要的参数。而此时被管理对象中一定要有代理进程，这样才能响应管理站发来的请求。</p><p><strong>SNMP代理</strong>(Agent)：运行在各个被管理的网络节点之上，负责统计该节点的各项信息，并且负责与SNMP管理站交互，接收并执行管理站的命令，上传各种本地的网络信息。</p><p><img src="/uploads/snmp_Structure.png" alt="snmp_structure"></p><p><strong>注</strong>：协议栈中带有阴影的部分是原主机或路由器所具有的，而没有阴影的部分是为实现网络管理而增加的。<br>　　<br><strong>MIB(管理信息库)</strong>：是对象的集合，它代表网络中可以管理的资源和设备。每个对象基本上是一个数据变量，它代表被管理的对象的一方面的信息。</p><p><strong>SNMP管理协议</strong>：用于管理站与SNMP代理之间的通信规则，其SNMP报文格式请查看底下章节。</p><p>管理站和代理之间利用 SNMP 报文进行通信，而 SNMP 报文又使用 UDP协议来传送，由于采用UDP协议，不需要在代理和管理站之间保持连接。　</p><h2 id="SNMP报文格式"><a href="#SNMP报文格式" class="headerlink" title="SNMP报文格式"></a>SNMP报文格式</h2><p>管理站（NMS）和代理（Agent）之间交换的管理信息构成了SNMP报文，报文的基本格式如下图：</p><p><img src="/uploads/snmp_MessageFormat.png" alt="snmp_MessageFormat.png"></p><p><strong>下面将对该SNMP报文格式逐个进行说明！</strong></p><p>SNMP消息报文包含两个部分：SNMP报头和PDU(协议数据单元)。</p><p><strong>SNMP报头</strong></p><ul><li>版本：版本号字段，规则为版本号减 1，如SNMP V1则应写入 0。如果SNMP代理使用不相同的协议，会直接抛弃与自己协议版本不同的数据报。</li><li>共同体(community)：即团体名，作为管理进程和代理进程之间的明文口令，相当于密码，默认为public，该字段可读可写，用来限制NMS对Agent的访问。如果团体名没有得到NMS/Agent的认可，该报文将被丢弃。</li><li>PDU 类型：填入 0～4 中的一个数字，其对应关系如图。</li></ul><p><img src="/uploads/snmp_PDUType.png" alt="snmp_PDUType.png"></p><p>PDU类型请参考<strong>PDU(协议数据单元)</strong>章节！</p><p><strong>Get/Set 首部</strong></p><ul><li>请求标识符(request ID)，这是由管理进程设置的一个整数值。代理进程在发送 get-response 报文时也要返回此请求标识符。管理进程可同时向许多代理发出 get 报文，这些报文都使用 UDP 传送，先发送的有可能后到达。设置了请求标识符可使管理进程能够识别返回的响应报文对于哪一个请求。</li><li>差错状态（error status）：由代理进程回答时填入 0～5 中的一个数字，见表 3 的描述。</li></ul><p><img src="/uploads/snmp_ErrorStatus.png" alt="snmp_ErrorStatus.png"></p><ul><li>差错索引(error index)：当出现 noSuchName、badValue 或 readOnly 的差错时，由代理进程在回答时设置的一个整数，它指明有差错的变量在变量列表中的偏移。</li></ul><p><strong>Trap 首部</strong></p><ul><li>企业（enterprise）：填入 trap 报文的网络设备的对象标识符。此对象标识符肯定是在图 3 的对象命名树上的 enterprise 结点{1.3.6.1.4.1}下面的一棵子树上。</li><li>Trap 类型：此字段正式的名称是 generic-trap，共分为表 4 中的 7 种。</li></ul><p><img src="/uploads/snmp_TrapType.png" alt="snmp_TrapType.png"> </p><p>当使用上述类型 2、3、5 时，在报文后面变量部分的第一个变量应标识响应的接口。</p><ul><li>特定代码(specific-code)：指明代理自定义的时间（若 trap 类型为 6），否则为 0。</li><li>时间戳(timestamp)：指明自代理进程初始化到 trap 报告的事件发生所经历的时间，单位为 10ms。例如时间戳为 1908 表明在代理初始化后 1908ms 发生了该时间。</li><li>变量绑定(variable-bindings)：指明一个或多个变量的名和对应的值。在 get 或 get-next 报文中，变量的值应忽略。</li></ul><h2 id="PDU-协议数据单元"><a href="#PDU-协议数据单元" class="headerlink" title="PDU(协议数据单元)"></a>PDU(协议数据单元)</h2><p>SNMP v1 版本规定了 5 种核心 PDU(协议数据单元)，用来在管理进程和代理之间信息的交换。</p><ul><li>get-request 操作：从代理进程处提取一个OID值。</li><li>get-next-request 操作：从代理进程(MIB中)处提取紧跟当前参数值的下一个OID值，常被用于检索表数据，也被用于不能指定名称的变量,可以浏览MIB树。</li><li>set-request 操作：设置代理进程的一个或多个参数值。</li><li>get-response 操作：返回的一个或多个参数值。这个操作是由代理进程发出的，它是前面三种操作的响应操作。</li><li>trap 操作：代理进程主动发出的报文，通知管理进程有某些事情发生。</li></ul><p>前面的 3 种操作是由管理进程向代理进程发出的，后面的 2 个操作是代理进程发给管理进程的，其中代理进程端是用 161 端口接收 get 或 set 报文，而在管理进程端是用 162 端口来接收 trap 报文。</p><p><img src="/uploads/snmp_fivePDU.png" alt="snmp_fivePDU.png"> </p><p>另外，在SNMP v2版本又增加了 3 种PDU(协议数据单元)，它们分别是：</p><ul><li>inform-request 操作：允许路由器向SNMP管理器发送通知请求。</li><li>getBulk-request 操作：从代理进程处提取多个参数值,该操作会根据最大重试值执行一连串的GetNext操作，减少管理站与代理之间的交互,提高效率。</li><li>report 操作：</li></ul><h3 id="SNMP的操作类型"><a href="#SNMP的操作类型" class="headerlink" title="SNMP的操作类型"></a>SNMP的操作类型</h3><p>其实上述 8 种PDU(协议数据单元)按照功能不同，可以归结为三类操作。</p><ul><li>查询、设置SNMP变量,如get-request、get-next-request、set-request、getBulk-request、inform-request。</li><li>应答请求,如 get-response。</li><li>事件报告，如trap。</li></ul><p>实际上，在SNMP中，SNMP管理站对被管理设备的SNMP变量的操作只能有 <strong>读</strong> 与 <strong>写</strong> 两种基本动作。</p><h2 id="ASN-1-抽象语法标记"><a href="#ASN-1-抽象语法标记" class="headerlink" title="ASN.1(抽象语法标记)"></a>ASN.1(抽象语法标记)</h2><p>ASN.1：高级的数据描述语言。描述数据的类型、结构、组织、及编码方法。包括符号和语法两部分。SNMP使用ASN.1描述PDU和MIB(管理信息库)。</p><p>关于ASN.1详细信息请查看这篇博文：<a href="http://blog.chinaunix.net/uid-23069658-id-3251526.html" target="_blank" rel="noopener">SNMP从入门到开发：进阶篇</a></p><h2 id="BER-基本编码规则"><a href="#BER-基本编码规则" class="headerlink" title="BER(基本编码规则)"></a>BER(基本编码规则)</h2><p><strong>BER(Basic Encoding Rule)</strong>，中文名称：基本编码规则。描述具体的ASN.1对象如何编码为比特流在网络上传输。SNMP使用BER(Basic Encoding Rule)作为编码方案，数据首先先经过BER编码，再经由传输层协议(一边是UDP)发往接收方。接收方在SNMP端口上收到PDU后，经过BER解码后，得到具体的SNMP操作数据。</p><p>BER的数据都由三个域构成:标识域(tag)+长度域(length)+值域(value)。</p><h2 id="SMI-管理信息结构"><a href="#SMI-管理信息结构" class="headerlink" title="SMI(管理信息结构)"></a>SMI(管理信息结构)</h2><p><strong>SMI(Structure of Managerment Intormation)</strong>，中文名称：管理信息结构，是SNMP的描述方法。规定了使用ASN.1子类型、符号。ASN.1功能强大，但SNMP只用到了其中很小一部分，对于这一部分内容的描述，限定了范围，即为SMI。SMI规定了使用到的ASN.1类型、宏、符号等。SMI是ASN.1的一个子集和超集。</p><h2 id="MIB-管理信息库"><a href="#MIB-管理信息库" class="headerlink" title="MIB(管理信息库)"></a>MIB(管理信息库)</h2><p><strong>MIB(Management Information Base)</strong>，中文名称：管理信息库，由网络管理协议访问的管理对象数据库。MIB是对象的集合，它代表网络中可以管理的资源和设备。每个对象基本上是一个数据变量，它代表被管理的对象的一方面的信息。</p><p>管理信息库 MIB 指明了网络元素所维持的变量（即能够被管理进程查询和设置的信息）。MIB 给出了一个网络中所有可能的被管理对象的集合的数据结构。SNMP 的管理信息库采用和域名系统 DNS 相似的树型结构，它的根在最上面，根没有名字。底下的图 画的是管理信息库的一部分，它又称为对象命名（object naming tree）。</p><p>MIB采用分层树形结构，对象命名树的顶级对象有三个，即 ISO、ITU-T 和这两个组织的联合体。在 ISO 的下面有 4 个结点，其中的饿一个（标号 3）是被标识的组织。在其下面有一个美国国防部（Department of Defense）的子树（标号是 6），再下面就是 Internet（标号是 1）。在只讨论 Internet 中的对象时，可只画出 Internet 以下的子树（图中带阴影的虚线方框），并在 Internet 结点旁边标注上{1.3.6.1}即可。</p><p>在 Internet 结点下面的第二个结点是 mgmt（管理），标号是 2。再下面是管理信息库，原先的结点名是 mib。1991 年定义了新的版本 MIB-II，故结点名现改为 mib-2，其标识为{1.3.6.1.2.1}，或{Internet(1) .2.1}。这种标识为对象标识符。</p><p><img src="/uploads/snmp_Mib.png" alt="snmp_Mib.png"></p><p>最初的结点 mib 将其所管理的信息分为 8 个类别，如图，现在的 mib-2 所包含的信息类别已超过 40 个。</p><p><img src="/uploads/snmp_MibInfoType.png" alt="snmp_MibInfoType.png"></p><p>应当指出，MIB 的定义与具体的网络管理协议无关，这对于厂商和用户都有利。厂商可以在产品（如路由器）中包含 SNMP 代理软件，并保证在定义新的 MIB 项目后该软件仍遵守标准。用户可以使用同一网络管理客户软件来管理具有不同版本的 MIB 的多个路由器。当然，一个没有新的 MIB 项目的路由器不能提供这些项目的信息。这里要提一下MIB中的对象{1.3.6.1.4.1}，即enterprises（企业），其所属结点数已超过 3000。例如IBM为{1.3.6.1.4.1.2}，Cisco为{1.3.6.1.4.1.9}，Novell为{1.3.6.1.4.1.23}等。世界上任何一个公司、学校只要用电子邮件发往<a href="mailto:iana-mib@isi.edu" target="_blank" rel="noopener">iana-mib@isi.edu</a>进行申请即可获得一个结点名。这样各厂家就可以定义自己的产品的被管理对象名，使它能用SNMP进行管理。</p><h2 id="ASN-1、BER、SMI、MIB、PDU的关系"><a href="#ASN-1、BER、SMI、MIB、PDU的关系" class="headerlink" title="ASN.1、BER、SMI、MIB、PDU的关系"></a>ASN.1、BER、SMI、MIB、PDU的关系</h2><p>关于ASN.1、BER、SMI、MIB、PDU的关系如下图所示。<br><img src="/uploads/snmp_SMI_MIB.png" alt="snmp_SMI_MIB.png"></p><h2 id="OID-对象标识符"><a href="#OID-对象标识符" class="headerlink" title="OID(对象标识符)"></a>OID(对象标识符)</h2><p><strong>OID(Object Identifier)</strong>，中文名称：对象标识符，被管理设备的每个管理资源和对象都有自己的OID(Object Identifier)，管理对象通过树状结构进行组织，OID由树上的一系列整数组成，整数之间用点( . )分隔开，树的叶子节点才是真正能够被管理的对象。</p><h2 id="常用OID"><a href="#常用OID" class="headerlink" title="常用OID"></a>常用OID</h2><p>这里总结了一些常用的OID，当需要时可以及时查询。<br><a href="http://oid-info.com/cgi-bin/display?tree=1.3.6" target="_blank" rel="noopener">SNMP监控常用OID查询</a><br><a href="https://blog.csdn.net/a9254778/article/details/51200502" target="_blank" rel="noopener">SNMP监控一些常用OID的总结</a><br><a href="http://www.oidview.com/mibs/2021/UCD-SNMP-MIB.html" target="_blank" rel="noopener">下载不同厂商的MIB包</a><br><a href="https://www.alvestrand.no/objectid/1.3.6.1.4.1.html" target="_blank" rel="noopener">查看不同厂商的OID代号</a></p><h1 id="SNMP协议实现"><a href="#SNMP协议实现" class="headerlink" title="SNMP协议实现"></a>SNMP协议实现</h1><p>SNMP协议的Java实现是SNMP4J，其jar包可以在<a href="http://www.snmp4j.org/" target="_blank" rel="noopener">SNMP官方网站</a>上下载。开发前请简单了解一下SNMP4J，具体细节请看这篇博文：<a href="https://www.cnblogs.com/xdp-gacl/p/4187089.html" target="_blank" rel="noopener">SNMP4J介绍</a>；更多SNMP4J示例请参考<a href="https://github.com/chloneda/snmp/" target="_blank" rel="noopener">Github</a>。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>SNMP支持Window、Linux、MacOS系统的安装，关于SNMP的安装步骤请自行查询。</p><hr>]]></content:encoded>
      
      
    </item>
    
  </channel>
</rss>
